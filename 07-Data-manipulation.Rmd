
#  数据处理之-dplyr {#Data:Manipulation-dplyr}


本章节主要目的是通过阐述dplyr动词用法，实现与`Excel透视表`或`sql`相同功能，从而达到不同的数据整理、聚合需求。

本章主要从以下方面阐述：

1. 行条件筛选
2. 列筛选
3. 字段重命名
4. 列位置排序
5. 行排序
6. 新增计算字段
7. 分组聚合
8. 表关联
9. 行列操作
10. 使用dplyr编写自定义函数


其中9,10行列操作和自定义函数有一定难度，大家可以先熟悉dplyr基本用法后再了解其用法。

与`sql`相比，用dplyr的优势：

- 代码量极大减少

- 逻辑复杂时，dplyr动词可以按照顺序一步步实现，无需嵌套，实现过程简单

- 代码可读性好

- 配合`dbplyr`包使用，大部分情况下可以扔掉`sql`语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用


> 本章节中部分案例照搬dplyr包的官方案例，
dplyr动词从数据库相关操作中抽象而来，从sql迁移成本低



## 前言 {#dplyr:description}


`dplyr`包是`tidyverse`系列的核心包之一。dplyr是**A Grammar of Data Manipulation **，即dplyr是数据处理的语法。数据操作在数据库中往往被增、改、删、查四字描述，加上表连接查询基本涵盖了大部分的数据操作。


`dplyr`包通过提供一组动词来解决最常见的数据处理问题：

- `mutate()` 添加新变量,现有变量的函数

- `select()` 筛选列,根据现有变量名称选择变量

- `filter()` 筛选行，根据条件筛选

- `summarise()` 按照一定条件汇总聚合

- `arrange()` 行排序

以上动词都可以和`group_by()`结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过`vignette("two-table")`查看学习。   


###  安装 {#dplyr:install-package}

dplyr包可以直接安装。

```{r eval=FALSE}
## 最简单是的方式就是安装tidyverse
install.packages('tidyverse')

## 或者仅仅安装 tidyr:
install.packages('dplyr')

## 或者从github 安装开发版本
## install.packages("devtools")
devtools::install_github("tidyverse/dplyr")
```

在开始使用前，请确保自己dplyr版本是较新版本，因为1.0.0版本有较大更新。

```{r}
packageVersion('dplyr')
```


### Excel and Sql 类比{#dplyr:difference-of-sql}

与Excel相比,dplyr使用`filter`实现筛选，`mutate`实现列新增计算，`summarise`配合`group_by`实现数据透视表，`arrange`实现排序功能。
`dplyr::left_join()`等表连接功能，实现Excel中的`vlookup`,`xlookup`等函数效果。

请看案例：

>案例中使用的数据集是R包`nycflights13`带的flights数据集。

Excel实现

![透视表截图](./picture/data-table/01picture.png)


R实现：

```{r message=FALSE,warning=FALSE}
library(tidyverse,warn.conflicts = FALSE)
data <- readr::read_csv("./data/flights.csv")

data %>% 
  filter(year==2014,month==6) %>% 
  group_by(origin,dest) %>% 
  summarise(distance求和项 = sum(distance))

```

Sql实现：


```{r include=FALSE}
library(DBI)
data <- readr::read_csv("C:/Users/zhongyf/Desktop/Rbook/data/flights.csv")
conn <- dbConnect(RSQLite::SQLite(), ":memory:")
RSQLite::dbWriteTable(conn,'flights',data)
```


```{sql connection=conn}
select origin,dest,sum(distance) distance求和项 from flights where year = 2014 and month =6 group by origin,dest
```


<!-- 本处很奇怪，无法正确编译通过 -->

<!-- 后来排查是因为每个Rmd前面得全局设置问题 -->


### 常见问题

1. 筛选订单表中的1-5月订单数据，按照城市汇总，求每个城市的销售额和门店数(去重)?


```{r eval=FALSE}
data %>% 
  filter(between(月,1,5)) %>% 
  group_by(城市) %>% 
  summarise(金额 = sum(金额),门店数 = n_distinct(门店编码))
```

2. 近30天商品销量排名?


```{r eval=FALSE}
data %>% 
  filter(订单日期 >= Sys.Date()-30) %>% 
  group_by(分析大类,商品编码) %>% 
  summarise(商品销量 = sum(数量)) %>% 
  group_by(分析大类) %>% 
  mutate(商品排名 = dense_rank(desc(商品销量))) 
# 注意用desc倒序，销量高排第一
```

3. 销售和库存形成笛卡尔积表，计算商品有货率、动销率?


**Cheat Sheet**

手册搬运于dplyr[官方介绍](https://dplyr.tidyverse.org/),方便下载查阅。

![dplyr-sheet](./picture/dplyr/data-transformation.pdf){width=100% height=400}

Rstudio提供的其它手册:<https://www.rstudio.com/resources/cheatsheets/>





## 基础用法 {#dplyr:usage}

基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述`dplyr`动词功能。

首先加载包，加载包时可能会有一些重名函数的提示，可以通过warn.conflict参数禁掉提示。如下所示：

```{r}
# 禁掉提示
library(dplyr,warn.conflicts = FALSE)
```

### filter{#dplyr-filter}

`filter`动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和`SQL`中`where`条件一致。

filter条件筛选中可以分为单条件筛选和多条件筛选；多条件中间用`,`分隔。

- 单条件

条件为` species == "Droid" `时，如下所示：

```{r}
starwars %>% 
  filter(species == "Droid")
```

```{sql eval = FALSE}
select * from starwars where species = "Droid" -- 注意=与==的区别
```


- 多条件

多条件筛选时，用英文逗号隔开多个条件。用“and”连接多个条件与用逗号隔开效果相同,“and”在R中用&表示。

```{r}
starwars %>% 
  filter(species == "Droid",skin_color == "gold")

# same above
# starwars %>% 
#   filter(species == "Droid" & skin_color == "gold")

```



```{sql eval =FALSE}
select * from starwars where species = "Droid" and skin_color = "gold" 
```


- 多情况筛选

类似`SQL`中 `in` 的用法，或Excel中筛选条件时"或"条件


```{r}
starwars %>% 
  filter(species %in%  c("Droid",'Clawdite'))
```


```{sql eval = FALSE}
select * from starwars where species in ("Droid","Clawdite") --sql查询
```


- 逻辑关系筛选

条件运算分为逻辑运算、关系运算。

关系运算符 >、<、==、!=、>=、<=分别代表大于、小于、等于、不等于、大于等于、小于等于。

逻辑运算符 &、|、！。 `|`为 或, `&` 为并、且条件，`!`为非。

```{r}
library(nycflights13)
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)

# same above
filter(flights, arr_delay <= 120 & dep_delay <= 120)

# %in% 的反面
starwars %>% 
  filter(!species %in%  c("Droid",'Clawdite'))
```

> !的运算级别相比 %in% 更高


### select  {#dplyr-select}

当完整数据集列较多时，我们某次分析可能并不需要那么多列，通过动词`select()`筛选列,剔除不需要的列。

- 基础用法

通过指定列名称筛选，并指定列之间顺序

```{r}
starwars %>% 
  select(name,height,mass,hair_color,skin_color,eye_color)
```

- 列索引

通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。

```{r}
starwars %>% 
  select(name : eye_color)

#same above
starwars %>% 
  select(1:6)

# starwars %>% select(c(1,2,4,5,7))


```

- 新增列筛选方式

```{r}
# starwars %>% select(!(name:mass))
# iris %>% select(!ends_with("Width"))
# iris %>% select(starts_with("Petal") & ends_with("Width"))
# iris %>% select(starts_with("Petal") | ends_with("Width"))
```


### rename {#dplyr-rename}

列重命名使用`rename()`函数，新名称写前面，如下所示：

```{r rename}
starwars %>% rename(home_world = homeworld)
# 多列同换
starwars %>% rename(home_world = homeworld,skincolor = skin_color)
```

```{sql eval = FALSE}
select * ,homeworld as home_word from starwars 
select * ,homeworld  home_word from starwars 
```

> as 可以省略，但中间有一个以上空格。与R的差异是新增home_word列，原始列继续存在，R中是替换列名。


### relocate {#dplyr-relocate}

更改列顺序，与使用`select()`动词指定列顺序功能相似。

relocate参数如下：

```{r eval=FALSE}
relocate(.data, ..., .before = NULL, .after = NULL)
```


```{r}
# sex:homeworld列在height列前面
starwars %>% relocate(sex:homeworld, .before = height)
```


### mutate {#dplyr-mutate}

动词`mutate`可以新增计算列，删除列，更新已有列，列之间的计算都可以通过mutate实现。

- 新增计算列

```{r}
starwars %>% 
  mutate(bmi = mass / ((height / 100)  ^ 2)) %>% 
  select(name:mass,bmi)
```

- 新增计算列基础上新增列

```{r}
starwars %>% 
  mutate(bmi = mass / ((height / 100)  ^ 2),newbmi = bmi *2) %>% 
  select(name:mass,bmi,newbmi)
```



- 删除列

```{r}
starwars %>% mutate(height = NULL)
```


### arrange {#dplyr-arrange}

- 单列排序，默认升序，通过`desc()`降序排列


```{r}
starwars %>% 
  arrange(desc(mass))
```

- 多列排序

```{r}
starwars %>% 
  arrange(height,desc(mass))
```


```{sql eval=FALSE}
select * from starwars order by height,mass desc
```



### summarise {#dplyr-summarise}

`summarise`常与`group_by`结合使用。

```{r}
mtcars %>%
  summarise(mean = mean(disp), n = n())
```

> n()是dplyr包中的计算当前组大小的函数，用在summarise()和mutate()中。通常用来组计算。

### group_by {#dplyr-groupby}

聚合前一般都需要分组，`group_by()`动词实现该功能，与`SQL`中`group by ···`类似。

```{r}
starwars %>%
  group_by(species) %>%
  summarise(
    n = n(),
    mass = mean(mass, na.rm = TRUE)
  )
```

```{sql eval=FALSE}
SELECT species,
  count(species) n,
  AVG(mass) mass
FROM [spb].[dbo].[starwars]
GROUP BY  species
```






## 常用函数 {#dplyr-functions}

本小节介绍dplyr处理数据时常用的函数，类似sql中的case_when、count、distinct、row_number、between等函数。

### 条件判断 

相比于`base::ifelse`,`if_else`输出类型更为严格，无论`TRUE`或`FALSE`输出类型一致，这样计算速度更快。

> 与`data.table::fifelse()`功能相似

`if_else()`参数

```{r dplyr-ifelse ,eval=FALSE}
if_else(condition, true, false, missing = NULL)
```

与`ifelse`不同的是，`if_else`保留类型

```{r dplyr-ifelse-1}
x <- factor(sample(letters[1:5], 10, replace = TRUE))
ifelse(x %in% c("a", "b", "c"), x, factor(NA))
if_else(x %in% c("a", "b", "c"), x, factor(NA))
```


### case_when 

当条件嵌套条件较多时，使用`case_when`,使代码可读并且不易出错。与sql 中的case when 等价。

```{r dplyr-casewhen}
Dates <- as.Date(c('2018-10-01', '2018-10-02', '2018-10-03','2018-10-04'))
case_when(
  Dates == '2018-10-01' ~ Dates - 1,
  Dates == '2018-10-02' ~ Dates + 1,
  Dates == '2018-10-03' ~ Dates + 2,
  TRUE ~ Dates
)
```

### 计数函数

- 计数

`count()`函数用来计数。下面两种表达方式等价。

```{r dplyr-count,eval =FALSE}
df %>% count(a, b)
# same above
df %>% group_by(a, b) %>% summarise(n = n())
```

```{r dplyr-count-1}
starwars %>% count(species)
# same above 等价
starwars %>% group_by(species) %>% summarise(n = n())
```


- 非重复计数

`n_distinct()`与` length(unique(x))`等价，但是更快更简洁。当我们需要给门店或订单之类数据需要去重计算时采用该函数。

```{r}
x <- sample(1:10, 1e5, rep = TRUE)
length(unique(x))
n_distinct(x)
```

### 排序函数

`dplyr`共六种排序函数，模仿SQL2003中的排名函数。

- row_number():等于 rank(ties.method = "first")
- min_rank(): 等于 rank(ties.method = "min")
- dense_rank(): 与min_rank()相似,但是没有间隔
- percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1]


```{r }
x <- c(5, 1, 3, 2, 2, NA)
row_number(x)
min_rank(x)
dense_rank(x)
percent_rank(x)
cume_dist(x)
```

### 提取向量

该系列函数是对`[[`的包装。

```{r eval=FALSE}
nth(x, n, order_by = NULL, default = default_missing(x))
first(x, order_by = NULL, default = default_missing(x))
last(x, order_by = NULL, default = default_missing(x))
```

```{r}
x <- 1:10
y <- 10:1
first(x)
last(y)
nth(x, 1)
nth(x, 5)
```


### group 系列

group_by(),group_map(), group_nest(), group_split(), group_trim()等一系列函数。

其中我常用group_by(),group_split()两个函数。group_by()是大部分数据操作中的分组操作，按照group_by()的指定分组条件。

- group_by()

```{r}
#group_by()不会改变数据框
by_cyl <- mtcars %>% group_by(cyl)
by_cyl
# It changes how it acts with the other dplyr verbs:
by_cyl %>% summarise(
  disp = mean(disp),
  hp = mean(hp)
)
# group_by中可以添加计算字段 即mutate操作
mtcars %>% group_by(vsam = vs + am) %>%
  group_vars()
```


- group_map()

group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据的数据清洗一般不涉及，常用在建模等方面。

但是目前三个函数是实验性的，未来可能会发生变化。

```{r}
# return a list
# 返回列表
mtcars %>%
  group_by(cyl) %>%
  group_map(~ head(.x, 2L))
```



```{r}
iris %>%
  group_by(Species) %>%
  group_modify(~ {
    .x %>%
      purrr::map_dfc(fivenum) %>%
      mutate(nms = c("min", "Q1", "median", "Q3", "max"))
  })
```

分组后批量输出

```{r eval=FALSE}
# group_walk
dir.create(temp <- tempfile())
iris %>%
  group_by(Species) %>%
  group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))
list.files(temp, pattern = "csv$")
unlink(temp, recursive = TRUE)
```


- group_cols()

选择分组变量

```{r}
gdf <- iris %>% group_by(Species)
gdf %>% select(group_cols())
```




### 其它函数

- between

- cummean cumsum cumall cumany

累计系列函数

```{r}
x <- c(1, 3, 5, 2, 2)
cummean(x)
cumsum(x) / seq_along(x)

cumall(x < 5)
cumany(x == 3)
```


- distinct 

```{r eval=FALSE}
df <- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)

distinct(df, x)
distinct(df, x, .keep_all = TRUE)
distinct(df, diff = abs(x - y))
```


## 表关联 {#dplyr:merge-two-table}

表关联指像`sql`中的`left join`,`inner join`等表格之间的操作，或者是Excel中`Power Piovt`建模的建立关系，从而实现不同表格间的关联。


### 基础操作 {#dplyr:merge-table-usage}

`left_join()`,`full_join`,`inner_join()`等动词关联两个表。详情请查看：`vignette("two-table")`

`left_join()`实现类似Excel中`VLOOKUP`函数功能或数据库中`left join`功能，将“右表”的字段依据“主键”关联到“左表”上。

- 基础用法

`left_join()`,`right_join()`,`full_join()`,`inner_join`()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中连接方式一致。

默认会自动寻找两表中相同的字段名作为关联的条件

```{r dplyr-merge-data}
library("nycflights13")
# Drop unimportant variables so it's easier to understand the join results.
flights2 <- flights %>% select(year:day, hour, origin, dest, tailnum, carrier)

flights2 %>% 
  left_join(airlines)
```

指定关联条件列，类似数据库中`on a.column = b.column `。

- R实现

```{r dplyr-32}
flights2 %>% left_join(planes, by = "tailnum")
```

- Sql实现

```{sql dplyr-33, eval=FALSE}
select * from flights2 a left join planes b on a.tailnum = b.tailnum 
```


- 不同名称列关联

`left_join(x,y,by = c("a" = "b", "c" = "d"))` 将会匹配 `x$a` to `y$b` 和 `x$c` to `y$d` 作为关联条件

```{r}
#出发机场和目的机场信息
flights2 %>% left_join(airports, by = c("dest" = "faa"))
#flights2 %>% left_join(airports, c("origin" = "faa"))
# 组合条件 多条件时用向量包裹即可c("dest" = "faa","cola" = "colb"))
```


- 筛选连接

`anti_join()` 删除所有左表中在右表中匹配到的行

`semi_join()`保留所有左表在右表中匹配到的行


```{r dplyr-34}
df1 <- tibble(a=letters[1:20],b=1:20)
df2 <- tibble(a=letters,b=1:26)

df1 %>% semi_join(df2)
df2 %>% anti_join(df1)
```

- 集合操作

1. `intersect(x,y)`返回x,y交集

2. `union(x,y)`返回x,y中唯一的值

3. `setdiff(x,y)`返回存在x中但是不存在y中的记录

```{r dplyr-35}
(df1 <- tibble(x = 1:2, y = c(1L, 1L)))
(df2 <- tibble(x = 1:2, y = 1:2))
intersect(df1, df2)
union(df1, df2)
setdiff(df1, df2)
setdiff(df2, df1)
```

### 多表操作 {#dplyr:merge-multiple-table}

当我们需要将多个表格连续关联时:

- 常规写法

```{r dplyr-36}
dt1 <- data.frame(x = letters)
dt2 <- data.frame(x = letters,cola = 1:26)
dt3 <- data.frame(x = letters,colb = 1:26)
dt4 <- data.frame(x = letters,cold = 1:26)
dt5 <- data.frame(x = letters,cole = 1:26)
```


```{r dplyr-37}
dt1 %>% 
  left_join(dt2) %>% 
  left_join(dt3) %>% 
  left_join(dt4) %>% 
  left_join(dt5)
```

- 改进写法

当需要合并多个表格时，可用`purrr::reduce()`实现

```{r}
dtlist <- list(dt1,dt2,dt3,dt4,dt5)
purrr::reduce(dtlist,left_join,by='x')
```



## 分组操作 {#dplyr-groupby-manipulation}

详情: <https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html>

`group_by()`最重要的分组动词,需要一个数据框和一个或多个变量进行分组：

### 添加分组

```{r dplyr-groupby-1}
by_species <- starwars %>% group_by(species)
by_sex_gender <- starwars %>% group_by(sex, gender)
```

除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在`mutate()`之后执行`group_by`:

```{r dplyr-groupby-2}
bmi_breaks <- c(0, 18.5, 25, 30, Inf)
starwars %>%
  group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %>%
  tally()
```


### 删除分组变量

要删除所有分组变量，使用`ungroup()`:

```{r dplyr-groupby-3}
by_species %>%
  ungroup() %>%
  tally()
```


### 动词

`summarise()` 计算每个组的汇总，表示从`group_keys`开始右侧添加汇总变量

```{r dplyr-groupby-4}
by_species %>%
  summarise(
    n = n(),
    height = mean(height, na.rm = TRUE)
  )
```


该`.groups=`参数控制输出的分组结构。删除右侧分组变量的历史行为对应于`.groups =` "drop_last"没有消息或.groups = NULL有消息（默认值）。

从1.0.0版开始，分组信息可以保留`(.groups = "keep")`或删除 `(.groups = 'drop)`


```{r dplyr-groupby-5}
a <- by_species %>%
  summarise(
    n = n(),
    height = mean(height, na.rm = TRUE),.groups='drop') %>% 
  group_vars()

b <- by_species %>%
  summarise(
    n = n(),
    height = mean(height, na.rm = TRUE),.groups='keep') %>% 
  group_vars()

object.size(a)
object.size(b)
```

在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。













## 列操作 {#dplyr-column-manipulation}

函数`across()`通过与`summarise()`和`mutate()`结合，很容易将某函数运用到多列上。函数`across()`取代了`summarise_all()`,`summarise_at()`,`summarise_if()`函数。

在多列上执行相同的函数是常用的操作，但是通过复制和粘贴代码，麻烦并且容易错,如下所示:

```{r eval=FALSE}
df %>% 
  group_by(g1, g2) %>% 
  summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d))
```

通过`across()`函数可以更简洁地重写上面代码：

```{r eval=FALSE}
df %>% 
  group_by(g1, g2) %>% 
  summarise(across(a:d, mean))
```

假设我们要将表格中多列向上取整?

```{r}
dt <- tibble(a= rnorm(100,mean = 1),b=rnorm(100,mean = 1),d=rnorm(100,mean = 1))
dt %>% 
  mutate(across(a:d,ceiling))
```




### 基础用法 {#dplyr-column-manipulation-basic-usage}

across() 有两个主要参数：

- 第一个参数，.cols选择要操作的列。它使用`tidyr`的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。

- 第二个参数，.fns是要应用于每一列的一个函数或函数列表。    也可以是purrr样式的公式（或公式列表），例如~ .x / 2。


```{r}
starwars %>% 
  summarise(across(where(is.character), ~ length(unique(.x))))

starwars %>% 
  group_by(species) %>% 
  filter(n() > 1) %>% 
  summarise(across(c(sex, gender, homeworld), ~ length(unique(.x))))

starwars %>% 
  group_by(homeworld) %>% 
  filter(n() > 1) %>% 
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
```

> ~ .x / 2是purr包提供的函数式编程风格，等效于 function(x) (x/2)



`across()` 不会选择分组变量：

```{r}
df <- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9))
df %>% 
  group_by(g) %>% 
  summarise(across(where(is.numeric), sum))
```

### 多种函数功能

通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量：


```{r}
min_max <- list(
  min = ~min(.x, na.rm = TRUE), 
  max = ~max(.x, na.rm = TRUE)
)
starwars %>% summarise(across(where(is.numeric), min_max))
```


通过`.names`参数控制名称：

NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时

以下是官方案例，但是报错(目前已修复)：

```{r }
starwars %>% summarise(across(where(is.numeric), min_max, .names = "{.fn}.{.col}"))
```

修改后正常运行：

```{r}
starwars %>% summarise(across(where(is.numeric), min_max, .names = "{fn}.{col}"))
```


区别主要是`.names`参数的使用方式问题，`.`加不加的问题。

```{r }

starwars %>% summarise(across(where(is.numeric), min_max, .names = "{fn}——{col}"))

```


### 当前列

如果需要，可以通过调用访问内部的“当前”列的名称`cur_column()`,仅在`across()`使用。和Excel中power pivot的"上下文"概念类似。

该函数不是特别容易理解，需要多尝试使用加深认识。

```{r}
df <- tibble(x = 1:3, y = 3:5, z = 5:7)
mult <- list(x = 1, y = 10, z = 100)

df %>% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]]))
```

代码解释：代码实现的是数据框df中列和mult中同名元素相乘得到新列。`mult[[cur_column()]]`依次返回mult[["x"]],mult[["y"]],mult[["z"]]。


以上部分是关于列操作的内容，详情查看`vignette("colwise")`。


## 行操作{#dplyr-row-manipulation}

行操作指不同字段间的计算，如`Excle`的列与列之间计算,`Excle`中的函数对行列不敏感，没有明显区别，但是`R`中`tidyverse`里列计算简单，行间计算依赖`rowwise()`函数实现。



![Excel-sum](picture/dplyr/dplyr-row-manipulation.png)

```{r}
df <- tibble(x = 1:2, y = 3:4, z = 5:6)
df %>% rowwise()
df %>% rowwise() %>% mutate(total = sum(c(x, y, z))) #返回结果与Excel一致

df %>% mutate(total = sum(c(x, y, z))) # 返回结果不符合预期
```



### 比较差异

像`group_by()`,`rowwise()`并没有做任何事情，它的作用是改变其他动词的工作方式。

注意以下代码返回结果不同:


```{r}
df %>% mutate(m = mean(c(x, y, z)))
df %>% rowwise() %>% mutate(m = mean(c(x, y, z)))
```

`df %>% mutate(m = mean(c(x, y, z)))`返回的结果是x,y,z散列全部数据的均值；`df %>% rowwise() %>% mutate(m = mean(c(x, y, z)))`通过rowwise改变了mean的作为范围，返回的某行x,y,z列3个数字的均值。两种动词的作用的范围因为rowwise完全改变。



可以选择在调用中提供“标识符”变量`rowwise()`。这些变量在您调用时被保留`summarise()`，因此它们的行为与传递给的分组变量有些相似`group_by()`：

```{r}
df <- tibble(name = c("Mara", "Hadley"), x = 1:2, y = 3:4, z = 5:6)

df %>% 
  rowwise() %>% 
  summarise(m = mean(c(x, y, z)))

df %>% 
  rowwise(name) %>% 
  summarise(m = mean(c(x, y, z)))
```


### 常用案例


```{r}
df <- tibble(x = runif(6), y = runif(6), z = runif(6))
# Compute the mean of x, y, z in each row
df %>% rowwise() %>% mutate(m = mean(c(x, y, z)))


# Compute the minimum of x and y in each row
df %>% rowwise() %>% mutate(m = min(c(x, y, z)))
# In this case you can use an existing vectorised function:
df %>% mutate(m = pmin(x, y, z))

```


键入每个变量名称很繁琐，通过`c_across()`使更简单。

>详情可见vignette("rowwise")。

```{r eval=FALSE}
rf %>% mutate(total = sum(c_across(w:z)))
rf %>% mutate(total = sum(c_across(where(is.numeric))))

rf %>% 
  mutate(total = sum(c_across(w:z))) %>% 
  ungroup() %>% 
  mutate(across(w:z, ~ . / total))
```







## `dplyr`编程{#dplyr-programming}

[Programming with dplyr](https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html)

本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。虽然复杂,但是比较实用，尤其是当我们需要定义一些通用功能函数时。

以下是对原文引用

两种情况：

- When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like `filter(df, {{ var }})`.

The following function uses embracing to create a wrapper around `summarise()` that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised:

```{r eval=FALSE}
var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)
```


- When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])).

The following example uses .data to count the number of unique values in each variable of mtcars: 

```{r eval=FALSE}
for (var in names(mtcars)) {
  mtcars %>% count(.data[[var]]) %>% print()
}
```

Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with `.data$x` or indirectly with ` .data[[var]]`. Don’t expect other functions to work with it.


### 案例

当我们不知道接下来会用哪个变量汇总时：

```{r}
my_summarise <- function(data, group_var) {
  data %>%
    group_by({{ group_var }}) %>%
    summarise(mean = mean(mass))
}
```


如果在多个位置使用：

```{r}
my_summarise2 <- function(data, expr) {
  data %>% summarise(
    mean = mean({{ expr }}),
    sum = sum({{ expr }}),
    n = n()
  )
}
```


当多个表达式时：

```{r}
my_summarise3 <- function(data, mean_var, sd_var) {
  data %>% 
    summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }}))
}
```

如果要输出变量名时：

```{r}
my_summarise4 <- function(data, expr) {
  data %>% summarise(
    "mean_{{expr}}" := mean({{ expr }}),
    "sum_{{expr}}" := sum({{ expr }}),
    "n_{{expr}}" := n()
  )
}
my_summarise5 <- function(data, mean_var, sd_var) {
  data %>% 
    summarise(
      "mean_{{mean_var}}" := mean({{ mean_var }}), 
      "sd_{{sd_var}}" := mean({{ sd_var }})
    )
}
```


任意个表达式：

这种使用场景更多

```{r}
my_summarise <- function(.data, ...) {
  .data %>%
    group_by(...) %>%
    summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE))
}
starwars %>% my_summarise(homeworld)
starwars %>% my_summarise(sex, gender)
```


## 参考资料 {#dplyr:reference-material}

1.programming <https://dplyr.tidyverse.org/dev/articles/programming.html>
2.https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html