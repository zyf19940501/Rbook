[["purrr-Iteration.html", "10 循环迭代purrr介绍", " 10 循环迭代purrr介绍 循环结构是完成重复操作一个处理框架，但是无论是 for 循环还是 apply 系列中的各个迭代函数，对于初次接触编程者而言，理解起来都略微有挑战，无论是函数的参数多样性，还是完成同一目的方法的多样性。 purrr 包的出现，在很大程度上减少初学者对于循环上手的难度。purrr 包提供一套完整且一致的函数用于处理函数和向量的工具(函数)，极大增强了 R 语言里面函数式编程，让我们以更简洁的代码替换 for 循环。如下所示： library(tidyverse) mtcars %&gt;% split(.$cyl) %&gt;% map( ~ write_excel_csv(.x,file = paste0(unique(.x$cyl),&#39;.csv&#39;))) 将数据集 mtcars 按照 cyl 字段拆分成多个数据集，并分别保存为相应名称 csv 文件。 大家可以直接阅读官方介绍purrr，或者阅读 R for Data Science 的迭代章节。 "],["安装-3.html", "10.1 安装", " 10.1 安装 安装 purrr 的最简单方法即安装tidyverse。 install.packages(&quot;tidyverse&quot;) 或者是仅仅安装 purrr: install.packages(&quot;purrr&quot;) # 安装开发版 devtools::install_github(&quot;tidyverse/purrr&quot;) "],["purrr-basic-usage.html", "10.2 常规用法", " 10.2 常规用法 10.2.1 map 系列 map 用map循环迭代,map函数始终返回list对象。 library(tidyverse) # 定义一个加10的函数 addTen &lt;- function(.x) { return(.x + 10) } map(.x = c(1, 4, 7), .f = addTen) #&gt; [[1]] #&gt; [1] 11 #&gt; #&gt; [[2]] #&gt; [1] 14 #&gt; #&gt; [[3]] #&gt; [1] 17 map_dbl 用map_dbl循环迭代，map_dbl函数返回vector。 add1 &lt;- function(x) { (x+1)*x } result1 &lt;- map_dbl(1:1000,add1) map_dbl()输出结果格式为向量。 for 循环版本： result2 &lt;- vector(length = 1000) for(i in 1:1000){ result2[i] &lt;- (i+1) * i } # 检查结果是否一样 identical(result1,result2) #&gt; [1] TRUE 10.2.2 pmap 系列 使用pmap可以实现多参数时的向量化迭代，功能极其强大。 x &lt;- list(1, 1, 1) y &lt;- list(10, 20, 30) z &lt;- list(100, 200, 300) pmap(list(x, y, z), sum) #&gt; [[1]] #&gt; [1] 111 #&gt; #&gt; [[2]] #&gt; [1] 221 #&gt; #&gt; [[3]] #&gt; [1] 331 借助数据框实现多个参数的向量化： df &lt;- data.frame( x = c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;), pattern = c(&quot;p&quot;, &quot;n&quot;, &quot;h&quot;), replacement = c(&quot;P&quot;, &quot;N&quot;, &quot;H&quot;), stringsAsFactors = FALSE ) pmap(df, gsub) #&gt; [[1]] #&gt; [1] &quot;aPPle&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;baNaNa&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;cHerry&quot; "],["purrr-map.html", "10.3 map系列函数", " 10.3 map系列函数 10.3.1 用法 map()返回列表(list) map_lgl(),map_int(),map_dbl(),map_chr()返回指定类型的原子向量,即逻辑型，整数型，实数型，字符型等。 map_dfr() 和 map_dfc()返回通过指定的行连接或列连接创建的数据框(data.frame) map(.x, .f, ...) map_lgl(.x, .f, ...) map_chr(.x, .f, ...) map_int(.x, .f, ...) map_dbl(.x, .f, ...) map_raw(.x, .f, ...) map_dfr(.x, .f, ..., .id = NULL) map_dfc(.x, .f, ...) 在 purrr 中，参数.f 可以是一个 function，formula or vector,像 ~ .x + 2 这种形式的公式会被转换成 function 使用,关于参数的引用有如下三种方式： 对一个参数，使用 . 即可 两个参数,使用 .x 和 .y 对于更多参数，使用..1,..2,..3等等 对于像 ~ .x + 2 会转换成： function(x){ x + 2 } #&gt; function(x){ #&gt; x + 2 #&gt; } # ~ .x + . y function(x,y){ x + y } #&gt; function(x,y){ #&gt; x + y #&gt; } x &lt;- list(1, 1, 1) y &lt;- list(10, 20, 30) z &lt;- list(100, 200, 300) pmap(list(x,y,z),~ (..1 + ..2 ) * ..3) #&gt; [[1]] #&gt; [1] 1100 #&gt; #&gt; [[2]] #&gt; [1] 4200 #&gt; #&gt; [[3]] #&gt; [1] 9300 ~ (..1 + ..2 ) * ..3转换成： function(x,y,z){ (x + y) * z } #&gt; function(x,y,z){ #&gt; (x + y) * z #&gt; } # pmap 实现 pmap(list(x,y,z),function(x,y,z) ( x + y ) *z) #&gt; [[1]] #&gt; [1] 1100 #&gt; #&gt; [[2]] #&gt; [1] 4200 #&gt; #&gt; [[3]] #&gt; [1] 9300 对于 purrr 风格的公式，我们可以看自己心情，可以学习这种方式也可以不学，因为用 R 里面的 function 也可以完全满足需求 map_chr map_chr(.x, .f) ,map_chr 返回对象为字符串 map_chr(letters,paste,&#39;yufei-world&#39;,sep=&#39;-&#39;) #&gt; [1] &quot;a-yufei-world&quot; &quot;b-yufei-world&quot; &quot;c-yufei-world&quot; &quot;d-yufei-world&quot; #&gt; [5] &quot;e-yufei-world&quot; &quot;f-yufei-world&quot; &quot;g-yufei-world&quot; &quot;h-yufei-world&quot; #&gt; [9] &quot;i-yufei-world&quot; &quot;j-yufei-world&quot; &quot;k-yufei-world&quot; &quot;l-yufei-world&quot; #&gt; [13] &quot;m-yufei-world&quot; &quot;n-yufei-world&quot; &quot;o-yufei-world&quot; &quot;p-yufei-world&quot; #&gt; [17] &quot;q-yufei-world&quot; &quot;r-yufei-world&quot; &quot;s-yufei-world&quot; &quot;t-yufei-world&quot; #&gt; [21] &quot;u-yufei-world&quot; &quot;v-yufei-world&quot; &quot;w-yufei-world&quot; &quot;x-yufei-world&quot; #&gt; [25] &quot;y-yufei-world&quot; &quot;z-yufei-world&quot; 10.3.2 案例 map map()函数返回列表，如下： 1:10 %&gt;% map(rnorm, n = 10) # 用匿名函数 1:10 %&gt;% map(function(x) rnorm(10, x)) # purrr 风格公式 1:10 %&gt;% map(~ rnorm(10, .x)) 使用map()提取列表对象中的列表元素: l2 &lt;- list( list(num = 1:3, letters[1:3]), list(num = 101:103, letters[4:6]), list() ) l2 %&gt;% map(c(2, 2)) #&gt; [[1]] #&gt; [1] &quot;b&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;e&quot; #&gt; #&gt; [[3]] #&gt; NULL 提取每个列表中的元素，上述代码表示提取列表中第二个对象的第二位置的元素： list(num = 1:3,letters[1:3])[[2]][2] #&gt; [1] &quot;b&quot; list(num = 101:103, letters[4:6])[[2]][2] #&gt; [1] &quot;e&quot; 通过list构建由“名称”和“数字”构建的提取器提取元素： l2 %&gt;% map(list(&quot;num&quot;, 3)) #&gt; [[1]] #&gt; [1] 3 #&gt; #&gt; [[2]] #&gt; [1] 103 #&gt; #&gt; [[3]] #&gt; NULL l2 %&gt;% map_int(list(&quot;num&quot;, 3), .default = NA) #&gt; [1] 3 103 NA map_dbl map_dbl()返回数字向量(双精度)。 1:10 %&gt;% map(rnorm, n = 10) %&gt;% #输出列表 map_dbl(mean) #&gt; [1] 0.559 1.821 2.876 4.152 5.116 6.127 6.911 8.281 9.237 10.627 在数据框上应用，由于数据框(data.frame)可以看成是特殊的列表，df[[1]],df[[2]],df[[3]]等。 mtcars %&gt;% map_dbl(sum) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 643 198 7383 4694 115 103 571 14 13 118 90 上述计算可以理解为计算:sum(mtcars[[1]]),sum(mtcars[[2]]),sum(mtcars[[3]])等。 map_chr map_chr()返回字符向量。 c(&quot;foo&quot;, &quot;bar&quot;) %&gt;% map_chr(paste0, &quot;:suffix&quot;) #&gt; [1] &quot;foo:suffix&quot; &quot;bar:suffix&quot; favorite_desserts &lt;- list(Sophia = &quot;banana bread&quot;, Eliott = &quot;pancakes&quot;, Karina = &quot;chocolate cake&quot;) favorite_desserts %&gt;% map_chr(~ paste(.x, &quot;rocks!&quot;)) #&gt; Sophia Eliott Karina #&gt; &quot;banana bread rocks!&quot; &quot;pancakes rocks!&quot; &quot;chocolate cake rocks!&quot; map_int 通过名字或者是数字位置提取内容。 l1 &lt;- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L)) l1 %&gt;% map(&quot;a&quot;, .default = &quot;???&quot;) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;???&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;???&quot; l1 %&gt;% map_int(&quot;b&quot;, .default = NA) #&gt; [1] NA 2 3 l1 %&gt;% map_int(2, .default = NA) #&gt; [1] NA 2 NA map_df map_df(.x, .f),map_df 返回对象为数据框,类似函数 map_dfr(.x,.f),map_dfc(.x,.f) map_df()函数示例 map_df(c(1, 4, 7), function(.x) { return(data.frame(old_number = .x, new_number = addTen(.x))) }) #&gt; old_number new_number #&gt; 1 1 11 #&gt; 2 4 14 #&gt; 3 7 17 make_dataframe &lt;- function(x){ data.frame(old_number = x,new_number = addTen(x)) } map_dfr(c(1,4,7),make_dataframe) #&gt; old_number new_number #&gt; 1 1 11 #&gt; 2 4 14 #&gt; 3 7 17 在数据导入导出章节中提到的批量读取,通过指定全部要读取的文件列表，使用map_dfr()函数读取全部文件并合并数据源。 allfiles &lt;- list.files(path = &#39;./data/read-write/&#39;,pattern = &#39;^[a-z].xlsx$&#39;,full.names = T) purrr::map_dfr(allfiles,read_excel) 在我实际工作中，实现传统零售行业门店之间商品调拨时就可使用该函数,更多详细信息可以查看我的语雀笔记。 "],["purrr-map2.html", "10.4 map2 系列函数", " 10.4 map2 系列函数 map2 系列函数是对 map 系列函数的升级，map 系列函数是一个列表参数，而 map2 系列是两个列表参数。常用函数如下： map2(.x, .y, .f, ...) map2_lgl(.x, .y, .f, ...) map2_int(.x, .y, .f, ...) map2_dbl(.x, .y, .f, ...) map2_chr(.x, .y, .f, ...) map2_raw(.x, .y, .f, ...) map2_dfr(.x, .y, .f, ..., .id = NULL) map2_dfc(.x, .y, .f, ...) walk2(.x, .y, .f, ...) 两个列表相加 x &lt;- list(1, 1, 1) y &lt;- list(10, 20, 30) map2(x, y, ~ .x + .y) #&gt; [[1]] #&gt; [1] 11 #&gt; #&gt; [[2]] #&gt; [1] 21 #&gt; #&gt; [[3]] #&gt; [1] 31 map2(x, y, `+`) #&gt; [[1]] #&gt; [1] 11 #&gt; #&gt; [[2]] #&gt; [1] 21 #&gt; #&gt; [[3]] #&gt; [1] 31 两个向量分别相加后构造新的数据框 ex_fun &lt;- function(arg1, arg2){ col &lt;- arg1 + arg2 x &lt;- as.data.frame(col) } arg1 &lt;- 1:4 arg2 &lt;- 10:13 map2_dfr(arg1, arg2, ex_fun) #&gt; col #&gt; 1 11 #&gt; 2 13 #&gt; 3 15 #&gt; 4 17 map2_dfc(arg1, arg2, ex_fun) #&gt; New names: #&gt; * col -&gt; col...1 #&gt; * col -&gt; col...2 #&gt; * col -&gt; col...3 #&gt; * col -&gt; col...4 #&gt; col...1 col...2 col...3 col...4 #&gt; 1 11 13 15 17 两个列表中取较小值 df &lt;- data.frame( x = c(1, 2, 5), y = c(5, 4, 8) ) pmin(df$x, df$y) #&gt; [1] 1 2 5 map2_dbl(df$x, df$y, min) #&gt; [1] 1 2 5 "],["purrr-multi-parameter.html", "10.5 pmap系列函数", " 10.5 pmap系列函数 pmap 系列函数可以映射多个(2个以上)参数，两个参数使用 map2 函数。 pmap(.l, .f, ...) pmap_lgl(.l, .f, ...) pmap_int(.l, .f, ...) pmap_dbl(.l, .f, ...) pmap_chr(.l, .f, ...) pmap_raw(.l, .f, ...) pmap_dfr(.l, .f, ..., .id = NULL) pmap_dfc(.l, .f, ...) pwalk(.l, .f, ...) li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) li3 &lt;- list(2,4,6) li1 &lt;- c(1,3,5) li2 &lt;- c(2,4,6) li3 &lt;- c(2,3,4) li &lt;- list(li1,li2,li3) pmap(li,sum) #&gt; [[1]] #&gt; [1] 5 #&gt; #&gt; [[2]] #&gt; [1] 10 #&gt; #&gt; [[3]] #&gt; [1] 15 df &lt;- data.frame( x = 1:3, y = 10:12, z = letters[1:3] ) plus2 &lt;- function(x, y, ...) x + y pmap_dbl(df, plus2) #&gt; [1] 11 13 15 注意上述代码中plus2函数的特殊性，运用了…参数 本章开始案例中的 pmap 函数的应用，将各种参数构造为 data.frame，运用好此特性，可以发挥强大作用。 df &lt;- data.frame( x = c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;), pattern = c(&quot;p&quot;, &quot;n&quot;, &quot;h&quot;), replacement = c(&quot;P&quot;, &quot;N&quot;, &quot;H&quot;), stringsAsFactors = FALSE ) pmap(df, gsub) #&gt; [[1]] #&gt; [1] &quot;aPPle&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;baNaNa&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;cHerry&quot; 对大部分数据分析师而言，掌握 map 系列以及 map 变种系列函数即可很好处理大部分数据问题。 "],["purrr-reduce.html", "10.6 归约累计函数", " 10.6 归约累计函数 reduce、accumulate()函数用法介绍. 10.6.1 reduce 函数 reduce() 将多个元素的值组合(由函数驱动)成一个，组合的动词(函数)由参数.f决定。 reduce(.x, .f, ..., .init, .dir = c(&quot;forward&quot;, &quot;backward&quot;)) reduce2(.x, .y, .f, ..., .init) 如下，将 1 到 100 共 100 个元素由函数+组合成一个元素，即将 100 个数字连续相加： reduce(1:100,`+`) #&gt; [1] 5050 连续相减 reduce(5:1,`-`) #&gt; [1] -5 # 等同于 5-4-3-2-1 #&gt; [1] -5 .dir 参数决定动词(函数)方向： str(reduce(1:4, list)) #&gt; List of 2 #&gt; $ :List of 2 #&gt; ..$ :List of 2 #&gt; .. ..$ : int 1 #&gt; .. ..$ : int 2 #&gt; ..$ : int 3 #&gt; $ : int 4 # 等同 # list(list(list(list(1),2),3),4) str(reduce(1:4, list, .dir = &quot;backward&quot;)) #&gt; List of 2 #&gt; $ : int 1 #&gt; $ :List of 2 #&gt; ..$ : int 2 #&gt; ..$ :List of 2 #&gt; .. ..$ : int 3 #&gt; .. ..$ : int 4 # 等同 # list(1,list(2,list(3,list(4)))) 自己试着比较添加 .dir 参数后的差异。 在实际工作中,我常用reduce函数实现连续merge()或left_joind()等功能，如下所示： n &lt;- 10 dt1 &lt;- data.frame(a=letters[n],b1=rnorm(n)) dt2 &lt;- data.frame(a=letters[n],b2=rnorm(n)) dt3 &lt;- data.frame(a=letters[n],b3=rnorm(n)) dt4 &lt;- data.frame(a=letters[n],b4=rnorm(n)) reduce(list(dt1,dt2,dt3,dt4),merge) %&gt;% head() #&gt; a b1 b2 b3 b4 #&gt; 1 j -0.387 -0.209 2.04 -1.1462 #&gt; 2 j -0.387 -0.209 2.04 0.8462 #&gt; 3 j -0.387 -0.209 2.04 0.0817 #&gt; 4 j -0.387 -0.209 2.04 -1.3051 #&gt; 5 j -0.387 -0.209 2.04 -0.9449 #&gt; 6 j -0.387 -0.209 2.04 0.4543 # not run # reduce(list(dt1,dt2,dt3,dt4),merge,by=&#39;a&#39;) same above 关于reduce2()函数，第二个元素需要比第一个元素长度少一个，如下所示： paste2 &lt;- function(x, y, sep = &quot;.&quot;) paste(x, y, sep = sep) letters[1:4] %&gt;% reduce(paste2) #&gt; [1] &quot;a.b.c.d&quot; letters[1:4] %&gt;% reduce2(c(&quot;-&quot;, &quot;.&quot;, &quot;-&quot;), paste2) #&gt; [1] &quot;a-b.c-d&quot; x &lt;- list(c(0, 1), c(2, 3), c(4, 5)) y &lt;- list(c(6, 7), c(8, 9)) reduce2(x, y, paste) #&gt; [1] &quot;0 2 6 4 8&quot; &quot;1 3 7 5 9&quot; 10.6.2 accumulate 函数 accumulate()与reduce()的区别是accumulate()记录过程结果，而reduce()`仅保持最后结果。 1:5 %&gt;% accumulate(`+`) #&gt; [1] 1 3 6 10 15 1:5 %&gt;% accumulate(`+`, .dir = &quot;backward&quot;) #&gt; [1] 15 14 12 9 5 accumulate(letters[1:5], paste, sep = &quot;.&quot;) #&gt; [1] &quot;a&quot; &quot;a.b&quot; &quot;a.b.c&quot; &quot;a.b.c.d&quot; &quot;a.b.c.d.e&quot; paste2 &lt;- function(x, y, sep = &quot;.&quot;) paste(x, y, sep = sep) letters[1:4] %&gt;% accumulate(paste2) #&gt; [1] &quot;a&quot; &quot;a.b&quot; &quot;a.b.c&quot; &quot;a.b.c.d&quot; letters[1:4] %&gt;% accumulate2(c(&quot;-&quot;, &quot;.&quot;, &quot;-&quot;), paste2) #&gt; [[1]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;a-b&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;a-b.c&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;a-b.c-d&quot; "],["purrr-safely-functions.html", "10.7 安全函数", " 10.7 安全函数 当循环迭代时遇到错误报错，导致整个程序停止,这不是我们能接受的，尤其时在做大规模比较耗时的工作时。purrr提供了“安全函数” possibly()和 safely()处理该类问题。 l &lt;- list(1,2,3,4,&#39;5&#39;) map(l,function(.x) .x+1) # Error in .x + 1 : 二进列运算符中有非数值参数 由于字符 5 不能相加，导致以上代码报错,不能正确运行。通过函数safely()改进函数，即可避免： l &lt;- list(1,2,3,4,&#39;5&#39;) test_fun &lt;- safely(function(.x) .x+1) map(l,test_fun) #&gt; [[1]] #&gt; [[1]]$result #&gt; [1] 2 #&gt; #&gt; [[1]]$error #&gt; NULL #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$result #&gt; [1] 3 #&gt; #&gt; [[2]]$error #&gt; NULL #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$result #&gt; [1] 4 #&gt; #&gt; [[3]]$error #&gt; NULL #&gt; #&gt; #&gt; [[4]] #&gt; [[4]]$result #&gt; [1] 5 #&gt; #&gt; [[4]]$error #&gt; NULL #&gt; #&gt; #&gt; [[5]] #&gt; [[5]]$result #&gt; NULL #&gt; #&gt; [[5]]$error #&gt; &lt;simpleError in .x + 1: 二进列运算符中有非数值参数&gt; 用safely()函数将原始function包裹起来,即使执行过程中遇到错误也可以完成整个任务,不会因为中途报错停止,在大型循环过程中,如爬虫过程中比较实用。 或者用possibly()函数： test_fun &lt;- possibly(function(.x) .x+1,otherwise = NA) map(l,test_fun) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 3 #&gt; #&gt; [[3]] #&gt; [1] 4 #&gt; #&gt; [[4]] #&gt; [1] 5 #&gt; #&gt; [[5]] #&gt; [1] NA 使用默认值替换错误发生时的“值” list(&quot;a&quot;, 10, 100) %&gt;% map_dbl(possibly(log, NA_real_)) #&gt; [1] NA 2.30 4.61 "],["purrr-else-functions.html", "10.8 其他函数介绍", " 10.8 其他函数介绍 10.8.1 flatten 系列 flatten()系列函数可以将列表输出为稳定类型，通过flatten_函数后缀表明输出类型。 x &lt;- rerun(2, sample(4)) # rerun purrr 中的函数 x x %&gt;% flatten() x %&gt;% flatten_int() # 提取列表的第一个元素 x %&gt;% map(1L) %&gt;% flatten_int() # 下面的方式效率更高 x %&gt;% map_int(1L) 10.8.2 imap 函数 imap()系列函数官方描述： imap_xxx(x, …), an indexed map, is short hand for map2(x, names(x), …) if x has names, or map2(x, seq_along(x), …) if it does not. This is useful if you need to compute on both the value and the position of an element. imap,当x有names(x)或者seq_along(x)属性,imap是map2的另一种表达方式。 详情请查看:?imap 案例： imap_chr(sample(10), ~ paste0(.y, &quot;: &quot;, .x)) #&gt; [1] &quot;1: 6&quot; &quot;2: 2&quot; &quot;3: 7&quot; &quot;4: 9&quot; &quot;5: 10&quot; &quot;6: 8&quot; &quot;7: 5&quot; &quot;8: 4&quot; &quot;9: 3&quot; #&gt; [10] &quot;10: 1&quot; sample(10),没有names(),只有长度信息。转化成map2表达如下: map2_chr(sample(10),1:10,~paste0(.y,&quot;: &quot;,.x)) # 第二个list 为位置信息. #&gt; [1] &quot;1: 3&quot; &quot;2: 4&quot; &quot;3: 6&quot; &quot;4: 8&quot; &quot;5: 2&quot; &quot;6: 5&quot; &quot;7: 1&quot; &quot;8: 7&quot; #&gt; [9] &quot;9: 9&quot; &quot;10: 10&quot; 10.8.3 walk 系列 对于不关心过程或结果的操作可以采用该系列函数，比如打印，做图，批量输出数据，上传数据库等。 iwalk(mtcars, ~ cat(.y, &quot;: &quot;, median(.x), &quot;\\n&quot;, sep = &quot;&quot;)) #&gt; mpg: 19.2 #&gt; cyl: 6 #&gt; disp: 196 #&gt; hp: 123 #&gt; drat: 3.7 #&gt; wt: 3.33 #&gt; qsec: 17.7 #&gt; vs: 0 #&gt; am: 0 #&gt; gear: 4 #&gt; carb: 2 个人觉得iwalk()和前文数据导入导出章节中提到的批量输出group_walk()函数功能有相似之处。 dt %&gt;% group_by(name) %&gt;% group_walk(~ write.csv(.x,file = file.path(&#39;data/read-write&#39;,paste0(.y$name,&#39;.csv&#39;)))) 同上，iwalk()函数家族还有walk2()和pwalk()`函数,函数间区别与 map 族函数间区别类似。 10.8.4 逻辑判断函数 判断序列中是否存在任意/存在元素满足条件 every(.x, .p, ...) some(.x, .p, ...) none(.x, .p, ...) y &lt;- list(0:10, 5.5) y %&gt;% every(is.numeric) #&gt; [1] TRUE y %&gt;% every(is.integer) #&gt; [1] FALSE y %&gt;% some(is.integer) #&gt; [1] TRUE y %&gt;% none(is.character) #&gt; [1] TRUE 应用在dplyr动词中： mpg %&gt;% group_by(manufacturer) %&gt;% mutate(a = every(cty, ~ .x &gt; 10) ) #&gt; # A tibble: 234 x 12 #&gt; # Groups: manufacturer [15] #&gt; manufacturer model displ year cyl trans drv cty hwy fl class a #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; #&gt; 1 audi a4 1.8 1999 4 auto~ f 18 29 p comp~ TRUE #&gt; 2 audi a4 1.8 1999 4 manu~ f 21 29 p comp~ TRUE #&gt; 3 audi a4 2 2008 4 manu~ f 20 31 p comp~ TRUE #&gt; 4 audi a4 2 2008 4 auto~ f 21 30 p comp~ TRUE #&gt; 5 audi a4 2.8 1999 6 auto~ f 16 26 p comp~ TRUE #&gt; 6 audi a4 2.8 1999 6 manu~ f 18 26 p comp~ TRUE #&gt; # ... with 228 more rows 10.8.5 提取函数 pluck()和chuck()实现一种通用形式的元素提取。 obj1 &lt;- list(&quot;a&quot;, list(1, elt = &quot;foo&quot;)) obj2 &lt;- list(&quot;b&quot;, list(2, elt = &quot;bar&quot;)) x &lt;- list(obj1, obj2) pluck(x, 1) #&gt; [[1]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [[2]][[1]] #&gt; [1] 1 #&gt; #&gt; [[2]]$elt #&gt; [1] &quot;foo&quot; x[[1]] #&gt; [[1]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [[2]][[1]] #&gt; [1] 1 #&gt; #&gt; [[2]]$elt #&gt; [1] &quot;foo&quot; pluck(x, 1, 2) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; $elt #&gt; [1] &quot;foo&quot; x[[1]][[2]] #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; $elt #&gt; [1] &quot;foo&quot; pluck(x, 1, 2, &quot;elt&quot;) #&gt; [1] &quot;foo&quot; x[[1]][[2]][[&quot;elt&quot;]] #&gt; [1] &quot;foo&quot; 10.8.6 筛选函数 keep()和discard()函数筛选元素，keep()保留计算后为 TRUE 的结果，discard()保留计算后为 FALSE 的结果。 keep(.x, .p, ...) discard(.x, .p, ...) compact(.x, .p = identity) .p 参数是一个谓词函数(predicate function),谓词函数返回单个的TRUE或FALSE。 筛选从 1:10 中随机生成的 5 个数字，保留均值大于的记录。 rep(10, 10) %&gt;% map(sample, 5) %&gt;% keep(~ mean(.x) &gt; 6) #&gt; [[1]] #&gt; [1] 8 10 6 9 7 #&gt; #&gt; [[2]] #&gt; [1] 8 7 2 5 10 #&gt; #&gt; [[3]] #&gt; [1] 7 4 9 8 3 筛选列表(list) x 中“a”元素为 TRUE 或 FALSE 的记录。 x &lt;- rerun(5, a = rbernoulli(1), b = sample(10)) x %&gt;% keep(&quot;a&quot;) #&gt; [[1]] #&gt; [[1]]$a #&gt; [1] TRUE #&gt; #&gt; [[1]]$b #&gt; [1] 4 9 6 5 8 2 7 1 10 3 #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$a #&gt; [1] TRUE #&gt; #&gt; [[2]]$b #&gt; [1] 2 8 10 6 7 1 5 3 4 9 x %&gt;% discard(&quot;a&quot;) #&gt; [[1]] #&gt; [[1]]$a #&gt; [1] FALSE #&gt; #&gt; [[1]]$b #&gt; [1] 6 9 5 7 4 1 8 10 2 3 #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$a #&gt; [1] FALSE #&gt; #&gt; [[2]]$b #&gt; [1] 8 7 6 9 3 2 10 5 1 4 #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$a #&gt; [1] FALSE #&gt; #&gt; [[3]]$b #&gt; [1] 6 8 10 7 3 4 2 5 9 1 compact() 舍弃 NULL 元素和长度为 0 的元素。 list(a = &quot;a&quot;, b = NULL, c = integer(0), d = NA, e = list()) %&gt;% compact() #&gt; $a #&gt; [1] &quot;a&quot; #&gt; #&gt; $d #&gt; [1] NA "]]
