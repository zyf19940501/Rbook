[["Data-Manipulation-dplyr.html", "2 数据处理之-dplyr", " 2 数据处理之-dplyr 本章节主要目的是通过阐述dplyr动词用法，实现与Excel透视表或sql相同功能，从而达到不同的数据整理、聚合需求。 本章主要从以下方面阐述： 行条件筛选 列筛选 字段重命名 列位置排序 行排序 新增计算字段 分组聚合 表关联 行列操作 使用dplyr编写自定义函数 其中9,10行列操作和自定义函数有一定难度，大家可以先熟悉dplyr基本用法后再了解其用法。 与sql相比，用dplyr的优势： 代码量极大减少 逻辑复杂时，dplyr动词可以按照顺序一步步实现，无需嵌套，实现过程简单 代码可读性好 配合dbplyr包使用，大部分情况下可以扔掉sql语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用 本章节中部分案例照搬dplyr包的官方案例， dplyr动词从数据库相关操作中抽象而来，从sql迁移成本低 "],["dplyr-description.html", "2.1 前言", " 2.1 前言 dplyr包是tidyverse系列的核心包之一。dplyr是A Grammar of Data Manipulation ，即dplyr是数据处理的语法。数据操作在数据库中往往被增、改、删、查四字描述，加上表连接查询基本涵盖了大部分的数据操作。 dplyr包通过提供一组动词来解决最常见的数据处理问题： mutate() 添加新变量,现有变量的函数 select() 筛选列,根据现有变量名称选择变量 filter() 筛选行，根据条件筛选 summarise() 按照一定条件汇总聚合 arrange() 行排序 以上动词都可以和group_by()结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过vignette(\"two-table\")查看学习。 2.1.1 安装 dplyr包可以直接安装。 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;dplyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/dplyr&quot;) 在开始使用前，请确保自己dplyr版本是较新版本，因为1.0.0版本有较大更新。 packageVersion(&#39;dplyr&#39;) #&gt; [1] &#39;1.0.6&#39; 2.1.2 Excel and Sql 类比 与Excel相比,dplyr使用filter实现筛选，mutate实现列新增计算，summarise配合group_by实现数据透视表，arrange实现排序功能。 dplyr::left_join()等表连接功能，实现Excel中的vlookup,xlookup等函数效果。 请看案例： 案例中使用的数据集是R包nycflights13带的flights数据集。 Excel实现 透视表截图 R实现： library(tidyverse,warn.conflicts = FALSE) data &lt;- readr::read_csv(&quot;./data/flights.csv&quot;) data %&gt;% filter(year==2014,month==6) %&gt;% group_by(origin,dest) %&gt;% summarise(distance求和项 = sum(distance)) #&gt; # A tibble: 195 x 3 #&gt; # Groups: origin [3] #&gt; origin dest distance求和项 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 EWR ALB 715 #&gt; 2 EWR ANC 13480 #&gt; 3 EWR ATL 317050 #&gt; 4 EWR AUS 88736 #&gt; 5 EWR AVL 13409 #&gt; 6 EWR BDL 8236 #&gt; # ... with 189 more rows Sql实现： select origin,dest,sum(distance) distance求和项 from flights where year = 2014 and month =6 group by origin,dest Table 2.1: Displaying records 1 - 10 origin dest distance求和项 EWR ALB 715 EWR ANC 13480 EWR ATL 317050 EWR AUS 88736 EWR AVL 13409 EWR BDL 8236 EWR BNA 138380 EWR BOS 92600 EWR BQN 47550 EWR BTV 15960 2.1.3 常见问题 筛选订单表中的1-5月订单数据，按照城市汇总，求每个城市的销售额和门店数(去重)? data %&gt;% filter(between(月,1,5)) %&gt;% group_by(城市) %&gt;% summarise(金额 = sum(金额),门店数 = n_distinct(门店编码)) 近30天商品销量排名? data %&gt;% filter(订单日期 &gt;= Sys.Date()-30) %&gt;% group_by(分析大类,商品编码) %&gt;% summarise(商品销量 = sum(数量)) %&gt;% group_by(分析大类) %&gt;% mutate(商品排名 = dense_rank(desc(商品销量))) # 注意用desc倒序，销量高排第一 销售和库存形成笛卡尔积表，计算商品有货率、动销率? Cheat Sheet 手册搬运于dplyr官方介绍,方便下载查阅。 dplyr-sheet Rstudio提供的其它手册:https://www.rstudio.com/resources/cheatsheets/ "],["dplyr-usage.html", "2.2 基础用法", " 2.2 基础用法 基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述dplyr动词功能。 首先加载包，加载包时可能会有一些重名函数的提示，可以通过warn.conflict参数禁掉提示。如下所示： # 禁掉提示 library(dplyr,warn.conflicts = FALSE) 2.2.1 filter filter动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和SQL中where条件一致。 filter条件筛选中可以分为单条件筛选和多条件筛选；多条件中间用,分隔。 单条件 条件为species == \"Droid\"时，如下所示： starwars %&gt;% filter(species == &quot;Droid&quot;) #&gt; # A tibble: 6 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculi~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none masculi~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none masculi~ #&gt; 4 IG-88 200 140 none metal red 15 none masculi~ #&gt; 5 R4-P17 96 NA none silver, red red, blue NA none feminine #&gt; 6 BB8 NA NA none none black NA none masculi~ #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species = &quot;Droid&quot; -- 注意=与==的区别 多条件 多条件筛选时，用英文逗号隔开多个条件。sql中用“and”连接多个条件，与 R 中用逗号隔开效果相同,“and” 在 R 中用 &amp; 表示。 starwars %&gt;% filter(species == &quot;Droid&quot;,skin_color == &quot;gold&quot;) #&gt; # A tibble: 1 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculine #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; # 同上 # starwars %&gt;% # filter(species == &quot;Droid&quot; &amp; skin_color == &quot;gold&quot;) select * from starwars where species = &quot;Droid&quot; and skin_color = &quot;gold&quot; 多情况筛选 %in%类似SQL中 in 的用法，与Excel中筛选条件时“或”条件相当。 starwars %&gt;% filter(species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 7 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none mascu~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ #&gt; 4 IG-88 200 140 none metal red 15 none mascu~ #&gt; 5 Zam We~ 168 55 blonde fair, green~ yellow NA fema~ femin~ #&gt; 6 R4-P17 96 NA none silver, red red, blue NA none femin~ #&gt; # ... with 1 more row, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species in (&quot;Droid&quot;,&quot;Clawdite&quot;) --sql查询 逻辑关系筛选 条件运算分为逻辑运算、关系运算。 关系运算符 &gt;、&lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。 逻辑运算符 &amp;、|、！。 |为 或, &amp; 为并、且条件，!为非。 library(nycflights13) filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # same above filter(flights, arr_delay &lt;= 120 &amp; dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # %in% 的反面 starwars %&gt;% filter(!species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 80 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 3 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 4 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; 5 Beru Wh~ 165 75 brown light blue 47 fema~ femin~ #&gt; 6 Biggs D~ 183 84 black light brown 24 male mascu~ #&gt; # ... with 74 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; !的运算级别相比 %in% 更高 2.2.2 select 当完整数据集列较多时，我们某次分析可能并不需要那么多列，通过动词select()筛选列,剔除不需要的列。 基础用法 通过指定列名称筛选，并指定列之间顺序 starwars %&gt;% select(name,height,mass,hair_color,skin_color,eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows 列索引 通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。 starwars %&gt;% select(name : eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows # 同上 starwars %&gt;% select(1:6) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows # starwars %&gt;% select(c(1,2,4,5,7)) 新增列筛选方式 # starwars %&gt;% select(!(name:mass)) # iris %&gt;% select(!ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) &amp; ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) | ends_with(&quot;Width&quot;)) 2.2.3 rename 列重命名使用rename()函数，新名称写前面，如下所示： starwars %&gt;% rename(home_world = homeworld) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # 多列同换 starwars %&gt;% rename(home_world = homeworld,skincolor = skin_color) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skincolor eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * ,homeworld as home_word from starwars select * ,homeworld home_word from starwars as 可以省略，但中间有一个以上空格。与R的差异是新增home_word列，原始列继续存在，R中是替换列名。 2.2.4 relocate 更改列顺序，与使用select()动词指定列顺序功能相似。 relocate参数如下： relocate(.data, ..., .before = NULL, .after = NULL) # sex:homeworld 列在 height 列前面 starwars %&gt;% relocate(sex:homeworld, .before = height) #&gt; # A tibble: 87 x 14 #&gt; name sex gender homeworld height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ male mascul~ Tatooine 172 77 blond fair blue #&gt; 2 C-3PO none mascul~ Tatooine 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 none mascul~ Naboo 96 32 &lt;NA&gt; white, bl~ red #&gt; 4 Darth V~ male mascul~ Tatooine 202 136 none white yellow #&gt; 5 Leia Or~ female femini~ Alderaan 150 49 brown light brown #&gt; 6 Owen La~ male mascul~ Tatooine 178 120 brown, gr~ light blue #&gt; # ... with 81 more rows, and 5 more variables: birth_year &lt;dbl&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 2.2.5 mutate 动词mutate可以新增计算列，删除列，更新已有列，列之间的计算都可以通过mutate实现。 新增计算列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% select(name:mass,bmi) #&gt; # A tibble: 87 x 4 #&gt; name height mass bmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 #&gt; 2 C-3PO 167 75 26.9 #&gt; 3 R2-D2 96 32 34.7 #&gt; 4 Darth Vader 202 136 33.3 #&gt; 5 Leia Organa 150 49 21.8 #&gt; 6 Owen Lars 178 120 37.9 #&gt; # ... with 81 more rows 新增计算列基础上新增列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2),newbmi = bmi *2) %&gt;% select(name:mass,bmi,newbmi) #&gt; # A tibble: 87 x 5 #&gt; name height mass bmi newbmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 52.1 #&gt; 2 C-3PO 167 75 26.9 53.8 #&gt; 3 R2-D2 96 32 34.7 69.4 #&gt; 4 Darth Vader 202 136 33.3 66.7 #&gt; 5 Leia Organa 150 49 21.8 43.6 #&gt; 6 Owen Lars 178 120 37.9 75.7 #&gt; # ... with 81 more rows 删除列 starwars %&gt;% mutate(height = NULL) #&gt; # A tibble: 87 x 13 #&gt; name mass hair_color skin_color eye_color birth_year sex gender homeworld #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke ~ 77 blond fair blue 19 male mascu~ Tatooine #&gt; 2 C-3PO 75 &lt;NA&gt; gold yellow 112 none mascu~ Tatooine #&gt; 3 R2-D2 32 &lt;NA&gt; white, bl~ red 33 none mascu~ Naboo #&gt; 4 Darth~ 136 none white yellow 41.9 male mascu~ Tatooine #&gt; 5 Leia ~ 49 brown light brown 19 fema~ femin~ Alderaan #&gt; 6 Owen ~ 120 brown, gr~ light blue 52 male mascu~ Tatooine #&gt; # ... with 81 more rows, and 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; 2.2.6 arrange 单列排序，默认升序，通过desc()降序排列 starwars %&gt;% arrange(desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Jabba ~ 175 1358 &lt;NA&gt; green-tan,~ orange 600 herm~ mascu~ #&gt; 2 Grievo~ 216 159 none brown, whi~ green, y~ NA male mascu~ #&gt; 3 IG-88 200 140 none metal red 15 none mascu~ #&gt; 4 Darth ~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Tarfful 234 136 brown brown blue NA male mascu~ #&gt; 6 Owen L~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 多列排序 starwars %&gt;% arrange(height,desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Yoda 66 17 white green brown 896 male mascu~ #&gt; 2 Ratts Ty~ 79 15 none grey, blue unknown NA male mascu~ #&gt; 3 Wicket S~ 88 20 brown brown brown 8 male mascu~ #&gt; 4 Dud Bolt 94 45 none blue, grey yellow NA male mascu~ #&gt; 5 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 6 R4-P17 96 NA none silver, r~ red, blue NA none femin~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars order by height,mass desc 2.2.7 summarise summarise常与group_by结合使用。 mtcars %&gt;% summarise(mean = mean(disp), n = n()) #&gt; mean n #&gt; 1 231 32 n()是dplyr包中的计算当前组大小的函数，用在summarise()和mutate()中。通常用来组计算。 2.2.8 group_by 聚合前一般都需要分组，group_by()动词实现该功能，与SQL中group by ···类似。 starwars %&gt;% group_by(species) %&gt;% summarise( n = n(), mass = mean(mass, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n mass #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 15 #&gt; 2 Besalisk 1 102 #&gt; 3 Cerean 1 82 #&gt; 4 Chagrian 1 NaN #&gt; 5 Clawdite 1 55 #&gt; 6 Droid 6 69.8 #&gt; # ... with 32 more rows SELECT species, count(species) n, AVG(mass) mass FROM [spb].[dbo].[starwars] GROUP BY species "],["dplyr-functions.html", "2.3 常用函数", " 2.3 常用函数 本小节介绍dplyr处理数据时常用的函数，类似sql中的case_when、count、distinct、row_number、between等函数。 2.3.1 条件判断 dplyr::if_else()相比于base::ifelse,if_else输出类型更为严格，无论TRUE或FALSE输出类型一致，这样计算速度更快。 dplyr::if_else()参数: if_else(condition, true, false, missing = NULL) x &lt;- sample(1:10,5) if_else(x&gt;5,&quot;大于五&quot;,&quot;小于等于五&quot;,missing = &quot;空值&quot;) #&gt; [1] &quot;大于五&quot; &quot;大于五&quot; &quot;大于五&quot; &quot;大于五&quot; &quot;小于等于五&quot; 与ifelse不同的是，if_else保留类型 x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] NA 2 1 NA 1 2 3 1 1 2 if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] &lt;NA&gt; b a &lt;NA&gt; a b c a a b #&gt; Levels: a b c d e 与data.table::fifelse()功能相似 2.3.2 case_when 当条件嵌套较多时，使用case_when,使代码可读并且不易出错。与sql 中的case when 等价。 x &lt;- 1:50 case_when( x %% 35 == 0 ~ &quot;fizz buzz&quot;, x %% 5 == 0 ~ &quot;fizz&quot;, x %% 7 == 0 ~ &quot;buzz&quot;, TRUE ~ as.character(x) ) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;fizz&quot; &quot;6&quot; #&gt; [7] &quot;buzz&quot; &quot;8&quot; &quot;9&quot; &quot;fizz&quot; &quot;11&quot; &quot;12&quot; #&gt; [13] &quot;13&quot; &quot;buzz&quot; &quot;fizz&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; #&gt; [19] &quot;19&quot; &quot;fizz&quot; &quot;buzz&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; #&gt; [25] &quot;fizz&quot; &quot;26&quot; &quot;27&quot; &quot;buzz&quot; &quot;29&quot; &quot;fizz&quot; #&gt; [31] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;fizz buzz&quot; &quot;36&quot; #&gt; [37] &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;fizz&quot; &quot;41&quot; &quot;buzz&quot; #&gt; [43] &quot;43&quot; &quot;44&quot; &quot;fizz&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; #&gt; [49] &quot;buzz&quot; &quot;fizz&quot; Dates &lt;- as.Date(c(&#39;2018-10-01&#39;, &#39;2018-10-02&#39;, &#39;2018-10-03&#39;,&#39;2018-10-04&#39;)) case_when( Dates == &#39;2018-10-01&#39; ~ Dates - 1, Dates == &#39;2018-10-02&#39; ~ Dates + 1, Dates == &#39;2018-10-03&#39; ~ Dates + 2, TRUE ~ Dates ) #&gt; [1] &quot;2018-09-30&quot; &quot;2018-10-03&quot; &quot;2018-10-05&quot; &quot;2018-10-04&quot; 结合 mutate 动词使用 starwars %&gt;% mutate(性别 = case_when( sex == &quot;male&quot; ~ &quot;雄性&quot;, sex == &quot;female&quot; ~ &quot;雌性&quot;, sex == &quot;hermaphroditic&quot; ~ &quot;雌雄同体&quot;, TRUE ~ &quot;无&quot; )) %&gt;% pull(性别) %&gt;% table() #&gt; . #&gt; 雌性 雌雄同体 无 雄性 #&gt; 16 1 10 60 pull()功能与 data$．类似，为了在管道中使用设计 2.3.3 计数函数 计数 count()函数用来计数。下面两种表达方式等价。 df %&gt;% count(a, b) # same above df %&gt;% group_by(a, b) %&gt;% summarise(n = n()) starwars %&gt;% count(species) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows # same above 等价 starwars %&gt;% group_by(species) %&gt;% summarise(n = n()) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows 非重复计数 n_distinct()与length(unique(x))等价，但是更快更简洁。当我们需要给门店或订单之类数据去重计算时采用该函数。 x &lt;- sample(1:10, 1e5, rep = TRUE) length(unique(x)) #&gt; [1] 10 n_distinct(x) #&gt; [1] 10 2.3.4 排序函数 dplyr共六种排序函数，模仿SQL2003中的排名函数。 row_number():等于 rank(ties.method = “first”) min_rank(): 等于 rank(ties.method = “min”) dense_rank(): 与min_rank()相似,但是没有间隔 percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1] x &lt;- c(5, 1, 3, 2, 2, NA) row_number(x) #&gt; [1] 5 1 4 2 3 NA min_rank(x) #&gt; [1] 5 1 4 2 2 NA dense_rank(x) #&gt; [1] 4 1 3 2 2 NA percent_rank(x) #&gt; [1] 1.00 0.00 0.75 0.25 0.25 NA cume_dist(x) #&gt; [1] 1.0 0.2 0.8 0.6 0.6 NA 2.3.5 提取向量 该系列函数是对[[的包装，方便提取向量。 nth(x, n, order_by = NULL, default = default_missing(x)) first(x, order_by = NULL, default = default_missing(x)) last(x, order_by = NULL, default = default_missing(x)) x &lt;- 1:10 y &lt;- 10:1 first(x) #&gt; [1] 1 last(y) #&gt; [1] 1 nth(x, 1) #&gt; [1] 1 nth(x, 5) #&gt; [1] 5 2.3.6 slice 系列 slice()函数让我们按照行数切片，让我们筛选，删除、重复某些行。和 python 中的 pandas 库的切片类似。 slice()共有如下几组函数： slice_head() 和 slice_tail()，选着头和尾行 。 slice_sample() 随机选择行。 slice_min() 和 slice_max() 按照变量的最低值和最高值选择行。 如果用于 slice() 系列函数的数据集.data 是被 group_by() 过，那每个函数将作用在每一组上。例如，按照商品大类取每个商品大类前五的商品。 dt %&gt;% group_by(商品大类) %&gt;% slice_head(n = 5) 2.3.6.1 函数用法 slice(.data, ..., .preserve = FALSE) slice_head(.data, ..., n, prop) slice_tail(.data, ..., n, prop) slice_min(.data, order_by, ..., n, prop, with_ties = TRUE) slice_max(.data, order_by, ..., n, prop, with_ties = TRUE) slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE) 2.3.6.2 参数解释 .data: 一个 data.frame , data frame extension (tibble) …: 必须是整数，如果是正数将保留，负值将删除。提供的值超过行数的将会被忽略 .preserve :默认为FALSE,根据结果数据重新计算分组结构，否则保持原样分组 n,p: 提供要选择的行数 n,或行的比列比如 prop = 0.4，如果都未提供则默认n = 1 order_by: 要排序的变量或者是被函数作用的变量 with_ties: 针对 _min 或 _max 函数，相等时候是否强制输出指定行数。 weight_by: 抽样的权重 replace: 是否允许重复抽样，默认为FALSE 2.3.6.3 slice 案例 slice() # 筛选第一行 mtcars %&gt;% slice(1L) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 # 筛选最后一行 mtcars %&gt;% slice(n()) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Volvo 142E 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 # 筛选5至最后一行 mtcars %&gt;% slice(5:n()) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.2 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.8 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.42 17.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.34 17.4 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.52 16.9 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.44 17.3 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.85 17.1 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 # 删除前面四行 slice(mtcars, -(1:4)) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.2 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.8 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.42 17.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.34 17.4 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.52 16.9 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.44 17.3 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.85 17.1 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 slice_head slice_tail # 基于现有顺序筛选前面行或最后行 mtcars %&gt;% slice_head(n = 5) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 mtcars %&gt;% slice_tail(n = 5) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 slice_min slice_max # 基于变量筛选 mtcars %&gt;% slice_min(mpg, n = 5) #最小的五行 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.42 17.8 0 0 3 4 #&gt; Camaro Z28 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 #&gt; Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 mtcars %&gt;% slice_max(mpg, n = 5) #最大的五行 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 # slice_min()可能返回更多行，通过with_ties参数控制 mtcars %&gt;% slice_min(cyl, n = 1) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 mtcars %&gt;% slice_min(cyl, n = 1, with_ties = FALSE) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 slice_sample 在数据集中抽样，通过 replace 参数控制是否可以重复。 mtcars %&gt;% slice_sample(n = 5) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 0 0 3 4 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 0 0 3 4 mtcars %&gt;% slice_sample(n = 5, replace = TRUE) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Toyota Corona 21.5 4 120 97 3.70 2.46 20.0 1 0 3 1 #&gt; Chrysler Imperial...2 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 #&gt; Chrysler Imperial...3 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 #&gt; Merc 450SL 17.3 8 276 180 3.07 3.73 17.6 0 0 3 3 #&gt; Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 weight_by 参数调整抽样权重 # 重量大的会更容易抽到 mtcars %&gt;% slice_sample(weight_by = wt, n = 5) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Volvo 142E 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Dodge Challenger 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 分组操作 df &lt;- tibble( group = rep(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), c(1, 2, 4)), x = runif(7) ) df %&gt;% group_by(group) %&gt;% slice_head(n = 2) #&gt; # A tibble: 5 x 2 #&gt; # Groups: group [3] #&gt; group x #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 a 0.810 #&gt; 2 b 0.802 #&gt; 3 b 0.860 #&gt; 4 c 0.344 #&gt; 5 c 0.683 # 注意体会使用prop参数时的差异 df %&gt;% group_by(group) %&gt;% slice_head(prop = 0.4) #仅c组返回一个，因为c组3个数字的 40%的前面还有数 #&gt; # A tibble: 1 x 2 #&gt; # Groups: group [1] #&gt; group x #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 c 0.344 df %&gt;% group_by(group) %&gt;% slice_head(prop = 0.5) # 因为a组只有一个数字，前50%位没有数字 #&gt; # A tibble: 3 x 2 #&gt; # Groups: group [2] #&gt; group x #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 b 0.802 #&gt; 2 c 0.344 #&gt; 3 c 0.683 2.3.7 group 系列 group 系列函数包含 group_by(),group_map(), group_nest(), group_split(), group_trim()等。 其中我常用group_by(),group_split()两个函数。group_by()是我们熟悉的动词，大部分数据操作中的分组操作由它完成。 group_by() #group_by()不会改变数据框 by_cyl &lt;- mtcars %&gt;% group_by(cyl) by_cyl #&gt; # A tibble: 32 x 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows # It changes how it acts with the other dplyr verbs: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) #&gt; # A tibble: 3 x 3 #&gt; cyl disp hp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 105. 82.6 #&gt; 2 6 183. 122. #&gt; 3 8 353. 209. # group_by中可以添加计算字段 即mutate操作 mtcars %&gt;% group_by(vsam = vs + am) %&gt;% group_vars() #&gt; [1] &quot;vsam&quot; － group_split() group_split() 功能与 base::split()相似。 ir &lt;- iris %&gt;% group_by(Species) group_split(ir) #&gt; &lt;list_of&lt; #&gt; tbl_df&lt; #&gt; Sepal.Length: double #&gt; Sepal.Width : double #&gt; Petal.Length: double #&gt; Petal.Width : double #&gt; Species : factor&lt;fb977&gt; #&gt; &gt; #&gt; &gt;[3]&gt; #&gt; [[1]] #&gt; # A tibble: 50 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; # ... with 44 more rows #&gt; #&gt; [[2]] #&gt; # A tibble: 50 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 7 3.2 4.7 1.4 versicolor #&gt; 2 6.4 3.2 4.5 1.5 versicolor #&gt; 3 6.9 3.1 4.9 1.5 versicolor #&gt; 4 5.5 2.3 4 1.3 versicolor #&gt; 5 6.5 2.8 4.6 1.5 versicolor #&gt; 6 5.7 2.8 4.5 1.3 versicolor #&gt; # ... with 44 more rows #&gt; #&gt; [[3]] #&gt; # A tibble: 50 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 6.3 3.3 6 2.5 virginica #&gt; 2 5.8 2.7 5.1 1.9 virginica #&gt; 3 7.1 3 5.9 2.1 virginica #&gt; 4 6.3 2.9 5.6 1.8 virginica #&gt; 5 6.5 3 5.8 2.2 virginica #&gt; 6 7.6 3 6.6 2.1 virginica #&gt; # ... with 44 more rows group_keys(ir) #&gt; # A tibble: 3 x 1 #&gt; Species #&gt; &lt;fct&gt; #&gt; 1 setosa #&gt; 2 versicolor #&gt; 3 virginica group_map() group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据的数据清洗一般不涉及，常用在建模等方面。 但是目前三个函数是实验性的，未来可能会发生变化。 # return a list # 返回列表 mtcars %&gt;% group_by(cyl) %&gt;% group_map(~ head(.x, 2L)) #&gt; [[1]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 22.8 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; #&gt; [[2]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; #&gt; [[3]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 18.7 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 2 14.3 360 245 3.21 3.57 15.8 0 0 3 4 iris %&gt;% group_by(Species) %&gt;% group_modify(~ { .x %&gt;% purrr::map_dfc(fivenum) %&gt;% mutate(nms = c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;)) }) #&gt; # A tibble: 15 x 6 #&gt; # Groups: Species [3] #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width nms #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 setosa 4.3 2.3 1 0.1 min #&gt; 2 setosa 4.8 3.2 1.4 0.2 Q1 #&gt; 3 setosa 5 3.4 1.5 0.2 median #&gt; 4 setosa 5.2 3.7 1.6 0.3 Q3 #&gt; 5 setosa 5.8 4.4 1.9 0.6 max #&gt; 6 versicolor 4.9 2 3 1 min #&gt; # ... with 9 more rows 分组后批量输出 # group_walk dir.create(temp &lt;- tempfile()) iris %&gt;% group_by(Species) %&gt;% group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, &quot;.csv&quot;)))) list.files(temp, pattern = &quot;csv$&quot;) unlink(temp, recursive = TRUE) group_cols() 选择分组变量 gdf &lt;- iris %&gt;% group_by(Species) gdf %&gt;% select(group_cols()) #&gt; # A tibble: 150 x 1 #&gt; # Groups: Species [3] #&gt; Species #&gt; &lt;fct&gt; #&gt; 1 setosa #&gt; 2 setosa #&gt; 3 setosa #&gt; 4 setosa #&gt; 5 setosa #&gt; 6 setosa #&gt; # ... with 144 more rows 2.3.8 其它函数 between between(1:12, 7, 9) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE pull mtcars %&gt;% pull(-1) #&gt; [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 mtcars %&gt;% pull(cyl) #&gt; [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 distinct df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) distinct(df, x) distinct(df, x, .keep_all = TRUE) distinct(df, diff = abs(x - y)) cummean cumsum cumall cumany 累计系列函数 x &lt;- c(1, 3, 5, 2, 2) cummean(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumsum(x) / seq_along(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumall(x &lt; 5) #&gt; [1] TRUE TRUE FALSE FALSE FALSE cumany(x == 3) #&gt; [1] FALSE TRUE TRUE TRUE TRUE "],["dplyr-merge-two-table.html", "2.4 表关联", " 2.4 表关联 在我们做数据分析项目时，大多数时候数据源不止一个，我们需要通过表间共有信息字段将表关联，让表信息更加全面，从而方便做各种信息分类汇总。 dplyr 中表关联是通过一组函数实现，像sql中的left join,inner join等表格之间的操作，或者是Excel中Power Piovt建模的建立关系，从而实现不同表格间的关联。 2.4.1 两表关联 dplyr 中left_join(),full_join,inner_join()等动词关联两个表，详情请查看：vignette(\"two-table\")。 left_join(),right_join(),full_join(),inner_join()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中用法一致。 left_join()实现类似 Excel中VLOOKUP函数功能,将匹配到的“右表”字段依据对应关系关联到“左表”上。 2.4.1.1 基础用法 dplyr中的关联函数的关联条件可以分为: 同名列关联 不同名称列关联 2.4.1.1.1 同名列关联 默认同名列关联，也可指定关联条件列，类似数据库中on a.column = b.column，但 R 代码看起来更加“优雅”。 单个关联条件 library(&quot;nycflights13&quot;) flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) # 默认同名 flights2 %&gt;% left_join(airlines) #&gt; Joining, by = &quot;carrier&quot; #&gt; # A tibble: 336,776 x 9 #&gt; year month day hour origin dest tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. #&gt; # ... with 336,770 more rows 在某些时候，不同的表间可能出现同名的字段，但是并不能作为关联字段，这是就需要人为指定关联字段，并且建议在写代码的时候明确指定关联字段，能避免一些可能不必要的错误。 # 或指定列名 flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) #&gt; # A tibble: 336,776 x 16 #&gt; year.x month day hour origin dest tailnum carrier year.y type #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing multi~ #&gt; 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing multi~ #&gt; 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing multi~ #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing multi~ #&gt; 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing multi~ #&gt; 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing multi~ #&gt; # ... with 336,770 more rows, and 6 more variables: manufacturer &lt;chr&gt;, #&gt; # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt; 像 Sql 中指定关联字段，以下 Sql 代码和上面 R 代码 等效。 select * from flights2 a left join planes b on a.tailnum = b.tailnum 多个关联条件 dta &lt;- data.frame(name = &#39;vega&#39;,grade = 1) dtb &lt;- data.frame(name = c(&#39;vega&#39;,&#39;yufei&#39;),grade = 1:2,性别 = c(&#39;男&#39;,&#39;男&#39;)) left_join(dta,dtb,by=c(&#39;name&#39;,&#39;grade&#39;)) #&gt; name grade 性别 #&gt; 1 vega 1 男 必须指定关联字段的情况，如下所示： # id 是无效列，默认同名关联的话导致无法正常返回结果 dta &lt;- data.frame(id = 1:2, name = c(&#39;vega&#39;,&#39;yufei&#39;),grade = 1:2) dtb &lt;- data.frame(id = 2:1,name = c(&#39;vega&#39;,&#39;yufei&#39;),grade = 1:2,性别 = c(&#39;男&#39;,&#39;男&#39;)) left_join(dta,dtb) #&gt; Joining, by = c(&quot;id&quot;, &quot;name&quot;, &quot;grade&quot;) #&gt; id name grade 性别 #&gt; 1 1 vega 1 &lt;NA&gt; #&gt; 2 2 yufei 2 &lt;NA&gt; left_join(dta,dtb,by=c(&#39;name&#39;,&#39;grade&#39;)) #&gt; id.x name grade id.y 性别 #&gt; 1 1 vega 1 2 男 #&gt; 2 2 yufei 2 1 男 2.4.1.1.2 不同名称列关联 left_join(x,y,by = c(\"a\" = \"b\", \"c\" = \"d\")) 将会匹配 x$a to y$b 和 x$c to y$d 作为关联条件。 #出发机场和目的机场信息 flights2 %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 x 15 #&gt; year month day hour origin dest tailnum carrier name lat lon alt #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA George~ 30.0 -95.3 97 #&gt; 2 2013 1 1 5 LGA IAH N24211 UA George~ 30.0 -95.3 97 #&gt; 3 2013 1 1 5 JFK MIA N619AA AA Miami ~ 25.8 -80.3 8 #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 &lt;NA&gt; NA NA NA #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Hartsf~ 33.6 -84.4 1026 #&gt; 6 2013 1 1 5 EWR ORD N39463 UA Chicag~ 42.0 -87.9 668 #&gt; # ... with 336,770 more rows, and 3 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, #&gt; # tzone &lt;chr&gt; # flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) # 多条件关联时用逗号隔开 dta &lt;- data.frame(id = 1:2, Name = c(&#39;vega&#39;,&#39;yufei&#39;),Grade = 1:2) dtb &lt;- data.frame(id = 2:1,name = c(&#39;vega&#39;,&#39;yufei&#39;),grade = 1:2,性别 = c(&#39;男&#39;,&#39;男&#39;)) left_join(dta,dtb,by = c(&quot;Name&quot; = &quot;name&quot;,&quot;Grade&quot; = &quot;grade&quot;)) %&gt;% select(-id.x,-id.y) #&gt; Name Grade 性别 #&gt; 1 vega 1 男 #&gt; 2 yufei 2 男 2.4.1.1.3 不唯一关联 如果关联表中值不是唯一的，连接将添加匹配表的所有可能组合(笛卡尔积)： 右表重复 df1 &lt;- tibble(x = c(1, 2), y = 1:2) df2 &lt;- tibble(x = c(1, 1, 2,2), z = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;,&quot;b&quot;)) df1 %&gt;% left_join(df2) #&gt; Joining, by = &quot;x&quot; #&gt; # A tibble: 4 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 1 a #&gt; 2 1 1 a #&gt; 3 2 2 b #&gt; 4 2 2 b df1 %&gt;% right_join(df2) #&gt; Joining, by = &quot;x&quot; #&gt; # A tibble: 4 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 1 a #&gt; 2 1 1 a #&gt; 3 2 2 b #&gt; 4 2 2 b 两表重复 df1 &lt;- tibble(x = c(1, 1, 2), y = 1:3) df2 &lt;- tibble(x = c(1, 1, 2), z = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)) df1 %&gt;% left_join(df2) #&gt; Joining, by = &quot;x&quot; #&gt; # A tibble: 5 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 1 a #&gt; 2 1 1 b #&gt; 3 1 2 a #&gt; 4 1 2 b #&gt; 5 2 3 a 在我们工作中可能需要求两个表之间的笛卡尔乘积1，并且没有可关联字段，该如何求？ dta &lt;- data.frame(a=letters) dtb &lt;- data.frame(b=LETTERS) full_join(dta,dtb,by = character())%&gt;% glimpse() #&gt; Rows: 676 #&gt; Columns: 2 #&gt; $ a &lt;chr&gt; &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;~ #&gt; $ b &lt;chr&gt; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;~ 以上是简单的构造笛卡尔积表的办法，我们还可以通过构建相同列达到效果,如下所示： dta %&gt;% mutate(col = 1) %&gt;% left_join(dtb %&gt;% mutate(col=1)) %&gt;% mutate(col = NULL) %&gt;% glimpse() #&gt; Joining, by = &quot;col&quot; #&gt; Rows: 676 #&gt; Columns: 2 #&gt; $ a &lt;chr&gt; &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;~ #&gt; $ b &lt;chr&gt; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;~ 2.4.1.2 筛选关联 在某些时候筛选关联会比较方便，但是我个人比较少用。 anti_join():删除所有左表中在右表中匹配到的行 semi_join():保留所有左表在右表中匹配到的行 df1 &lt;- tibble(a=letters[1:20],b=1:20) df2 &lt;- tibble(a=letters,b=1:26) df2 %&gt;% anti_join(df1) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 6 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 u 21 #&gt; 2 v 22 #&gt; 3 w 23 #&gt; 4 x 24 #&gt; 5 y 25 #&gt; 6 z 26 df1 %&gt;% semi_join(df2) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 20 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 a 1 #&gt; 2 b 2 #&gt; 3 c 3 #&gt; 4 d 4 #&gt; 5 e 5 #&gt; 6 f 6 #&gt; # ... with 14 more rows 2.4.1.3 集合操作 以下动词要求x,y具有相同的变量，也就是x,y的格式一样。 intersect(x,y)返回x,y交集 union(x,y)返回x,y中唯一的值 setdiff(x,y)返回存在x中但是不存在y中的记录 union_all(x,y)返回全部值，不删除重复值 (df1 &lt;- tibble(x = 1:2, y = c(1L, 1L))) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 (df2 &lt;- tibble(x = 1:2, y = 1:2)) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 2 intersect(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 union(df1, df2) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 2 2 union_all(df1, df2) #&gt; # A tibble: 4 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 1 1 #&gt; 4 2 2 setdiff(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 1 setdiff(df2, df1) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 2 2.4.2 多表操作 当我们需要将多个表连续关联时: 常规写法 dt1 &lt;- data.frame(x = letters) dt2 &lt;- data.frame(x = letters,cola = 1:26) dt3 &lt;- data.frame(x = letters,colb = 1:26) dt4 &lt;- data.frame(x = letters,cold = 1:26) dt5 &lt;- data.frame(x = letters,cole = 1:26) dt1 %&gt;% left_join(dt2) %&gt;% left_join(dt3) %&gt;% left_join(dt4) %&gt;% left_join(dt5) #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; x cola colb cold cole #&gt; 1 a 1 1 1 1 #&gt; 2 b 2 2 2 2 #&gt; 3 c 3 3 3 3 #&gt; 4 d 4 4 4 4 #&gt; 5 e 5 5 5 5 #&gt; 6 f 6 6 6 6 #&gt; 7 g 7 7 7 7 #&gt; 8 h 8 8 8 8 #&gt; 9 i 9 9 9 9 #&gt; 10 j 10 10 10 10 #&gt; 11 k 11 11 11 11 #&gt; 12 l 12 12 12 12 #&gt; 13 m 13 13 13 13 #&gt; 14 n 14 14 14 14 #&gt; 15 o 15 15 15 15 #&gt; 16 p 16 16 16 16 #&gt; 17 q 17 17 17 17 #&gt; 18 r 18 18 18 18 #&gt; 19 s 19 19 19 19 #&gt; 20 t 20 20 20 20 #&gt; 21 u 21 21 21 21 #&gt; 22 v 22 22 22 22 #&gt; 23 w 23 23 23 23 #&gt; 24 x 24 24 24 24 #&gt; 25 y 25 25 25 25 #&gt; 26 z 26 26 26 26 改进写法 当需要合并多个表时，可用purrr::reduce()实现 dtlist &lt;- list(dt1,dt2,dt3,dt4,dt5) purrr::reduce(dtlist,left_join,by=&#39;x&#39;) #&gt; x cola colb cold cole #&gt; 1 a 1 1 1 1 #&gt; 2 b 2 2 2 2 #&gt; 3 c 3 3 3 3 #&gt; 4 d 4 4 4 4 #&gt; 5 e 5 5 5 5 #&gt; 6 f 6 6 6 6 #&gt; 7 g 7 7 7 7 #&gt; 8 h 8 8 8 8 #&gt; 9 i 9 9 9 9 #&gt; 10 j 10 10 10 10 #&gt; 11 k 11 11 11 11 #&gt; 12 l 12 12 12 12 #&gt; 13 m 13 13 13 13 #&gt; 14 n 14 14 14 14 #&gt; 15 o 15 15 15 15 #&gt; 16 p 16 16 16 16 #&gt; 17 q 17 17 17 17 #&gt; 18 r 18 18 18 18 #&gt; 19 s 19 19 19 19 #&gt; 20 t 20 20 20 20 #&gt; 21 u 21 21 21 21 #&gt; 22 v 22 22 22 22 #&gt; 23 w 23 23 23 23 #&gt; 24 x 24 24 24 24 #&gt; 25 y 25 25 25 25 #&gt; 26 z 26 26 26 26 笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尔积(Cartesian product)，又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员↩︎ "],["dplyr-groupby-manipulation.html", "2.5 分组操作", " 2.5 分组操作 详情: https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html group_by()最重要的分组动词,需要一个数据框和一个或多个变量进行分组： 2.5.1 添加分组 by_species &lt;- starwars %&gt;% group_by(species) by_sex_gender &lt;- starwars %&gt;% group_by(sex, gender) 除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在mutate()之后执行group_by: bmi_breaks &lt;- c(0, 18.5, 25, 30, Inf) starwars %&gt;% group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %&gt;% tally() #&gt; # A tibble: 5 x 2 #&gt; bmi_cat n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 (0,18.5] 10 #&gt; 2 (18.5,25] 24 #&gt; 3 (25,30] 13 #&gt; 4 (30,Inf] 12 #&gt; 5 &lt;NA&gt; 28 2.5.2 删除分组变量 要删除所有分组变量，使用ungroup(): by_species %&gt;% ungroup() %&gt;% tally() #&gt; # A tibble: 1 x 1 #&gt; n #&gt; &lt;int&gt; #&gt; 1 87 2.5.3 动词 summarise() 计算每个组的汇总，表示从group_keys开始右侧添加汇总变量 by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n height #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 79 #&gt; 2 Besalisk 1 198 #&gt; 3 Cerean 1 198 #&gt; 4 Chagrian 1 196 #&gt; 5 Clawdite 1 168 #&gt; 6 Droid 6 131. #&gt; # ... with 32 more rows 该.groups=参数控制输出的分组结构。删除右侧分组变量的历史行为对应于.groups = “drop_last”没有消息或.groups = NULL有消息（默认值）。 从1.0.0版开始，分组信息可以保留(.groups = \"keep\")或删除 (.groups = 'drop) a &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;drop&#39;) %&gt;% group_vars() b &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;keep&#39;) %&gt;% group_vars() object.size(a) #&gt; 48 bytes object.size(b) #&gt; 112 bytes 在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。 "],["dplyr-column-manipulation.html", "2.6 列操作", " 2.6 列操作 函数across()通过与summarise()和mutate()结合，很容易将某函数运用到多列上。函数across()取代了summarise_all(),summarise_at(),summarise_if()函数。 在多列上执行相同的函数是常用的操作，但是通过复制和粘贴代码，麻烦并且容易错,如下所示: df %&gt;% group_by(g1, g2) %&gt;% summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d)) 通过across()函数可以更简洁地重写上面代码： df %&gt;% group_by(g1, g2) %&gt;% summarise(across(a:d, mean)) 假设我们要将表格中多列向上取整? dt &lt;- tibble(a= rnorm(100,mean = 1),b=rnorm(100,mean = 1),d=rnorm(100,mean = 1)) dt %&gt;% mutate(across(a:d,ceiling)) #&gt; # A tibble: 100 x 3 #&gt; a b d #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 -1 1 #&gt; 2 2 2 3 #&gt; 3 1 2 2 #&gt; 4 0 2 2 #&gt; 5 1 1 1 #&gt; 6 2 1 1 #&gt; # ... with 94 more rows 2.6.1 基础用法 across() 有两个主要参数： 第一个参数，.cols选择要操作的列。它使用tidyr的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。 第二个参数，.fns是要应用于每一列的一个函数或函数列表。 也可以是purrr样式的公式（或公式列表），例如~ .x / 2。 starwars %&gt;% summarise(across(where(is.character), ~ length(unique(.x)))) #&gt; # A tibble: 1 x 8 #&gt; name hair_color skin_color eye_color sex gender homeworld species #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 87 13 31 15 5 3 49 38 starwars %&gt;% group_by(species) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(c(sex, gender, homeworld), ~ length(unique(.x)))) #&gt; # A tibble: 9 x 4 #&gt; species sex gender homeworld #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Droid 1 2 3 #&gt; 2 Gungan 1 1 1 #&gt; 3 Human 2 2 16 #&gt; 4 Kaminoan 2 2 1 #&gt; 5 Mirialan 1 1 1 #&gt; 6 Twi&#39;lek 2 2 1 #&gt; # ... with 3 more rows starwars %&gt;% group_by(homeworld) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) #&gt; # A tibble: 10 x 4 #&gt; homeworld height mass birth_year #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 176. 64 43 #&gt; 2 Corellia 175 78.5 25 #&gt; 3 Coruscant 174. 50 91 #&gt; 4 Kamino 208. 83.1 31.5 #&gt; 5 Kashyyyk 231 124 200 #&gt; 6 Mirial 168 53.1 49 #&gt; # ... with 4 more rows ~ .x / 2是purr包提供的函数式编程风格，等效于 function(x) (x/2) across() 不会选择分组变量： df &lt;- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9)) df %&gt;% group_by(g) %&gt;% summarise(across(where(is.numeric), sum)) #&gt; # A tibble: 2 x 3 #&gt; g x y #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 -5 #&gt; 2 2 3 -9 2.6.2 多种函数功能 通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量： min_max &lt;- list( min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE) ) starwars %&gt;% summarise(across(where(is.numeric), min_max)) #&gt; # A tibble: 1 x 6 #&gt; height_min height_max mass_min mass_max birth_year_min birth_year_max #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 通过.names参数控制名称： NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时 以下是官方案例，但是报错(目前已修复)： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{.fn}.{.col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; min.height max.height min.mass max.mass min.birth_year max.birth_year #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 修改后正常运行： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}.{col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; min.height max.height min.mass max.mass min.birth_year max.birth_year #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 区别主要是.names参数的使用方式问题，.加不加的问题。 starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}——{col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; `min——height` `max——height` `min——mass` `max——mass` `min——birth_year` #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 #&gt; # ... with 1 more variable: max——birth_year &lt;dbl&gt; 2.6.3 当前列 如果需要，可以通过调用访问内部的“当前”列的名称cur_column(),仅在across()使用。和Excel中power pivot的“上下文”概念类似。 该函数不是特别容易理解，需要多尝试使用加深认识。 df &lt;- tibble(x = 1:3, y = 3:5, z = 5:7) mult &lt;- list(x = 1, y = 10, z = 100) df %&gt;% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]])) #&gt; # A tibble: 3 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 30 500 #&gt; 2 2 40 600 #&gt; 3 3 50 700 代码解释：代码实现的是数据框df中列和mult中同名元素相乘得到新列。mult[[cur_column()]]依次返回mult[[“x”]],mult[[“y”]],mult[[“z”]]。 以上部分是关于列操作的内容，详情查看vignette(\"colwise\")。 "],["dplyr-row-manipulation.html", "2.7 行操作", " 2.7 行操作 行操作指不同字段间的计算，如Excle的列与列之间计算,Excle中的函数对行列不敏感，没有明显区别，但是R中tidyverse里列计算简单，行间计算依赖rowwise()函数实现。 Excel-sum df &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() #&gt; # A tibble: 2 x 3 #&gt; # Rowwise: #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 #&gt; 2 2 4 6 df %&gt;% rowwise() %&gt;% mutate(total = sum(c(x, y, z))) #返回结果与Excel一致 #&gt; # A tibble: 2 x 4 #&gt; # Rowwise: #&gt; x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 9 #&gt; 2 2 4 6 12 df %&gt;% mutate(total = sum(c(x, y, z))) # 返回结果不符合预期 #&gt; # A tibble: 2 x 4 #&gt; x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 21 #&gt; 2 2 4 6 21 2.7.1 比较差异 像group_by(),rowwise()并没有做任何事情，它的作用是改变其他动词的工作方式。 注意以下代码返回结果不同: df %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3.5 #&gt; 2 2 4 6 3.5 df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3 #&gt; 2 2 4 6 4 df %&gt;% mutate(m = mean(c(x, y, z)))返回的结果是x,y,z散列全部数据的均值；df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))通过rowwise改变了mean的作为范围，返回的某行x,y,z列3个数字的均值。两种动词的作用的范围因为rowwise完全改变。 可以选择在调用中提供“标识符”变量rowwise()。这些变量在您调用时被保留summarise()，因此它们的行为与传递给的分组变量有些相似group_by()： df &lt;- tibble(name = c(&quot;Mara&quot;, &quot;Hadley&quot;), x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has ungrouped output. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 1 #&gt; m #&gt; &lt;dbl&gt; #&gt; 1 3 #&gt; 2 4 df %&gt;% rowwise(name) %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has grouped output by &#39;name&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 2 #&gt; # Groups: name [2] #&gt; name m #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Mara 3 #&gt; 2 Hadley 4 2.7.2 常用案例 df &lt;- tibble(x = runif(6), y = runif(6), z = runif(6)) # Compute the mean of x, y, z in each row df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 6 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.116 0.690 0.827 0.544 #&gt; 2 0.443 0.432 0.626 0.500 #&gt; 3 0.797 0.896 0.0514 0.581 #&gt; 4 0.750 0.923 0.163 0.612 #&gt; 5 0.595 0.110 0.232 0.312 #&gt; 6 0.991 0.478 0.550 0.673 # Compute the minimum of x and y in each row df %&gt;% rowwise() %&gt;% mutate(m = min(c(x, y, z))) #&gt; # A tibble: 6 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.116 0.690 0.827 0.116 #&gt; 2 0.443 0.432 0.626 0.432 #&gt; 3 0.797 0.896 0.0514 0.0514 #&gt; 4 0.750 0.923 0.163 0.163 #&gt; 5 0.595 0.110 0.232 0.110 #&gt; 6 0.991 0.478 0.550 0.478 # In this case you can use an existing vectorised function: df %&gt;% mutate(m = pmin(x, y, z)) #&gt; # A tibble: 6 x 4 #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.116 0.690 0.827 0.116 #&gt; 2 0.443 0.432 0.626 0.432 #&gt; 3 0.797 0.896 0.0514 0.0514 #&gt; 4 0.750 0.923 0.163 0.163 #&gt; 5 0.595 0.110 0.232 0.110 #&gt; 6 0.991 0.478 0.550 0.478 键入每个变量名称很繁琐，通过c_across()使更简单。 详情可见vignette(“rowwise”)。 rf %&gt;% mutate(total = sum(c_across(w:z))) rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) rf %&gt;% mutate(total = sum(c_across(w:z))) %&gt;% ungroup() %&gt;% mutate(across(w:z, ~ . / total)) "],["dplyr-programming.html", "2.8 dplyr编程", " 2.8 dplyr编程 Programming with dplyr 本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。虽然复杂,但是比较实用，尤其是当我们需要定义一些通用功能函数时。 以下是对原文引用 两种情况： When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like filter(df, {{ var }}). The following function uses embracing to create a wrapper around summarise() that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised: var_summary &lt;- function(data, var) { data %&gt;% summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])). The following example uses .data to count the number of unique values in each variable of mtcars: for (var in names(mtcars)) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with .data$x or indirectly with .data[[var]]. Don’t expect other functions to work with it. 2.8.1 案例 当我们不知道接下来会用哪个变量汇总时： my_summarise &lt;- function(data, group_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean(mass)) } 如果在多个位置使用： my_summarise2 &lt;- function(data, expr) { data %&gt;% summarise( mean = mean({{ expr }}), sum = sum({{ expr }}), n = n() ) } 当多个表达式时： my_summarise3 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } 如果要输出变量名时： my_summarise4 &lt;- function(data, expr) { data %&gt;% summarise( &quot;mean_{{expr}}&quot; := mean({{ expr }}), &quot;sum_{{expr}}&quot; := sum({{ expr }}), &quot;n_{{expr}}&quot; := n() ) } my_summarise5 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise( &quot;mean_{{mean_var}}&quot; := mean({{ mean_var }}), &quot;sd_{{sd_var}}&quot; := mean({{ sd_var }}) ) } 任意个表达式： 这种使用场景更多 my_summarise &lt;- function(.data, ...) { .data %&gt;% group_by(...) %&gt;% summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE)) } starwars %&gt;% my_summarise(homeworld) #&gt; # A tibble: 49 x 3 #&gt; homeworld mass height #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 64 176. #&gt; 2 Aleen Minor 15 79 #&gt; 3 Bespin 79 175 #&gt; 4 Bestine IV 110 180 #&gt; 5 Cato Neimoidia 90 191 #&gt; 6 Cerea 82 198 #&gt; # ... with 43 more rows starwars %&gt;% my_summarise(sex, gender) #&gt; `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 6 x 4 #&gt; # Groups: sex [5] #&gt; sex gender mass height #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 female feminine 54.7 169. #&gt; 2 hermaphroditic masculine 1358 175 #&gt; 3 male masculine 81.0 179. #&gt; 4 none feminine NaN 96 #&gt; 5 none masculine 69.8 140 #&gt; 6 &lt;NA&gt; &lt;NA&gt; 48 181. "],["dplyr-reference-material.html", "2.9 参考资料", " 2.9 参考资料 1.programming https://dplyr.tidyverse.org/dev/articles/programming.html 2.https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html "]]
