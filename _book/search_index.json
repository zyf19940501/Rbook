[["index.html", "R学习笔记 1 说明", " R学习笔记 Yufei Zhong 2021-05-13 1 说明 作为商业数据分析师，我学习使用R以及有一段时间，主要用R来处理数据，自动化报表，ETL，可视化等，另外用shiny做看板。 R极大的拓展了数据处理能力,让我很轻松方便处理数据，有更多精力时间聚焦在具体问题上。 本文主要记录个人学习过程中的经验，因个人能力有限，难免出现错误，如阅读中发现错误，欢迎联系本人更正。 Email: 598253220@qq.com 微信公众号: 宇飞的世界 语雀: https://www.yuque.com/zyufei #查看版本信息 sessionInfo() #&gt; R version 4.0.5 (2021-03-31) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 19041) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=Chinese (Simplified)_China.936 #&gt; [2] LC_CTYPE=Chinese (Simplified)_China.936 #&gt; [3] LC_MONETARY=Chinese (Simplified)_China.936 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] bookdown_0.22 digest_0.6.27 R6_2.5.0 jsonlite_1.7.2 #&gt; [5] magrittr_2.0.1 evaluate_0.14 stringi_1.6.1 rlang_0.4.11 #&gt; [9] rstudioapi_0.13 jquerylib_0.1.4 bslib_0.2.5 rmarkdown_2.8 #&gt; [13] tools_4.0.5 stringr_1.4.0 xfun_0.22 yaml_2.2.1 #&gt; [17] compiler_4.0.5 htmltools_0.5.1.1 knitr_1.33 sass_0.4.0 "],["data-table.html", "2 data.table", " 2 data.table data.table包是我最常用的R包，是我目前觉得最好用的数据处理包,大部分我需要用到的功能集成在包里，不需要很多的依赖包。我简单接触过python，julia两种语言，并没有深入比较，所以我这个好用的印象仅仅是个人感受。 data.table包是我用了较长一段时间tidyverse系列后发现的“数据处理包”。已经忘记最初是什么吸引了我，我猜测可能是“大数据处理利器”之类的标签吸引了我，因为我喜欢“快”。但是和大部分人可能不同的是，初次接触时，语法的“怪异”并没有给我带来多少麻烦，因为我本来就没有编程基础以及很深的R语言基础。 所以我死记硬背data.table里一些常用用法，尤其喜欢拿Excle的一些用法参照，去实现Excle上面的部分操作，从读取、增、改、删除、筛选、计算列等常规操作入手。慢慢熟悉data.table语法之后，将会享受data.table带来的便利，其简洁的语法以及高效的计算速度（相比tidyverse系列）。 另外，Python中也有该包，目前正在积极开发中，期待ing，毕竟python也是很好用，在不同需求下选择不同的语言实现功能。 官方关于data.table的基础介绍请参阅: https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html data.table 优势： 速度快 内存效率高 API生命周期管理好 语法简洁 "],["基础介绍.html", "2.1 基础介绍", " 2.1 基础介绍 本部分从data.table安装，内置的案例查看，到data.table的句式语法，实现基础行列筛选和聚合计算。 1.安装 安装详细信息请参考the Installation wiki，有关于不同系统安装首次以及相关说明。 install.packages(&quot;data.table&quot;) # latest development version: data.table::update.dev.pkg() 2.使用说明 通过以下代码查看内置的使用案例。 library(data.table) example(data.table) 2.1.1 读取数据 在我实际工作中接触的数据大部分以数据库,csv,Excel等形式存在，并且CSV格式数据较少。但是data.table包读取数据的fread函数仅接受CSV格式。如果是Excel格式文件，需要通过如readxl，openxlsx等包读入后转换为data.table格式数据。 fread 函数可以直接读取CSV格式文件,无论是本地文件或者在线文件. 本文会照搬很多官方关于data.table的demo. library(data.table) input &lt;- if (file.exists(&quot;./data/flights.csv&quot;)) { &quot;./data/flights.csv&quot; #本地文件 } else { &quot;https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights.csv&quot; #在线文件需翻墙 } flights &lt;- fread(input) #具体参数请参照文档 实际工作中可能会用到的encoding参数,编码 encoding=&#39;UTF-8&#39; head(flights) #&gt; year month day dep_delay arr_delay carrier origin dest air_time distance #&gt; 1: 2014 1 1 14 13 AA JFK LAX 359 2475 #&gt; 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 #&gt; 3: 2014 1 1 2 9 AA JFK LAX 351 2475 #&gt; 4: 2014 1 1 -8 -26 AA LGA PBI 157 1035 #&gt; 5: 2014 1 1 2 1 AA JFK LAX 350 2475 #&gt; 6: 2014 1 1 4 0 AA EWR LAX 339 2454 #&gt; hour #&gt; 1: 9 #&gt; 2: 11 #&gt; 3: 19 #&gt; 4: 7 #&gt; 5: 13 #&gt; 6: 18 本文读取本地文件,如果该数据集下载失败,可更改地址为(http://www.zhongyufei.com/datatable/data/flights.csv) flights &lt;- fread(&quot;http://www.zhongyufei.com/datatable/data/flights.csv&quot;) 数据集记录的是 2014 年,纽约市3大机场(分别为:JFK 肯尼迪国际机场、 LGA 拉瓜迪亚机场,和 EWR 纽瓦克自由国际机场)起飞的航班信息。 具体的记录信息(特征列)，包括起飞时间、到达时间、延误时长、航空公司、始发机场、目的机场、飞行时长，和飞行距离等。 2.1.2 基本格式 DT[i, j, by]是data.table的基本样式，在不同位置上实现不同功能。 i-j-by DT[i, j, by] ## R: i j by ## SQL: where | order by select | update group by data.table个人理解主要有三大类参数,i参数做筛选,j参数做计算,by参数做分组. 拿Excel透视表类别,i位置参数当作『筛选』,by位置用来做汇总字段『行』,j位置当作『值』,如下所示: 透视表截图 1.代码实例 代码求2014年6月,从各始发机场到各目的机场的飞行距离求和. library(data.table) flights &lt;- fread(&quot;./data/flights.csv&quot;) flights[year==2014 &amp; month==6,.(求和项distance=sum(distance)),by=.(origin,dest)] #&gt; origin dest 求和项distance #&gt; 1: JFK LAX 2663100 #&gt; 2: JFK DFW 82069 #&gt; 3: JFK LAS 795792 #&gt; 4: JFK SFO 1967946 #&gt; 5: JFK SAN 349778 #&gt; --- #&gt; 191: EWR ANC 13480 #&gt; 192: EWR BZN 15056 #&gt; 193: LGA TVC 7205 #&gt; 194: LGA BZN 3788 #&gt; 195: JFK HYA 980 2.代码解释 i 的部分：条件year==2014 和 month==6 ; j 的部分：求和项distance=sum(distance)，写在.()中或者list()中； by 的部分.(origin,dest),重点是写在.()中,和Excel透视表一一对应。 至于为什么要用.()包裹起来，最开始默认为格式强制要求。就这个问题我想说：大部分人可能觉得是比较“怪异”的用法，并且不理解，从而可能留下data.table不好用，很古怪的印象，但是我觉得任何东西存在即合理，你学一个东西总得接受一些你可能不认可的东西，这样可能才是真正的学习，就像拿Python来做数据分析，我刚开始觉得pandas很难用，很反人类，但是后来知道python代码可以直接打包封装成exe后，觉得真香，说这么多主要是想表达我们学会挑选合适的工具用，适应它，用好它就可以了。 2.1.3 i j by 使用 使用data.table处理数据，接下来我们就用该函数读取数据演示i,j,by的简单使用。 2.1.3.1 i行筛选 行筛选是一种很常见的数据操作行为，类似我们Excel中的筛选，即按照一定条件筛选符合要求的数据。条件筛选一般分为单条件筛选、多条件筛选； 在筛选时涉及到条件判断，R语言中常用的条件判断分为逻辑运算、关系运算。常用的关系运算符 &gt;、 &lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。常用的逻辑运算符 &amp;、|、！等。 #单条件筛选 filghts[year == 2014] #筛选year==2014 #多条件筛选 用 &amp; 链接 flights[ year == 2014 &amp; month == 6] # | 相当于中文条件或 flights[ month == 5 | month == 6] # %in% 类似sql中in用法 flights[month %in% c(1,3,5,7,9)] # %between% 类似sql中between and 用法 flights[month %between% c(1,7)] 2.1.3.2 j列操作 数据集较大、字段较多时，由于无效信息较多可以做适当精选，这时需要我们筛选列。与sql中的select用法一致，即保留想要的字段。 .()或list()是data.table中的比较特殊的实现列筛选的用法。常规数字索引，字符向量索引同样有效。 #注意前面的. .() flights[,.(year,month,day,dep_delay,carrier,origin)] #&gt; year month day dep_delay carrier origin #&gt; 1: 2014 1 1 14 AA JFK #&gt; 2: 2014 1 1 -3 AA JFK #&gt; 3: 2014 1 1 2 AA JFK #&gt; 4: 2014 1 1 -8 AA LGA #&gt; 5: 2014 1 1 2 AA JFK #&gt; --- #&gt; 253312: 2014 10 31 1 UA LGA #&gt; 253313: 2014 10 31 -5 UA EWR #&gt; 253314: 2014 10 31 -8 MQ LGA #&gt; 253315: 2014 10 31 -4 MQ LGA #&gt; 253316: 2014 10 31 -5 MQ LGA # flights[,list(year,month,day,dep_delay,carrier,origin)] same above # not run # flights[,1:3] # not run # flights[,c(&#39;year&#39;,&#39;month&#39;,&#39;day&#39;)] setcolorder函数可以调整列的顺序，将常用的字段信息排在前面可以用过该函数实现。 # not run # setcolorder(x = flights,neworder = c( &quot;month&quot;,&quot;day&quot;,&quot;dep_delay&quot; ,&quot;arr_delay&quot;,&quot;carrier&quot; )) # 按照指定列顺序排序 其余字段保持不变,不是建立副本,是直接修改了flights 数据的列顺序 常规计算 根据最开始的Excel透视表截图，我们想要获得如截图一样的结果该怎么实现呢？代码如下： flights[year==2014 &amp; month==6,.(求和项distance=sum(distance),平均距离=mean(distance)),by=.(origin,dest)] 在i的位置做筛选，j的位置做计算，by指定分组字段。在j的位置可以做各种各样的计算，R中自带的函数，或者是自己定义的函数。 myfun &lt;- function(x){ x^2/2 } flights[year==2014 &amp; month==6,.(myfun(distance)),by=.(origin,dest)] #&gt; origin dest V1 #&gt; 1: JFK LAX 3062813 #&gt; 2: JFK LAX 3062813 #&gt; 3: JFK LAX 3062813 #&gt; 4: JFK LAX 3062813 #&gt; 5: JFK LAX 3062813 #&gt; --- #&gt; 26484: JFK HYA 19208 #&gt; 26485: JFK HYA 19208 #&gt; 26486: JFK HYA 19208 #&gt; 26487: JFK HYA 19208 #&gt; 26488: JFK HYA 19208 2.1.3.3 by 分组 分组是按照某种分组实现一定条件下某种聚合方式的计算。分组可以是单字段，多字段以及条件字段等。 1.按月分组 flights[,.(sum(distance)),by=.(month)] #&gt; month V1 #&gt; 1: 1 25112563 #&gt; 2: 2 22840391 #&gt; 3: 3 28716598 #&gt; 4: 4 27816797 #&gt; 5: 5 28030020 #&gt; 6: 6 29093557 #&gt; 7: 7 30059175 #&gt; 8: 8 30322047 #&gt; 9: 9 27615097 #&gt; 10: 10 28900834 2.多条件分组 dt &lt;- flights[,.(sum(distance)),by=.(carrier,origin)] head(dt) #&gt; carrier origin V1 #&gt; 1: AA JFK 20492213 #&gt; 2: AA LGA 12365282 #&gt; 3: AA EWR 3550217 #&gt; 4: AS EWR 1378748 #&gt; 5: B6 JFK 38117662 #&gt; 6: B6 EWR 4508574 #可直接重新命名 dt &lt;- flights[,.(sum(distance)),by=.(newcol1 = carrier,newcol2 = origin)] head(dt) #&gt; newcol1 newcol2 V1 #&gt; 1: AA JFK 20492213 #&gt; 2: AA LGA 12365282 #&gt; 3: AA EWR 3550217 #&gt; 4: AS EWR 1378748 #&gt; 5: B6 JFK 38117662 #&gt; 6: B6 EWR 4508574 3.按月份是否大于6分组 即得到是否大于6的两类分组 dt &lt;- flights[,.(sum(distance)),by=.(month&gt;6)] #by里面可以做计算 head(dt) #&gt; month V1 #&gt; 1: FALSE 161609926 #&gt; 2: TRUE 116897153 2.1.4 行列筛选总结 行筛选在 i 的位置上进行, 列筛选在 j 的位置上进行;data.table中j的位置比较灵活多变，但是i的位置大部分时候都是进行条件筛选。我们通过上述的行列筛选已经大概知道data.table中i,j的用法。也就是我们常规数据清洗过程中的数据筛选过程，筛选符合要求的数据记录。 dt &lt;- flights[ year == 2014 &amp; month == 6 &amp; day &gt;=15,.(year,month,day,dep_delay,carrier,origin)] head(dt) #&gt; year month day dep_delay carrier origin #&gt; 1: 2014 6 15 -4 AA JFK #&gt; 2: 2014 6 15 -8 AA JFK #&gt; 3: 2014 6 15 -12 AA JFK #&gt; 4: 2014 6 15 -4 AA LGA #&gt; 5: 2014 6 15 -3 AA JFK #&gt; 6: 2014 6 15 5 AA JFK "],["常规操作.html", "2.2 常规操作", " 2.2 常规操作 2.2.1 行筛选 上文已经大致讲过行筛选，但是行筛选使用有一定的技巧，涉及到运算的快慢。主要是逻辑条件的设置，交集并集之间的差异。除了上文中的关系运算筛选，逻辑运算筛选除外，data.table中还有几个常用的筛选函数。 数字向量筛选 %in%用法与 sql 中 in 用法类似。 # 筛选 %in% flights[ hour %in% seq(1,24,2) ] 字符向量筛选 %chin%用法与 %in% 类似，但仅仅针对字符。 # 字符筛选 flights[ origin %chin% c(&#39;JFK&#39;,&#39;LGA&#39;)] # not run 同上 %chin% 对字符速度筛选速度更快 #flights[ origin %in% c(&#39;JFK&#39;,&#39;LGA&#39;)] between 筛选 该函数的新特性矢量化挺实用。 #between 函数参数 #between(x, lower, upper, incbounds=TRUE, NAbounds=TRUE, check=FALSE) X &lt;- data.table(a=1:5, b=6:10, c=c(5:1)) X[b %between% c(7,9)] #&gt; a b c #&gt; 1: 2 7 4 #&gt; 2: 3 8 3 #&gt; 3: 4 9 2 X[between(b, 7, 9)] #效果同上 #&gt; a b c #&gt; 1: 2 7 4 #&gt; 2: 3 8 3 #&gt; 3: 4 9 2 X[c %between% list(a,b)] # 矢量化 #&gt; a b c #&gt; 1: 1 6 5 #&gt; 2: 2 7 4 #&gt; 3: 3 8 3 like 筛选 %like% 用法与SQL中 like 类似。 # %like% 用法与SQL中 like 类似 DT = data.table(Name=c(&quot;Mary&quot;,&quot;George&quot;,&quot;Martha&quot;), Salary=c(2,3,4)) DT[Name %like% &quot;^Mar&quot;] #&gt; Name Salary #&gt; 1: Mary 2 #&gt; 2: Martha 4 2.2.2 新增更新列 新增或删除或更新列是我们数据清洗过程中的常规操作，data.table中实现该类功能是通过:=符号实现。 选择列 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) dt[,.(col1,col2)] #&gt; col1 col2 #&gt; 1: 1 a #&gt; 2: 2 b #&gt; 3: 3 c #&gt; 4: 4 d #&gt; 5: 5 e #&gt; 6: 6 f #&gt; 7: 7 g #&gt; 8: 8 h #&gt; 9: 9 i #&gt; 10: 10 j # same above dt[,list(col1,col2)] #&gt; col1 col2 #&gt; 1: 1 a #&gt; 2: 2 b #&gt; 3: 3 c #&gt; 4: 4 d #&gt; 5: 5 e #&gt; 6: 6 f #&gt; 7: 7 g #&gt; 8: 8 h #&gt; 9: 9 i #&gt; 10: 10 j 新增列 如下所示:新增addcol列，最后的[]是为了显示新增列的数据框,可不增加。 #data.table()函数创建data.table数据框 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) # 新增列 := dt[,addcol:=rep(&#39;新列&#39;,10)][] #最后的[]是为了显示新增列的数据框,可不增加 #&gt; col1 col2 col3 col4 addcol #&gt; 1: 1 a A 1 新列 #&gt; 2: 2 b B 2 新列 #&gt; 3: 3 c C 3 新列 #&gt; 4: 4 d D 4 新列 #&gt; 5: 5 e E 5 新列 #&gt; 6: 6 f F 6 新列 #&gt; 7: 7 g G 7 新列 #&gt; 8: 8 h H 8 新列 #&gt; 9: 9 i I 9 新列 #&gt; 10: 10 j J 10 新列 #dt[,addcol:=rep(&#39;新列&#39;,10)] 不会显示返回结果,加上[]会显示返回 # 新增多列 dt[,`:=`(newcol1=rep(&#39;newcol1&#39;,10),newcol2=rep(&#39;newcol2&#39;,10))][] #&gt; col1 col2 col3 col4 addcol newcol1 newcol2 #&gt; 1: 1 a A 1 新列 newcol1 newcol2 #&gt; 2: 2 b B 2 新列 newcol1 newcol2 #&gt; 3: 3 c C 3 新列 newcol1 newcol2 #&gt; 4: 4 d D 4 新列 newcol1 newcol2 #&gt; 5: 5 e E 5 新列 newcol1 newcol2 #&gt; 6: 6 f F 6 新列 newcol1 newcol2 #&gt; 7: 7 g G 7 新列 newcol1 newcol2 #&gt; 8: 8 h H 8 新列 newcol1 newcol2 #&gt; 9: 9 i I 9 新列 newcol1 newcol2 #&gt; 10: 10 j J 10 新列 newcol1 newcol2 删除列 删除列即将列赋值NULL即可 # 删除列 dt[,col1:=NULL][] #&gt; col2 col3 col4 addcol newcol1 newcol2 #&gt; 1: a A 1 新列 newcol1 newcol2 #&gt; 2: b B 2 新列 newcol1 newcol2 #&gt; 3: c C 3 新列 newcol1 newcol2 #&gt; 4: d D 4 新列 newcol1 newcol2 #&gt; 5: e E 5 新列 newcol1 newcol2 #&gt; 6: f F 6 新列 newcol1 newcol2 #&gt; 7: g G 7 新列 newcol1 newcol2 #&gt; 8: h H 8 新列 newcol1 newcol2 #&gt; 9: i I 9 新列 newcol1 newcol2 #&gt; 10: j J 10 新列 newcol1 newcol2 # 删除多列 dt[,c(&#39;newcol1&#39;,&#39;newcol2&#39;):=NULL][] #&gt; col2 col3 col4 addcol #&gt; 1: a A 1 新列 #&gt; 2: b B 2 新列 #&gt; 3: c C 3 新列 #&gt; 4: d D 4 新列 #&gt; 5: e E 5 新列 #&gt; 6: f F 6 新列 #&gt; 7: g G 7 新列 #&gt; 8: h H 8 新列 #&gt; 9: i I 9 新列 #&gt; 10: j J 10 新列 更新 更新即重新赋值，将现有列参与计算等于是重新赋值，可以看成是更新列。 # 更新列 dt[,col1:=11:20][] #&gt; col2 col3 col4 addcol col1 #&gt; 1: a A 1 新列 11 #&gt; 2: b B 2 新列 12 #&gt; 3: c C 3 新列 13 #&gt; 4: d D 4 新列 14 #&gt; 5: e E 5 新列 15 #&gt; 6: f F 6 新列 16 #&gt; 7: g G 7 新列 17 #&gt; 8: h H 8 新列 18 #&gt; 9: i I 9 新列 19 #&gt; 10: j J 10 新列 20 # not run # 两列间计算 也可以理解为更新 dt[,newcol:=col1/col4] Note: DT[a &gt; 4, b := c] is different from DT[a &gt; 4][, b := c] 2.2.3 排序 当我们清洗数据时，我们需要将数据框排序，我们可以使用setorder或setorderv函数实现排序。函数是data.table包的函数，比base R 中的order函数要节省内存。 注意：按照函数文档说法：Note that queries like x[order(.)] are optimised internally to use data.table’s fast order。即x[order(.)]这样的用法会被优化为data.table的排序方法。 set.seed(45L) DT = data.table(A=sample(3, 10, TRUE), B=sample(letters[1:3], 10, TRUE), C=sample(10)) setorder(DT, A, -B) #将DT按照A、B排序 A 升序,-B降序 # 和上面同样的效果 但是函数变成 setorderv setorderv(DT, c(&quot;A&quot;, &quot;B&quot;), c(1, -1)) "],["常用函数.html", "2.3 常用函数", " 2.3 常用函数 常用函数指我们常用功能的函数，如排名、排序、非重复计数、判断、表连接、长宽转换等功能。 2.3.1 特殊符号 .SD,.BY,.N,.I,.NGRP和.GRP,.SDcols等,只能用在 j 的位置,.N 可以用在 i 的位置。 如果想要记住用法需要自己多尝试练习，对于我来说.N使用较多。 DT = data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT #&gt; x v y a b #&gt; 1: b 1 1 1 9 #&gt; 2: b 1 3 2 8 #&gt; 3: b 1 6 3 7 #&gt; 4: a 2 1 4 6 #&gt; 5: a 2 3 5 5 #&gt; 6: a 1 6 6 4 #&gt; 7: c 1 1 7 3 #&gt; 8: c 2 3 8 2 #&gt; 9: c 2 6 9 1 X = data.table(x=c(&quot;c&quot;,&quot;b&quot;), v=8:7, foo=c(4,2)) X #&gt; x v foo #&gt; 1: c 8 4 #&gt; 2: b 7 2 # 用在i的位置 DT[.N] #取DT最后一行,.N 计数函数 #&gt; x v y a b #&gt; 1: c 2 6 9 1 DT[,.N] #DT 共有多少行记录 返回一个整数 #&gt; [1] 9 DT[, .N, by=x] #分组计数 #&gt; x N #&gt; 1: b 3 #&gt; 2: a 3 #&gt; 3: c 3 DT[, .SD, .SDcols=x:y] # 选择x 到y 列 #&gt; x v y #&gt; 1: b 1 1 #&gt; 2: b 1 3 #&gt; 3: b 1 6 #&gt; 4: a 2 1 #&gt; 5: a 2 3 #&gt; 6: a 1 6 #&gt; 7: c 1 1 #&gt; 8: c 2 3 #&gt; 9: c 2 6 #DT[, .SD, .SDcols=c(&quot;x&quot;,&quot;y&quot;)] 与上面不一样 DT[, .SD[1]] #取第一行 #&gt; x v y a b #&gt; 1: b 1 1 1 9 DT[, .SD[1], by=x] #按x列分组后 #&gt; x v y a b #&gt; 1: b 1 1 1 9 #&gt; 2: a 2 1 4 6 #&gt; 3: c 1 1 7 3 DT[, c(.N, lapply(.SD, sum)), by=x] #按照x分组后 行数计数和每列求和 #&gt; x N v y a b #&gt; 1: b 3 3 10 6 24 #&gt; 2: a 3 5 10 15 15 #&gt; 3: c 3 5 10 24 6 2.3.2 排序函数 frank和frankv函数参数如下： frank(x, ..., na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) frankv(x, cols=seq_along(x), order=1L, na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) 官方案例,如下所示: # on vectors x = c(4, 1, 4, NA, 1, NA, 4) # NAs are considered identical (unlike base R) # default is average frankv(x) # na.last=TRUE #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(x, na.last=FALSE) #&gt; [1] 6.0 3.5 6.0 1.5 3.5 1.5 6.0 # on data.table DT = data.table(x, y=c(1, 1, 1, 0, NA, 0, 2)) frankv(DT, cols=&quot;x&quot;) # same as frankv(x) from before #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(DT, cols=&quot;x&quot;, na.last=&quot;keep&quot;) #&gt; [1] 4.0 1.5 4.0 NA 1.5 NA 4.0 frankv(DT, cols=&quot;x&quot;, ties.method=&quot;dense&quot;, na.last=NA) #&gt; [1] 2 1 2 1 2 frank(DT, x, ties.method=&quot;dense&quot;, na.last=NA) # equivalent of above using frank #&gt; [1] 2 1 2 1 2 frankv在排序时,NA被认为是一样的,基础base R 中认为不一样. x &lt;- c(4, 1, 4, NA, 1, NA, 4) frankv(x) #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 rank(x) #&gt; [1] 4.0 1.5 4.0 6.0 1.5 7.0 4.0 升序降序选择 order参数只能为1或者-1.默认为1代表升序 frankv(x,order = 1L) #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(x,order = -1L) #&gt; [1] 2.0 4.5 2.0 6.5 4.5 6.5 2.0 排序方式选择 默认 average,还有dense,random,first,last,max,min等方式。其中dense是紧凑排名，random是随机让相同的随机排列后排名 x &lt;- c(1,1,1,2,3) frankv(x) #大小相同 排名相同,下一位排名除以2 frankv(x,ties.method = &#39;min&#39;) #大小相同 排名相同,取最小排名 frankv(x,ties.method = &#39;max&#39;) #大小相同 排名相同,取最大排名 frankv(x,ties.method = &#39;first&#39;) #相同大小排名以后往后递增 根据实际情况决定 frankv(x,ties.method = &#39;dense&#39;) frankv(x,ties.method = &#39;random&#39;) NA处理 默认是将NA排在最后,NAs是相同的，与base R 不一样。 na.last参数等于TRUE时，缺失值被排最后；如果等于FALSE,放在前面；如果等于NA，将被移除；如果等于“keep,”将会保留NA. frankv(c(NA,NA,1,2,3), na.last = TRUE,ties.method = &#39;first&#39;) #&gt; [1] 4 5 1 2 3 frankv(c(NA,NA,1,2,3), na.last = FALSE,ties.method = &#39;first&#39;) #&gt; [1] 1 2 3 4 5 frankv(c(NA,NA,1,2,3), na.last = NA,ties.method = &#39;first&#39;) #&gt; [1] 1 2 3 frankv(c(NA,NA,1,2,3), na.last = &#39;keep&#39;,ties.method = &#39;first&#39;) #&gt; [1] NA NA 1 2 3 2.3.3 非重复计数 uniqueN相当于length(unique(x)),但是计算更快，内存效率更高。 x &lt;-sample(1:10,50,replace = TRUE) uniqueN(x) #&gt; [1] 10 DT &lt;- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3), C = rep(1:2, 6), key = &quot;A,B&quot;) uniqueN(DT, by = key(DT)) #&gt; [1] 6 uniqueN(DT) #&gt; [1] 10 2.3.4 判断函数 fifelse fifelse()类似dplyr::if_else()函数,相比base::ifelse() 更快。 x &lt;- c(1:4, 3:2, 1:4,5) fifelse(x &gt; 2L, x, x - 1L) #&gt; [1] 0 1 3 4 3 1 0 1 3 4 5 fifelse(x &gt; 2L,fifelse(x &gt;= 4L,x + 1L,x),x-1L) #&gt; [1] 0 1 3 5 3 1 0 1 3 5 6 fcase 与sql中的case when，与dplyr中的case_when()函数用法相似。相比fifelse相比，嵌套更加方便。 x = 1:10 fcase( x &lt; 5L, 1L, x &gt; 5L, 3L ) #&gt; [1] 1 1 1 1 NA 3 3 3 3 3 # not run 两种函数实现方式 fifelse(x &gt; 5,fifelse(x &gt;8,2,1),0) #&gt; [1] 0 0 0 0 0 1 1 1 2 2 fcase( x &gt; 8,2, x &gt; 5,1, default = 0 ) #&gt; [1] 0 0 0 0 0 1 1 1 2 2 2.3.5 交集 差集 合并 相当于base R 中 union(),intersect(),setdiff() 和setequal() 功能.all参数控制如何处理重复的行,和SQL中不同的是,data.table将保留行顺序. fintersect(x, y, all = FALSE) fsetdiff(x, y, all = FALSE) funion(x, y, all = FALSE) fsetequal(x, y, all = TRUE) x &lt;- data.table(c(1,2,2,2,3,4,4)) x2 &lt;- data.table(c(1,2,3,4)) # same set of rows as x y &lt;- data.table(c(2,3,4,4,4,5)) fintersect(x, y) # intersect fintersect(x, y, all=TRUE) # intersect all fsetdiff(x, y) # except fsetdiff(x, y, all=TRUE) # except all funion(x, y) # union funion(x, y, all=TRUE) # union all fsetequal(x, x2, all=FALSE) # setequal fsetequal(x, x2) # setequal all 2.3.6 长宽转换 主要是两个函数dcast以及melt实现长宽转换，实现Excel中部分透视表功能。具体的函数参数请自行查阅文档。 dcast函数能实现长转宽 参数如下：fun.aggregate函数指定聚合函数，value.var参数指定参与聚合的字段。formula指定聚合维度，格式用x+y~z，其中x,y在行的位置，z在列的位置。 dcast(data, formula, fun.aggregate = NULL, sep = &quot;_&quot;, ..., margins = NULL, subset = NULL, fill = NULL, drop = TRUE, value.var = guess(data), verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下： dt &lt;- data.table(分公司=rep(c(&#39;华东&#39;,&#39;华南&#39;,&#39;华西&#39;,&#39;华北&#39;),1000), 季度=rep(c(&#39;一季度&#39;,&#39;二季度&#39;,&#39;三季度&#39;,&#39;四季度&#39;),1000), 销售额=sample(100:200,4000,replace = TRUE)) dcast(dt,分公司~季度,value.var = &quot;销售额&quot;,fun.aggregate = sum) #&gt; 分公司 一季度 三季度 二季度 四季度 #&gt; 1: 华东 149470 0 0 0 #&gt; 2: 华北 0 0 0 149343 #&gt; 3: 华南 0 0 150489 0 #&gt; 4: 华西 0 150698 0 0 从版本V1.9.6起可以同时对多个值实现不同聚合后的长转宽。 fun参数即 fun.aggregate的简写，可以是自定义的函数。 dt &lt;- data.table(x=sample(5,20,TRUE), y=sample(2,20,TRUE), z=sample(letters[1:2], 20,TRUE), d1 = runif(20), d2=1L) dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=c(&quot;d1&quot;,&quot;d2&quot;)) #&gt; x y d1_sum_a d1_sum_b d2_sum_a d2_sum_b d1_mean_a d1_mean_b d2_mean_a #&gt; 1: 1 1 0.8454 0.3717 1 2 0.8454 0.1858 1 #&gt; 2: 1 2 0.3769 0.0000 1 0 0.3769 NaN 1 #&gt; 3: 2 1 1.3419 0.4810 2 1 0.6709 0.4810 1 #&gt; 4: 2 2 0.0000 0.6666 0 1 NaN 0.6666 NaN #&gt; 5: 3 1 0.8703 0.1866 1 1 0.8703 0.1866 1 #&gt; 6: 3 2 0.0000 0.9074 0 2 NaN 0.4537 NaN #&gt; 7: 4 1 0.0957 0.0000 1 0 0.0957 NaN 1 #&gt; 8: 4 2 0.1103 0.1867 1 1 0.1103 0.1867 1 #&gt; 9: 5 1 1.1344 0.0000 2 0 0.5672 NaN 1 #&gt; 10: 5 2 1.0839 0.0707 2 1 0.5419 0.0707 1 #&gt; d2_mean_b #&gt; 1: 1 #&gt; 2: NaN #&gt; 3: 1 #&gt; 4: 1 #&gt; 5: 1 #&gt; 6: 1 #&gt; 7: NaN #&gt; 8: 1 #&gt; 9: NaN #&gt; 10: 1 dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=list(&quot;d1&quot;,&quot;d2&quot;)) #注意value.var是向量和列表时的区别 #&gt; x y d1_sum_a d1_sum_b d2_mean_a d2_mean_b #&gt; 1: 1 1 0.8454 0.3717 1 1 #&gt; 2: 1 2 0.3769 0.0000 1 NaN #&gt; 3: 2 1 1.3419 0.4810 1 1 #&gt; 4: 2 2 0.0000 0.6666 NaN 1 #&gt; 5: 3 1 0.8703 0.1866 1 1 #&gt; 6: 3 2 0.0000 0.9074 NaN 1 #&gt; 7: 4 1 0.0957 0.0000 1 NaN #&gt; 8: 4 2 0.1103 0.1867 1 1 #&gt; 9: 5 1 1.1344 0.0000 1 NaN #&gt; 10: 5 2 1.0839 0.0707 1 1 melt函数实现宽转长 melt(data, id.vars, measure.vars, variable.name = &quot;variable&quot;, value.name = &quot;value&quot;, ..., na.rm = FALSE, variable.factor = TRUE, value.factor = FALSE, verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下: ChickWeight = as.data.table(ChickWeight) setnames(ChickWeight, tolower(names(ChickWeight))) DT &lt;- melt(as.data.table(ChickWeight), id=2:4) # calls melt.data.table DT #&gt; time chick diet variable value #&gt; 1: 0 1 1 weight 42 #&gt; 2: 2 1 1 weight 51 #&gt; 3: 4 1 1 weight 59 #&gt; 4: 6 1 1 weight 64 #&gt; 5: 8 1 1 weight 76 #&gt; --- #&gt; 574: 14 50 4 weight 175 #&gt; 575: 16 50 4 weight 205 #&gt; 576: 18 50 4 weight 234 #&gt; 577: 20 50 4 weight 264 #&gt; 578: 21 50 4 weight 264 2.3.7 表连接 两个数据框之间左连,右连等操作,类似数据库中的left_join right_join,inner_join 等函数. 键入?merge()查看函数帮助,data.table 包中和base R 中都有merge 函数,当第一个数据框是data.table格式时启用data.table::merge(). ?merge() merge(x, y, by = NULL, by.x = NULL, by.y = NULL, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(&quot;.x&quot;, &quot;.y&quot;), no.dups = TRUE, allow.cartesian=getOption(&quot;datatable.allow.cartesian&quot;), # default FALSE ...) x.y为连个数据框,当两个数据框连接字段相同时,用by=c(’‘,’’)连接,不同时采用,by.x=,by.y= ,all,all.x,all.y等参数决定连接方式,sort 默认为排序,当不需要排序时更改参数,allow.cartesian=是否允许笛卡尔,默认不允许,当需要时设置为TURE. "],["高级函数.html", "2.4 高级函数", " 2.4 高级函数 高级函数并不是指使用难度，而是使用频率可能不高，但在实现某些功能时特别便利的函数。 如分组聚合的groupingsets,前后移动的shift等函数。 2.4.1 groupingsets 产生多个层次的合计数据，与sql中的grouping set功能相似。 用法 rollup(x, j, by, .SDcols, id = FALSE, ...) groupingsets(x, j, by, sets, .SDcols, id = FALSE, jj, ...) # rollup rollup(DT, j = lapply(.SD, sum), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE, .SDcols=&quot;value&quot;) rollup(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 如果要达到像Excel中透视表一样的效果，如下所示: Excel groupingsets透视表 rollup library(magrittr) DT &lt;- fread(&#39;./data/data-table-groupingsets.csv&#39;,encoding = &#39;UTF-8&#39;) (rollup(DT,j =list(以下项目的总和 =sum(value)),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) %&gt;% setorderv(cols=c(&#39;area&#39;,&#39;grouping&#39;),na.last = TRUE)) #&gt; grouping area store_type 以下项目的总和 #&gt; 1: 0 华东 不可比 9 #&gt; 2: 0 华东 可比 309 #&gt; 3: 1 华东 &lt;NA&gt; 318 #&gt; 4: 0 华北 不可比 72 #&gt; 5: 0 华北 可比 173 #&gt; 6: 1 华北 &lt;NA&gt; 245 #&gt; 7: 0 华南 可比 86 #&gt; 8: 0 华南 不可比 79 #&gt; 9: 1 华南 &lt;NA&gt; 165 #&gt; 10: 0 华西 可比 2 #&gt; 11: 0 华西 不可比 198 #&gt; 12: 1 华西 &lt;NA&gt; 200 #&gt; 13: 3 &lt;NA&gt; &lt;NA&gt; 928 通过上述计算,发现计算结果与Excel透视表一样。 cube 观察cube()计算结果与rollup()差异，发现cube()聚合层次更多。 cube(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 0 华东 不可比 9 #&gt; 2: 0 华东 可比 309 #&gt; 3: 0 华西 可比 2 #&gt; 4: 0 华西 不可比 198 #&gt; 5: 0 华南 可比 86 #&gt; 6: 0 华北 不可比 72 #&gt; 7: 0 华南 不可比 79 #&gt; 8: 0 华北 可比 173 #&gt; 9: 1 华东 &lt;NA&gt; 318 #&gt; 10: 1 华西 &lt;NA&gt; 200 #&gt; 11: 1 华南 &lt;NA&gt; 165 #&gt; 12: 1 华北 &lt;NA&gt; 245 #&gt; 13: 2 &lt;NA&gt; 不可比 358 #&gt; 14: 2 &lt;NA&gt; 可比 570 #&gt; 15: 3 &lt;NA&gt; &lt;NA&gt; 928 groupingsets 根据需要指定指定聚合的层次。 # 与本例中rollup 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;), character()),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 1 华东 &lt;NA&gt; 318 #&gt; 2: 1 华西 &lt;NA&gt; 200 #&gt; 3: 1 华南 &lt;NA&gt; 165 #&gt; 4: 1 华北 &lt;NA&gt; 245 #&gt; 5: 0 华东 不可比 9 #&gt; 6: 0 华东 可比 309 #&gt; 7: 0 华西 可比 2 #&gt; 8: 0 华西 不可比 198 #&gt; 9: 0 华南 可比 86 #&gt; 10: 0 华北 不可比 72 #&gt; 11: 0 华南 不可比 79 #&gt; 12: 0 华北 可比 173 #&gt; 13: 3 &lt;NA&gt; &lt;NA&gt; 928 # 与本例中cube 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;),&quot;store_type&quot;, character()),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 1 华东 &lt;NA&gt; 318 #&gt; 2: 1 华西 &lt;NA&gt; 200 #&gt; 3: 1 华南 &lt;NA&gt; 165 #&gt; 4: 1 华北 &lt;NA&gt; 245 #&gt; 5: 0 华东 不可比 9 #&gt; 6: 0 华东 可比 309 #&gt; 7: 0 华西 可比 2 #&gt; 8: 0 华西 不可比 198 #&gt; 9: 0 华南 可比 86 #&gt; 10: 0 华北 不可比 72 #&gt; 11: 0 华南 不可比 79 #&gt; 12: 0 华北 可比 173 #&gt; 13: 2 &lt;NA&gt; 不可比 358 #&gt; 14: 2 &lt;NA&gt; 可比 570 #&gt; 15: 3 &lt;NA&gt; &lt;NA&gt; 928 groupingsets: sets参数,用list()包裹想要聚合的字段组合,最后character(),加上该部分相当于不区分层级全部聚合,用法类似sql中“().” SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ()); 2.4.2 rleid 该函数根据分组生成长度列。 即将0011001110111101类似这种分组成1 1 2 2 3 3 4 4 4 5 6 6 6 6 7 8。在特定时候是很便捷的一个函数。如在计算股票连续上涨或下跌天数时。 rleid(c(0,0,1,1,0,0,1,1,1,0,1,1,1,1,0,1)) #&gt; [1] 1 1 2 2 3 3 4 4 4 5 6 6 6 6 7 8 用法： rleid(..., prefix=NULL) rleidv(x, cols=seq_along(x), prefix=NULL) DT = data.table(grp=rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;), c(2,2,3,1,2)), value=1:10) rleid(DT$grp) # get run-length ids #&gt; [1] 1 1 2 2 3 3 3 4 5 5 rleidv(DT, &quot;grp&quot;) # same as above #&gt; [1] 1 1 2 2 3 3 3 4 5 5 rleid(DT$grp, prefix=&quot;grp&quot;) # prefix with &#39;grp&#39; #&gt; [1] &quot;grp1&quot; &quot;grp1&quot; &quot;grp2&quot; &quot;grp2&quot; &quot;grp3&quot; &quot;grp3&quot; &quot;grp3&quot; &quot;grp4&quot; &quot;grp5&quot; &quot;grp5&quot; 2.4.3 shift 向前或向后功能,通俗来说就是向前或向后移动位置。 示例如下： x = 1:5 # lag with n=1 and pad with NA (returns vector) shift(x, n=1, fill=NA, type=&quot;lag&quot;) #&gt; [1] NA 1 2 3 4 其中参数n控制偏移量，n正负数和type的参数相对应。, n=-1 and type=‘lead’ 与 n=1 and type=’lag’效果相同。 在data.table上使用： DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5]) cols = c(&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;) anscols = paste(&quot;lead&quot;, cols, sep=&quot;_&quot;) DT[, (anscols) := shift(.SD, 1, 0, &quot;lead&quot;), .SDcols=cols] 例如求某人连续消费时间间隔天数时： DT = data.table(dates =lubridate::ymd(c(20210105,20210115,20210124,20210218,20210424))) DT[,newdate:=shift(dates)] DT #&gt; dates newdate #&gt; 1: 2021-01-05 &lt;NA&gt; #&gt; 2: 2021-01-15 2021-01-05 #&gt; 3: 2021-01-24 2021-01-15 #&gt; 4: 2021-02-18 2021-01-24 #&gt; 5: 2021-04-24 2021-02-18 通过构造新列newdate，然后将两列相减dates-newdate即可得到每次购物间隔天数。 2.4.4 J J 是.(),list()等的别名。SJ是排序连接，CJ是交叉连接。 用法： # DT[J(...)] # J() only for use inside DT[...] # DT[.(...)] # .() only for use inside DT[...] # DT[list(...)] # same; .(), list() and J() are identical SJ(...) # DT[SJ(...)] CJ(..., sorted=TRUE, unique=FALSE) # DT[CJ(...)] CJ 我喜欢用CJ()函数创建笛卡尔积表。例如在商品运营中，时常需要将门店和商品形成笛卡尔积表，相比起dplyr::full_join() ,data.table::merge.data.table(allow.cartesian = TRUE ),CJ更加方便快捷。 # CJ usage examples CJ(c(5, NA, 1), c(1, 3, 2)) # sorted and keyed data.table #&gt; V1 V2 #&gt; 1: NA 1 #&gt; 2: NA 2 #&gt; 3: NA 3 #&gt; 4: 1 1 #&gt; 5: 1 2 #&gt; 6: 1 3 #&gt; 7: 5 1 #&gt; 8: 5 2 #&gt; 9: 5 3 # do.call(CJ, list(c(5, NA, 1), c(1, 3, 2))) # same as above # CJ(c(5, NA, 1), c(1, 3, 2), sorted=FALSE) # same order as input, unkeyed SJ SJ : Sorted Join. The same value as J() but additionally setkey() is called on all columns in the order they were passed to SJ. For efficiency, to invoke a binary merge rather than a repeated binary full search for each row of i. "],["小技巧.html", "2.5 小技巧", " 2.5 小技巧 2.5.1 用{}抑制中间过程输出 默认只返回未命名花括号中定义的最后一个对象。 dt &lt;- data.table(mtcars) dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2)}, by=cyl] #&gt; cyl V1 #&gt; 1: 6 1.19 #&gt; 2: 4 3.83 #&gt; 3: 8 1.79 在我不知道上述技巧之前，我可能的操作是 dt &lt;- data.table(mtcars) res &lt;- dt[,tmp1:=mean(mpg), by=cyl][,.(tmp2=mean(abs(mpg-tmp1))), by=.(cyl)] res[,.(round(tmp2,2)),by=.(cyl)][] #&gt; cyl V1 #&gt; 1: 6 1.19 #&gt; 2: 4 3.83 #&gt; 3: 8 1.79 保留中间变量 dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2); list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] #&gt; cyl tmp2 tmp3 #&gt; 1: 6 1.19 1.19 #&gt; 2: 4 3.83 3.83 #&gt; 3: 8 1.79 1.79 不写分号的方式 dt[,{tmp1=mean(mpg) tmp2=mean(abs(mpg-tmp1)) tmp3=round(tmp2, 2) list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] #&gt; cyl tmp2 tmp3 #&gt; 1: 6 1.19 1.19 #&gt; 2: 4 3.83 3.83 #&gt; 3: 8 1.79 1.79 2.5.2 使用[]打印data.table 在测试代码查看结果时很有用。 df &lt;- head(mtcars) # doesn&#39;t print (df &lt;- head(mtcars)) # does print #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # data.table way of printing after an assignment dt &lt;- data.table(head(mtcars)) # doesn&#39;t print dt[,hp2wt:=hp/wt][] # does print #&gt; mpg cyl disp hp drat wt qsec vs am gear carb hp2wt #&gt; 1: 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 42.0 #&gt; 2: 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 38.3 #&gt; 3: 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 40.1 #&gt; 4: 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 34.2 #&gt; 5: 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 50.9 #&gt; 6: 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 30.3 "],["运用.html", "2.6 运用", " 2.6 运用 2.6.1 自定义函数计算 1.自定义函数处理列 按照自定义函数计算修改单列或多列 # 测试函数 fun &lt;- function(x){ x &lt;- x^2+1 } DT &lt;- data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT[,.(newcol=fun(y)),by=.(x)] #&gt; x newcol #&gt; 1: b 2 #&gt; 2: b 10 #&gt; 3: b 37 #&gt; 4: a 2 #&gt; 5: a 10 #&gt; 6: a 37 #&gt; 7: c 2 #&gt; 8: c 10 #&gt; 9: c 37 #Not run #DT[,lapply(.SD,fun),.SDcols=c(&#39;y&#39;,&#39;a&#39;),by=.(x)] #多列参与计算 # 批量修改列 #Not run # myfun &lt;- function(x){ # return(x) # } # # dt &lt;- dt[,colnames(dt):=lapply(.SD[,1:ncol(dt)],myfun)] #很重要的用法 2.6.2 带汇总的聚合运算 按照by的字段级别汇总. rollup 分组聚合后设置id=TRUE将各个级别的汇总显示清晰,当by字段只有一个是和正常聚合计算没有区别.以下是官方案例. #Usage #rollup(x, j, by, .SDcols, id = FALSE, ...) n = 24L set.seed(25) DT &lt;- data.table( color = sample(c(&quot;green&quot;,&quot;yellow&quot;,&quot;red&quot;), n, TRUE), year = as.Date(sample(paste0(2011:2015,&quot;-01-01&quot;), n, TRUE)), status = as.factor(sample(c(&quot;removed&quot;,&quot;active&quot;,&quot;inactive&quot;,&quot;archived&quot;), n, TRUE)), amount = sample(1:5, n, TRUE), value = sample(c(3, 3.5, 2.5, 2), n, TRUE) ) rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;)) # default id=FALSE #&gt; color year status V1 #&gt; 1: red 2015-01-01 active 3.5 #&gt; 2: green 2015-01-01 inactive 5.5 #&gt; 3: green 2014-01-01 archived 3.5 #&gt; 4: green 2015-01-01 archived 2.0 #&gt; 5: yellow 2014-01-01 active 4.5 #&gt; 6: red 2013-01-01 inactive 2.0 #&gt; 7: green 2011-01-01 active 6.0 #&gt; 8: red 2014-01-01 inactive 2.5 #&gt; 9: green 2011-01-01 archived 2.5 #&gt; 10: yellow 2015-01-01 active 2.0 #&gt; 11: red 2012-01-01 archived 2.0 #&gt; 12: red 2011-01-01 removed 3.5 #&gt; 13: green 2014-01-01 inactive 8.0 #&gt; 14: green 2011-01-01 removed 2.0 #&gt; 15: yellow 2012-01-01 archived 2.5 #&gt; 16: red 2013-01-01 removed 3.5 #&gt; 17: green 2013-01-01 active 3.0 #&gt; 18: green 2014-01-01 removed 2.5 #&gt; 19: red 2011-01-01 archived 3.0 #&gt; 20: red 2015-01-01 &lt;NA&gt; 3.5 #&gt; 21: green 2015-01-01 &lt;NA&gt; 7.5 #&gt; 22: green 2014-01-01 &lt;NA&gt; 14.0 #&gt; 23: yellow 2014-01-01 &lt;NA&gt; 4.5 #&gt; 24: red 2013-01-01 &lt;NA&gt; 5.5 #&gt; 25: green 2011-01-01 &lt;NA&gt; 10.5 #&gt; 26: red 2014-01-01 &lt;NA&gt; 2.5 #&gt; 27: yellow 2015-01-01 &lt;NA&gt; 2.0 #&gt; 28: red 2012-01-01 &lt;NA&gt; 2.0 #&gt; 29: red 2011-01-01 &lt;NA&gt; 6.5 #&gt; 30: yellow 2012-01-01 &lt;NA&gt; 2.5 #&gt; 31: green 2013-01-01 &lt;NA&gt; 3.0 #&gt; 32: red &lt;NA&gt; &lt;NA&gt; 20.0 #&gt; 33: green &lt;NA&gt; &lt;NA&gt; 35.0 #&gt; 34: yellow &lt;NA&gt; &lt;NA&gt; 9.0 #&gt; 35: &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 64.0 #&gt; color year status V1 #rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 个人运用,实际工作中常常需要汇总项,汇总项在Excel透视表中很简单,在R中我之前是构造重复的数据源聚合汇总出现汇总项,极大浪费内存,运算速度减慢. 新方法 rollup set.seed(25) N &lt;- 1000 dt &lt;- data.table(col1=sample(LETTERS[1:5],N,replace = T),col2=sample(letters[1:5],N,replace = T),num=1:N) rollup(dt,j=c(list(sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #&gt; col1 col2 V1 #&gt; 1: E a 19926 #&gt; 2: D a 20966 #&gt; 3: A d 12927 #&gt; 4: A b 20862 #&gt; 5: A c 15331 #&gt; 6: B d 15414 #&gt; 7: C e 20794 #&gt; 8: D e 16110 #&gt; 9: C d 22152 #&gt; 10: A a 18378 #&gt; 11: C c 19474 #&gt; 12: E d 18831 #&gt; 13: B b 19941 #&gt; 14: C a 19652 #&gt; 15: E c 16734 #&gt; 16: E e 24137 #&gt; 17: E b 21988 #&gt; 18: D b 16607 #&gt; 19: B c 25720 #&gt; 20: B a 22109 #&gt; 21: A e 18724 #&gt; 22: C b 24323 #&gt; 23: D d 20508 #&gt; 24: D c 19668 #&gt; 25: B e 29224 #&gt; 26: E &lt;NA&gt; 101616 #&gt; 27: D &lt;NA&gt; 93859 #&gt; 28: A &lt;NA&gt; 86222 #&gt; 29: B &lt;NA&gt; 112408 #&gt; 30: C &lt;NA&gt; 106395 #&gt; 31: &lt;NA&gt; &lt;NA&gt; 500500 #&gt; col1 col2 V1 #同上 添加汇总项名称 total #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #添加id=TRUE参数,多出的grouping 列显示聚合级别 #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;),id=TRUE) 2.groupingsets 按照指定字段聚合.包作者说相同与SQL中的 GROUPING SETS 操作.详情参照postgresql res &lt;- groupingsets(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), sets = list(&quot;color&quot;, c(&quot;year&quot;,&quot;status&quot;), character()), id=TRUE) head(res) #&gt; grouping color year status count amount value #&gt; 1: 3 red &lt;NA&gt; &lt;NA&gt; 7 19 20.0 #&gt; 2: 3 green &lt;NA&gt; &lt;NA&gt; 13 43 35.0 #&gt; 3: 3 yellow &lt;NA&gt; &lt;NA&gt; 4 10 9.0 #&gt; 4: 4 &lt;NA&gt; 2015-01-01 active 2 8 5.5 #&gt; 5: 4 &lt;NA&gt; 2015-01-01 inactive 2 5 5.5 #&gt; 6: 4 &lt;NA&gt; 2014-01-01 archived 1 3 3.5 注意groupingsets函数中sets参数,用list()包裹想要聚合的字段组合,最后还有一个character(),加上该部分相当于全部聚合.当by只有一个字段时,相当于汇总.用法类似sql中“().” 上述语句结果等同于下面sql. select color ,year, status,count(*) count,sum(amount) amount,sum(value) value FROM dbo.DT GROUP BY GROUPING SETS( (color), (year,status), () ---- 类似 character() ) 最后还有cube()函数,可?cube查看用法 2.6.3 行列转变 一列变多行 用tstrsplit()函数实现 n &lt;- 10 dt &lt;- data.table(name=LETTERS[1:n],char=rep(&#39;我-爱-R-语-言&#39;),n) res &lt;- dt[,.(newcol=tstrsplit(char,&#39;-&#39;)),by=.(name)] head(res) #&gt; name newcol #&gt; 1: A 我 #&gt; 2: A 爱 #&gt; 3: A R #&gt; 4: A 语 #&gt; 5: A 言 #&gt; 6: B 我 多行变一列 res[,.(char=paste0(newcol,collapse = &#39;-&#39;)),by=.(name)] #&gt; name char #&gt; 1: A 我-爱-R-语-言 #&gt; 2: B 我-爱-R-语-言 #&gt; 3: C 我-爱-R-语-言 #&gt; 4: D 我-爱-R-语-言 #&gt; 5: E 我-爱-R-语-言 #&gt; 6: F 我-爱-R-语-言 #&gt; 7: G 我-爱-R-语-言 #&gt; 8: H 我-爱-R-语-言 #&gt; 9: I 我-爱-R-语-言 #&gt; 10: J 我-爱-R-语-言 #同上 #res[,.(char=stringr::str_c(newcol,collapse = &#39;-&#39;)),by=.(name)] # A 我-爱-R-语-言 # B 我-爱-R-语-言 # C 我-爱-R-语-言 # D 我-爱-R-语-言 # E 我-爱-R-语-言 # F 我-爱-R-语-言 # G 我-爱-R-语-言 # H 我-爱-R-语-言 # I 我-爱-R-语-言 # J 我-爱-R-语-言 "],["database.html", "3 database", " 3 database 实际工作中，需要从数据库获取数据并清洗，R与数据库有多种交互方式,目前工作中打交道数据库主要是MSSQL,Oracle,mysql等,本文主要从以上数据库介绍记录“R与数据库的连接”。 R中与数据库交互的包主要有DBI,RODBC,RMySQL,ROracle,odbc等包。DBI库在查询或上传工作中效率比RODBC高,特别数据量较大时,上传效率差异巨大,具体差异请点击查看详情。 即使你暂时没有用数据库，也建议你未来用数据库存储数据，尤其是当有一定数据量时;在我最开始接触数据时，数据一般保存在Excel,那时候数据量大概在50万行左右，当公式较多，尤其时需要大批量vlookup时，Excel表格将会很卡顿。 "],["安装数据库.html", "3.1 安装数据库", " 3.1 安装数据库 如果暂时没有数据库使用经验，如果是使用Windows系统，直接去微软官网下载安装数据库即可。如果决定用R做数据分析相关工作，尤其时商业环境下，使用数据库有较强的必要性。安装数据库后，利用数据库做数据分析的练习测试也是不错的体验。另外也可以积累ETL相关经验。 仅简单介绍 MS SQL Server 安装 Win环境下安装 MS下载，选择开发版或精简版(Developer、Express)其中一个版本下载即可。 数据库下载 成功下载后，按照提示一步步确认即可安装成功。另外使用SSMS工具，微软配套的MS SQL SERVER数据库链接工具连接数据库。至于详细的数据库配置尤其是远程连接、账户等信息请自行查阅相关资料。 Linux环境下安装 官网安装指南 以下用于 SQL Server 2019 的命令指向 Ubuntu 20.04 存储库。 如果使用的是 Ubuntu 18.04 或 16.04，请将以下路径更改为 /ubuntu/18.04/ 或 /ubuntu/16.04/，而不是 /ubuntu/20.04/。 # 导入公共存储库的密钥 wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - # 为 SQL Server 2019 注册 Microsoft SQL Server Ubuntu 存储库 sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/20.04/mssql-server-2019.list)&quot; # sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/18.04/mssql-server-2019.list)&quot; # 安装 SQL Server sudo apt-get update sudo apt-get install -y mssql-server # 验证服务是否运行 systemctl status mssql-server --no-pager 至于其他如安装sql server 命令行工具请查阅官网安装。 接下来我们就R语言与数据库的交互包展开介绍。 "],["dbi.html", "3.2 DBI", " 3.2 DBI 3.2.1 安装 install.packages(&#39;DBI&#39;) 3.2.2 连接数据库 连接MS SQL SERVER 通过以下代码即可连接到服务器172.16.88.2(即IP地址)的数据库，成功连接后即可与数据库交互。 library(DBI) con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;SQL Server&quot;, server = &quot;172.16.88.2&quot;,database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) 如果你用windows系统，通过DBI包连接数据库发现乱码时，根据数据库编码指定encoding参数即可，常规在win下连接sqlserver设置encoding = “GBK”。 library(DBI) #根据数据库编码方式指定encoding con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot;, encoding = &quot;GBK&quot; ) # 查看本机可用驱动 如缺少相应驱动则安装，ODBC Driver 17 for SQL Server 就是个人安装的驱动 Drivers_tbl &lt;- odbc::odbcListDrivers() head(Drivers_tbl) 查询数据库编码方式,从而选择连接数据库时相应的编码方式。 con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;ODBC Driver 17 for SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) #查看编码是否是936 代表中文简体 sql &lt;- &quot;SELECT COLLATIONPROPERTY( &#39;chinese_prc_ci_as&#39;, &#39;codepage&#39; )&quot; dbGetQuery(con,sql) # same above # dbExecute(con,sql) # 用完后记得关闭数据库连接 DBI::dbDisconnect(con) 连接mysql MySQL()函数来源RMySQL包，用来创建&lt;MySQLDriver&gt;驱动，以下代码可连接到阿里云的MySQL数据库。 library(RMySQL) con &lt;- dbConnect(MySQL(), dbname = &quot;test&quot;, user = &quot;test_admin&quot;, password = &quot;30HL1234M7#lD6gxjB&quot;, host = &quot;prd-public-mypersonal.mysql.test.zhangjiabei.rds.aliyuncs.com&quot; ) 或者通过本地已安装驱动连接数据库 con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;MySQL ODBC 8.0 Unicode Driver&quot;, Server = &quot;localhost&quot;, UID = &quot;root&quot;, PWD = &quot;123456&quot;, Database = &quot;mysql&quot;, Port = 3306 ) mysql数据库默认端口是3306,访问不通时记得检查3306端口是否开放。 3.2.3 执行sql任务 dbGetQuery()函数处理由DBI包创建的con连接查询任务,dbExecute()执行一些数据库任务 # dbGetQuery 直接查询 res_table &lt;- dbGetQuery(con,&#39;select * from table&#39;) #直接获取sql查询结果 #dbReadTable直接读取 dbReadTable(con,&#39;tbl_name&#39;) #直接读取数据库中某表 # dbSendQuery 执行一个查询任务 res &lt;- dbSendQuery(conn = con,statement = &#39;select * FROM tab&#39;) dbFetch(res) dbClearResult(res) # dbExecute dbExecute(con,&#39;delete from table where num &lt;=1000&#39;) #类似任务 # dbWriteTable() # 上传数据,指定表名,需上传的数据框df,overwrite是否覆盖,append是否可追加 dbWriteTable(conn = con,name = &#39;表名&#39;,value = df,overwrite=TURE,append=FALSE) 3.2.4 函数介绍 查看数据库信息,查看表名,删除表，关闭连接等常用操作. con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;ODBC Driver 17 for SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot;, encoding = &quot;GBK&quot; ) #查看数据版本连接信息 dbGetInfo(con) # 数据库中的全部表名 dbListTables(con) #win下中文表名还是会乱码 # 删除表 dbRemoveTable(con,&#39;tbl_name&#39;) # 关闭连接 dbDisconnect(con) "],["odbc包.html", "3.3 odbc包", " 3.3 odbc包 官方介绍：Connect to ODBC databases (using the DBI interface) 记录到此时，并不时特别清晰odbc与DBI之间的关系。 odbc可以运用于包括(SQL Server, Oracle, MySQL,PostgreSQL,SQLite)等odbc驱动程序于DBI兼容的接口，相比起来DBI包适用范围更广。 1.安装包 #安装包 install.packages(&#39;odbc&#39;) 2.连接数据库 连接数据库需要注意时区、编码，尤其是涉及到时间时时区如果设置有误，可能导致上传数据错误。 当你在Win系统上连接Sql Server时，如果你使用的数据库是中文环境时，最好设置encoding参数。 如果是linux上通过odbc连接SqlServer,一般情况下可以不用设置编码。如果还是乱码，在连接字符中设置字符编码charset=zh_CN.GBK，设置为gbk会报错。 library(odbc) con &lt;- odbc::dbConnect(odbc(), Driver = &quot;SQL Server&quot;, Server = &quot;Vega&quot;, Database = &quot;ghzy&quot;, Trusted_Connection = &quot;True&quot; ) # windows身份认证连接 # con &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;Driver={SQL Server}; # server=Vega;database=ghzy;uid=zhongyf;pwd=Zyf123456;&quot;, timeout = 10) con ## Not run # Win con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;,encoding = &#39;gbk&#39;) #Linux con_dd &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2; database=aojo_dd;uid=wj;pwd=12qw#$ER;charset=zh_CN.GBK&quot;, timeout = 10) 3.查询 dt &lt;- odbc::dbGetQuery(con,&#39;select * from DT&#39;) head(dt) 4.写入数据库 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,overwrite = T ) # 是否覆盖 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,append = T ) # 是否追加 "],["rodbc包.html", "3.4 RODBC包", " 3.4 RODBC包 RODBC包是R语言对ODBC数据库接口,可以连接所有的ODBC数据库. 1.安装包 install.packages(&#39;RODBC&#39;) 2.SQL SERVER 数据库举例 library(RODBC) con &lt;- odbcDriverConnect(&quot;driver={SQL Server};server=192.168.2.62;database=dbname;uid=zhongyf;pwd=Zyf123456&quot;) con RODBC::sqlQuery(con,&#39;select * from test&#39;) 在WINDOWS机器上,需要知道本机是否有相应数据库的驱动程序. 查看本机上可用驱动 odbc::odbcListDrivers() 怎样安装驱动 请参照驱动安装 ODBC for sql server driver 下载地址地址 3.数据库字符串 请参照数据库连接字符串 #ODBC Driver 17 for SQL Server cn &lt;- odbcDriverConnect(&quot;Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=name;UID=username;PWD=123456;&quot;) #server 数据库 UID 数据库账户 PWD 数据库账户密码 sql server 请参照sql server连接字符串 "],["roracle包.html", "3.5 ROracle包", " 3.5 ROracle包 在第一次安装这个包时遇到了很多困难，首先需要安装oracle客户端，其次配置好环境变量，最后安装包。R与Oracle的连接需要安装Oracle Instant Client， 安装客户端 安装oracle客户端，根据电脑的位数选择相应的32位或64位，根据要连接数据库版本，可以去官网自行下载，本机需要下载的客户端地址 配置环境变量 根据自己所使用的系统，配置环境变量 OCI_INC=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\oci\\include&#39; OCI_LIB64=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\BIN&#39; linxu上安装Roracle包，可以参考我的 微信公众号：宇飞的世界 公众号文章连接 安装包 安装Roracle包需要配置相应版本的Rtools并添加到环境变量，另外配置两个oracle的环境变量。代码中有注释,按照自己安装版本路径修改。 由于ROracle依赖于Oracle Instant Client,安装之前一定要先安装好客户端。 install.packages(&#39;ROracle&#39;) 连接数据库 Roracle可以通过DBI包链接，除了驱动和连接字符串有差异，其他部分一样。 library(ROracle) drv &lt;-dbDriver(&quot;Oracle&quot;) connect.string &lt;- &#39;(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.16.88.129)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = bidev) ))&#39; #连接字符串 con &lt;- dbConnect(drv,username = &quot;query&quot;, password = &quot;query&quot;,dbname = connect.string) 乱码问题 如果连接oracle数据库，中文乱码设置以下环境变量即可，或者在启动文件配置该环境变量。 linux下可以在文件Renviron中添加，记得引号，路径为[/opt/R/4.0.2/lib/R/etc/Renviron] # 查询数据库编码 select userenv(&#39;language&#39;) from dual Sys.setenv(NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;) "],["rmysql包.html", "3.6 RMySQL包", " 3.6 RMySQL包 RMySQL包的主要作用可以提供驱动与mysql数据库进行连接，在本机未安装mysql的驱动的情况下.该包正在逐渐被淘汰，可以使用RMariaDB包替换。 3.6.1 安装 Win系统下直接安装即可，其它平台下需提前安装依赖环境。 #On recent Debian or Ubuntu install libmariadbclient-dev sudo apt-get install -y libmariadbclient-dev #On Fedora, CentOS or RHEL we need mariadb-devel: sudo yum install mariadb-devel #On OS-X use mariadb-connector-c from Homebrew: brew install mariadb-connector-c install.packages(&#39;RMySQL&#39;) 3.6.2 连接使用 连接数据库，与上述连接方式基本一致。 library(RMySQL) con &lt;- RMySQL::dbConnect(drv = RMySQL::MySQL(),host=&#39;localhost&#39;,dbname=&quot;mysql&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) RMariaDB包与RMySQL包用法基本一致，在连接时注意驱动的选择即可。 install.packages(&#39;RMariaDB&#39;) library(RMariaDB) con &lt;- RMySQL::dbConnect(drv = RMariaDB::MariaDB() ,host=&#39;localhost&#39;,dbname=&quot;dbtest&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) "],["常见问题.html", "3.7 常见问题", " 3.7 常见问题 在使用R包连接数据库时有些常见的问题，整理如下： 3.7.1 乱码问题 R中中文乱码问题一直都很麻烦，并且常常遇见，尤其是使用win系统时。 MS SQL SERVER 乱码 修改encoding参数，在win系统下，可以考虑使用RODBC包连接查询数据库，因为该包将自动转换编码，不会存在乱码问题。但是上传效率奇慢，为了减少包依赖保持代码一致性使用odbc连接数据库时遇到乱码，在连接数据库时设定encoding即可。 # win con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ SQLServer};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;gbk&quot; ) # linux con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;utf8&quot; ) MySQL乱码 1.代码修改 #执行查询语句前执行 dbSendQuery(con,&#39;SET NAMES gbk&#39;) 2.ODBC配置 如果是通过ODBC数据源连接,可通过配置需改,如下所示： ODBC配置截图 3.7.2 无法连接问题 首先需要装mysql的驱动,确保RMySQL成功安装 如果是测试自己安装的mysql,可以先用Navicat连接,如果出现Authentication plugin ‘caching_sha2_password’ cannot be loaded的错误。 可能是由于 mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password,通过修改加密规则可解决无法连接问题。 --cmd 登录本地数据 mysql -u root -p --输入密码 password: --执行命令 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 ---ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; 看账号权限注意与上面的区别 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 3.7.3 远程连接 当你需要远程连接时，需要确保数据库的远程连接已经开启。在数据库中开启某账户远程连接权限,在公司的话，数据库连接问题咨询公司的IT人员。自己个人电脑上安装的MS SQL SERVER数据库需要自行开启远程连接。 另外如果是云服务器上搭建的数据库,需要开启数据库端口，如Mysql默认端口3306;如果是阿里云的Rds数据库,找DBA管理员要数据库地址以及端口信息。 "],["dbplyr.html", "3.8 dbplyr", " 3.8 dbplyr dbplyr将dplyr包的函数转化为SQL语句去服务器获取数据；在数据量较大、计算较多时，可以将远程连接数据库中的表当作内存中的数据框使用，当本机内存不够大时，这样做的好处不言而喻。 至于为什么使用dbplyr而不是直接编写SQL,因为： dbplyr写起来简洁高效，基本跟用dplyr没有差别 能利用数据库所在服务器的算力，配合上并行计算，在处理大量数据时，大大加快速度。 不同数据库的语法存在差异，当源数据存在不同数据库时，用R的dbplyr包清洗数据时能加快效率 通过dplyr动词方便实现复杂的逻辑，当过程越多越复杂时dbplyr的优势越明显，不用一层层嵌套语句。 3.8.1 基础用法 library(dplyr) library(dbplyr) mf &lt;- memdb_frame(x = 1, y = 2) mf %&gt;% mutate( a = y * x, b = a ^ 2, ) %&gt;% show_query() library(dplyr) #connect database con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = &quot;:memory:&quot;) # 上传数据 copy_to(con, nycflights13::flights, &quot;flights&quot;, temporary = FALSE, indexes = list( c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), &quot;carrier&quot;, &quot;tailnum&quot;, &quot;dest&quot; ) ) # 查看库中全部表名 #dbListTables(con) #tbl()引用表flights flights_db &lt;- tbl(con, &quot;flights&quot;) flights_db # 开始查询 flights_db %&gt;% select(year:day, dep_delay, arr_delay) flights_db %&gt;% filter(dep_delay &gt; 240) flights_db %&gt;% group_by(dest) %&gt;% summarise(delay = mean(dep_time)) 部分简单不复杂的sql语句可以用dplyr的语法代替. tailnum_delay_db &lt;- flights_db %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay,na.rm = T), n = n() ) %&gt;% arrange(desc(delay)) %&gt;% filter(n &gt; 100) tailnum_delay_db tailnum_delay_db %&gt;% show_query() tailnum_delay &lt;- tailnum_delay_db %&gt;% collect() #把数据从数据库加载到R内存中 3.8.2 无法正确转化 在使用过程中发现无法识别lubridate包的函数，但是dbplyr对于不认识的函数都将保留。 利用这个特性，可以使用数据库中原生的相关函数：如下所示，在Oracle中to_date函数 以下的自定义函数可以实现按照想要group_by的字段汇总金额、数量、吊牌额、折扣率等,其中关于时间周期的筛选就利用了该特性。 date #个人写的争对目前公司数仓写的包中获取销售数据的一段代码 get_sales_data &lt;- function(con,...,start_date,end_date,brand_name,channel_type = NULL ,area_name = NULL,boss_name = NULL,category_name = NULL,shop_no = NULL){ store_table &lt;- store(con,brand_name = brand_name,channel_type = channel_type ,area_name = area_name,boss_name = boss_name,shop_no = shop_no) #门店信息 sku_table &lt;- sku(con,category_name = category_name ) #商品信息 tbl(con, in_schema(&quot;DW&quot;, &quot;DW_SALE_SHOP_F&quot;)) %&gt;% #DW层 select(BILL_DATE1, SKU_NO, SHOP_NO, BILL_QTY, BILL_MONEY2, PRICE) %&gt;% filter(between( BILL_DATE1, to_date(start_date, &quot;yyyy-mm-dd&quot;), to_date(end_date, &quot;yyyy-mm-dd&quot;) )) %&gt;% mutate(年 = year(BILL_DATE1), 月 = month(BILL_DATE1)) %&gt;% inner_join(store_table) %&gt;% inner_join(sku_table) %&gt;% group_by(...) %&gt;% summarise( 金额 = sum(BILL_MONEY2, na.rm = TRUE), 数量 = sum(BILL_QTY, na.rm = TRUE), 吊牌金额 = sum(BILL_QTY * PRICE, na.rm = TRUE)) %&gt;% collect() %&gt;% mutate(折扣率:= 金额 / 吊牌金额) %&gt;% arrange(...) # return(res) } like mf %&gt;% filter(x %LIKE% &quot;%foo%&quot;) %&gt;% show_query() 特殊用法 特殊情况可以使用sql()函数 mf %&gt;% transmute(factorial = sql(&quot;x!&quot;)) %&gt;% show_query() "],["参考资料.html", "3.9 参考资料", " 3.9 参考资料 DBI包资料https://dbi.r-dbi.org/reference/ dbplyr包资料https://dbplyr.tidyverse.org/ rstudio关于数据库介绍 https://db.rstudio.com/databases 数据库连接字符串介绍 https://www.connectionstrings.com/ 个人博客关于Roracle的安装介绍 http://www.zhongyufei.com/2020/07/25/roracle-install/ https://www.r-consortium.org/blog/2017/05/15/improving-dbi-a-retrospect "],["stringr.html", "4 stringr", " 4 stringr 实际工作中,经常需要处理字符串.R包stringr处理字符相对简单,本章记录工作中常用的字符处理方式方法。 本文部分案例照搬R for Data Science的字符部分。 Excle中自带的字符函数如: left,len,mid,find,Proper,rept,trim,upper,substitute,concatenate,以及Excle2019新出的concat,TEXTJOIN等函数，新出的textjoin函数我个人比较喜欢用。 学习的时候可以先用stringr包实现以上相对应功能。 https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html "],["基础.html", "4.1 基础", " 4.1 基础 字符串处理的难点，个人觉得在于【正则表达式】的掌握程度，但是需要用到正则表达式时都是比较复杂的字符处理工作，在实际商业文本数据中 运用较多。对大部分常规商业数据分析工作者的面对的表格数据而言，字符处理可能仅仅只是合并、剔除、删除空格、倒叙等基础操作。 4.1.1 单双引号 R语言中字符串输入时，可以使用单引号，也可以使用双引号。 单双引号用法和意义没有差别 R中推荐使用双引号分隔符，打印、显示时都是用双引号 单引号字符串通常用在字符串内包含双引号时，如用R执行sql字符串代码时 4.1.2 转义 要在字符串中包含单引号或双引号，可以使用 转义它，即遇到特殊符号时需要转义。 #install.packages(&#39;stringr&#39;) library(stringr) char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; #字符串建议用双引号包裹,单引号也可以 char 打印会显示转义符。要查看字符串的原始内容,可使用writeLines()或cat() x &lt;- c(&quot;\\&quot;&quot;, &quot;\\\\&quot;) x #&gt; [1] &quot;\\&quot;&quot; &quot;\\\\&quot; writeLines(x) cat(char) #&gt; &quot; #&gt; \\ 在正则表达式中 有特殊含义,有时需要两个 ，多体会下面这段，代码实现移除“||”的功能。 str_remove(string = &#39;a||b&#39;,pattern = &quot;\\\\|\\\\|&quot;) 另外常见的\\n, \\t需要被转义处理,在字符清洗,如小说语义分析,网页爬虫后整理等数据清洗过程中经常用到. 4.1.3 字符串长度 char &lt;- &quot;我是R语言学习者&quot; str_length(char) # 向量化 str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA)) 4.1.4 连接字符串 R中字符串不像python中可以用加号连接字符串,如下所示: R 版本 #base R paste0(&#39;a&#39;,&#39;b&#39;) #stringr str_c(&quot;a&quot;,&quot;b&quot;) str_c(&quot;a&quot;, &quot;b&quot;, sep = &quot;, &quot;) #sep 参数控制分隔符 Python 版本 &#39;a&#39; + &#39;b&#39; 多个字符串合并为一个字符,stringr中的函数都是向量化的，合并一个和多个字符都是同样道理。 #base R paste0(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #stringr str_c(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #collapse 参数控制 实际运用案例 合并 library(data.table) dt &lt;- data.table(col=rep(&#39;a&#39;,10),letters=letters[1:10]) dt[,newcol:=str_c(letters,collapse = &#39;|&#39;),by=.(col)][] 拆解 #工作中路径需要拆解 类似商品品类路径 进口水果-热带水果-生鲜,用户行为路径等 dt &lt;- data.table(col=&#39;a&#39;,letters=str_c(letters[1:10],collapse = &#39;|&#39;)) my_str_split &lt;- function(x){ str_split(x,pattern = &quot;\\\\|&quot;) %&gt;% unlist() #str_split 拆解出来是列表 需要向量化 } dt[,list(newcol=my_str_split(letters)),by=.(col)] 4.1.5 R4.0后新特性 新特性 char &lt;- r&quot;(\\\\a\\ab\\d\\e\\f)&quot; #windows下路径好用,不用转义路径复制和直接可用 char char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; cat(char) char &lt;- r&quot;(我是一名&#39;R语言&#39;学习者)&quot; cat(char) "],["常用函数-1.html", "4.2 常用函数", " 4.2 常用函数 4.2.1 截取 与Excle中left,mid,right函数功能类似 str_sub() 函数 三个参数: string:需要被截取的字符串 start: 默认1L,即从最开始截取 end:默认-1L,即截取到最后 #注意end 3 和 -3的区别 str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = 3) str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = -3) 4.2.2 匹配 查看函数帮助文档,str_match()按照指定pattern(正则表达式)查找字符.重点困难点正则表达式的编写. ?str_match() ?str_match_all() ?str_extract() ?str_extract_all() str_extract()函数返回向量,str_match()函数返回矩阵. #原文来源烽火戏诸侯的&lt;剑来&gt; strings &lt;- c(&#39;陈平安放下新折的那根桃枝,吹灭蜡烛,走出屋子后,坐在台阶上,仰头望去,星空璀璨.&#39;) str_extract(strings,&#39;陈平安&#39;) str_match(strings,&#39;陈平安&#39;) 匹配中文 匹配中文的正则表达式\\[\\u4e00-\\u9fa5\\] str_extract_all(strings,&#39;[\\u4e00-\\u9fa5]&#39;) #返回list 匹配数字或英文 查找数字的正则表达式[0-9];查找英文的正则表达式:[a-zA-Z] strings &lt;- c(&#39;00123545&#39;,&#39;LOL league of legends&#39;) str_extract_all(strings,&#39;[0-9]&#39;) str_extract_all(strings,&#39;[a-zA-Z]&#39;) 4.2.3 添加字符 str_pad() 函数向字符串添加字符 像工作中处理月份的时候,1,2,3,4,5,6,7,8,9,10,11,12变成01,02,03,04,05,06,07,08,09,10,11,12.按照日期时间输出文件名称,如下所示: str_pad(string = 1:12,width = 2,side = &#39;left&#39;,pad = &#39;0&#39;) 4.2.4 去除空格 与excel中trim函数功能类似，剔除字符中的空格，但是不可以剔除字符中的空格 # side 可选 both left right str_trim(&#39; ab af &#39;,side = &#39;both&#39;) 4.2.5 分割字符 str_split()处理后的结果是列表 # 得到列表,需要向量化 str_split(&quot;a,b,d,e&quot;,pattern = &#39;,&#39;) str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% unlist() # same above #str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% purrr::as_vector() 当待处理的字符串是字符串向量时，得到的列表长度与向量长度一致 fruits &lt;- c( &quot;apples and oranges and pears and bananas&quot;, &quot;pineapples and mangos and guavas&quot; ) str_split(fruits, &quot; and &quot;) 4.2.6 替换字符 str_replace()，str_replace_all()函数用来替换字符 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_replace(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) str_replace_all(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) 4.2.7 移除字符 str_remove(),str_remove_all()移除字符。本人常用该函数剔除文本中的空格。 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_remove(fruits, &quot;[aeiou]&quot;) str_remove_all(fruits, &quot;[aeiou]&quot;) 移除文本中空格 str_replace_all(string = &#39; d a b &#39;,pattern = &#39; &#39;,replacement = &#39;&#39;) 4.2.8 字符排序 numeric参数决定是否按照数字排序。 str_order(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_sort(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_order(letters) str_sort(letters) numeric参数 x &lt;- c(&quot;100a10&quot;, &quot;100a5&quot;, &quot;2b&quot;, &quot;2a&quot;) str_sort(x) str_sort(x, numeric = TRUE) 4.2.9 提取单词 从句子中提取单词。 参数 word(string, start = 1L, end = start, sep = fixed(&quot; &quot;)) 案例 sentences &lt;- c(&quot;Jane saw a cat&quot;, &quot;Jane sat down&quot;) word(sentences, 2, -1) word(sentences[1], 1:3, -1) 指定分隔符 # Can define words by other separators str &lt;- &#39;abc.def..123.4568.999&#39; word(str, 1, sep = fixed(&#39;..&#39;)) word(str, 2, sep = fixed(&#39;..&#39;)) 4.2.10 其他函数 str_subset() str_which() 匹配字符串本身行筛选时候能用 fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_subset(fruit, &quot;a&quot;) str_which(fruit, &quot;a&quot;) # 匹配字符首次出现的位置 #str_which 是which(str_detect(x,pattern))的包装 #str_which() #str_subset是对x[str_detect(x,pattern)]的包装 #str_subset() #筛选出字母行 set.seed(24) dt &lt;- data.table::data.table(col=sample(c(letters,1:10),100,replace = T)) head(dt[str_which(col,pattern = &#39;[a-z]&#39;)]) str_dup() 复制字符串 fruit &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_dup(fruit, 2) str_dup(fruit, 1:3) str_c(&quot;ba&quot;, str_dup(&quot;na&quot;, 0:5)) str_starts() str_ends() 从str_detect()包装得到. str_starts(&#39;abd&#39;,&#39;a&#39;) str_detect(&#39;abd&#39;,&#39;^a&#39;) str_ends(&#39;abd&#39;,&#39;d&#39;) str_detect(&#39;abd&#39;,&#39;a$&#39;) 大小写转换 dog &lt;- &quot;The quick brown dog&quot; str_to_upper(dog) str_to_lower(dog) str_to_title(dog) str_to_sentence(&quot;the quick brown dog&quot;) "],["r实现excel字符函数.html", "4.3 R实现Excel字符函数", " 4.3 R实现Excel字符函数 以下函数实现，仅仅只是从stringr包的函数上修改，并且没有完善，没有报错提示等的简陋版本，如果感兴趣的可以尝试利用Rcpp写出高性能版本的同功能函数。 left r_left &lt;- function(str,num){ str_sub(string = str,start = 1,end = num) } r_left(&#39;我是R语言学习者&#39;,3) right r_right &lt;- function(str,num){ str_sub(string = str,start = str_length(str) - num + 1) } r_right(&#39;我是R语言学习者&#39;,3) mid r_mid &lt;- function(str,start,num){ str_sub(string = str,start = start,end = start + num -1) } r_mid(&#39;我是R语言学习者&#39;,3,3) 其余函数可以自行实现 "],["lubridate.html", "5 lubridate", " 5 lubridate 数据清洗中,经常涉及到时间处理。个人R中用来处理时间的包是lubridate，本文将介绍该包中部分函数用法。 该包能灵活处理日期和时间数据，但是日期处理是比较复杂的，就拿简单的同环比来说，如果是想利用基础函数自定义函数来处理同环比，你遇到的第一个问题就是每个月的天数不一样，第二个问题就是闰年问题导致年天数不一致。 经过一番折腾，完全放弃了自己处理时间日期数据的想法，投入了lubridate包的怀抱。由于能力有限以及处理过的日期数据有限，并不能面面俱到，更加深入的问题，可自行去了解该包的文档，甚至去通读源码。 在Excel的Power Pivot中有一组DAX智能函数，如： 基础函数 date,datediff,datevalue,edate,eomonth,quarter,TIMEVALUE等等 智能函数 dateadd,DATESBETWEEN,DATESMTD,TOTALMTD,TOTALQTD,TOTALYTD等等 Excel中因为有了以上时间智能函数，用度量值在透视表中计算同环比变得简单 熟悉DAX时间智能函数，在R中设计相关功能或实现时可以借鉴参考DAX函数的思路。比如在R中写自动化报表时，涉及到同环比计算时就可以按照这个模式设计。 注意事项： R中日期起始时间是1970-01-01,Excel中是1900-01-01,转化成数字两者相差25568。在用R读取Excel文件时，设计到日期数字转化成日期时需要注意其中差异。 R中日期 : 2021-05-13 转化成数字: 18760, Excel 中 2021-05-13转化成数字:44328,两者相差25568. "],["基础用法-1.html", "5.1 基础用法", " 5.1 基础用法 获取当前日期、时间；拆解时间日期中的年、月、日、星期、计算年月天数，记录时刻等常用的时间日期功能，lubridate包中都有相对应的功能函数。 5.1.1 安装包 install.packages(&quot;tidyverse&quot;) # 仅仅只安装lubridate install.packages(&#39;lubridate&#39;) # 开发版 devtools::install_github(&quot;tidyverse/lubridate&quot;) # 加载包 library(lubridate,warn.conflicts = FALSE) 5.1.2 获取当前时间日期 now函数 now(tzone = &#39;Asia/Shanghai&#39;) #base R base::Sys.time() 输出结果中，CST是指中国标准时间，即时区概念。 查看时区，时区和所用系统设置相关 Sys.timezone() # windows 系统默认的时区 中国台北 # linux 上是&quot;Asia/Shanghai&quot; today函数 today(tzone = &#39;Asia/Shanghai&#39;) #base R base::Sys.Date() 5.1.3 获取日期时间中的组成部分 #获取年 year(now()) #获取月 month(now()) # 当前时间所在年份天数 yday(now()) # 当前时间所在月天数 mday(now()) # 周几 wday(now(),label = TRUE,week_start = 1) # 所在时刻 hour(now()) # 所在时刻 minute(now()) # 所在时刻 second(now()) "],["处理时区.html", "5.2 处理时区", " 5.2 处理时区 如果生成数据时区与本地一致时，没必要处理，但是当数据是跨时区的或者不同生产系统的时区不一致，我们将要处理统一。 用with_tz()，force_tz()处理时区问题 time &lt;- ymd_hms(&quot;2020-12-13 15:30:30&quot;) time # Changes printing with_tz(time, &quot;Asia/Shanghai&quot;) # Changes time force_tz(time, &quot;Asia/Shanghai&quot;) "],["解析日期和时间.html", "5.3 解析日期和时间", " 5.3 解析日期和时间 从时间表达式中提取想要时间。存储的数据源中日期列可能是各种的字符形式，需要转换为时间格式方便进行日期计算。商业环境中的数据是混乱的，生成库可能是不同的系统，导致时间日期格式混乱，如果没有BI，我们就需要自己清洗数据，将不同形式的日期格式转化为标准格式。 # 整数和字符都可以 ymd(20200604) ymd(&#39;20200604&#39;) mdy(06042020) dmy(04062020) 遇到unix 时间戳 可以用 .POSIXct()函数转化. unix在线转换 .POSIXct(1591709615) ymd_hms(.POSIXct(1591709615)) unix时间戳里面有时区的概念，在用mysql，RDS数据库时需要注意时区，特别是需要提取时间点时。lubridate包里面tz参数指定时区 ymd_hms(.POSIXct(1591709615),tz = &#39;asia/shanghai&#39;) 从下面三个时间观察时区，CST时间:中央标准时间;UTC时间:世界协调时间(UTC)是世界上不同国家用来调节时钟和时间的主要时间标准。 如:当UTC时间为0点时，中国CST时间为8点，因为零时区和中国北京时区相差8个时区. https://home.kpn.nl/vanadovv/time/TZworld.html#asi lubridate::now() as_datetime(now()) #默认是UTC as_datetime(now(),tz = &#39;asia/shanghai&#39;) "],["构造日期或时间.html", "5.4 构造日期或时间", " 5.4 构造日期或时间 使用数值直接创建日期时间make_date和make_datetime函数默认时区为“UTC” make_date(year = year(today()), month = month(today()), day = day(today()), tz = &quot;asia/shanghai&quot;) make_datetime( year = year(today()), month = month(today()), day = day(today()), hour = hour(now()), min = minute(now()), sec = second(now()), tz = &quot;asia/shanghai&quot; ) 使用数值或字符直接创建日期时间 as_datetime(&#39;2020-01-09 09:15:40&#39;,tz=&#39;asia/shanghai&#39;) as_date(&#39;2020-01-09&#39;) #ymd格式 # same above #as_date(&#39;2020/01/09&#39;) #as_date(&#39;20200109&#39;) "],["时间间隔.html", "5.5 时间间隔", " 5.5 时间间隔 我们可以用lubridate将时间间隔保存为interveal类对象 arrive &lt;- ymd_hms(&quot;2020-12-04 12:00:00&quot;, tz = &quot;asia/shanghai&quot;) arrive leave &lt;- ymd_hms(&quot;2020-12-10 14:00:00&quot;, tz = &quot;asia/shanghai&quot;) leave res &lt;- interval(arrive, leave) # same above res &lt;- arrive %--% leave 两个时间间隔是否重复 jsm &lt;- interval(ymd(20201020, tz = &quot;asia/shanghai&quot;), ymd(20201231, tz = &quot;asia/shanghai&quot;)) jsm int_overlaps(jsm, res) 更多详细用法?interveal interval(start = NULL, end = NULL, tzone = tz(start)) start %--% end is.interval(x) int_start(int) int_start(int) &lt;- value int_end(int) int_end(int) &lt;- value int_length(int) int_flip(int) int_shift(int, by) int_overlaps(int1, int2) int_standardize(int) int_aligns(int1, int2) int_diff(times) "],["时间日期计算.html", "5.6 时间日期计算", " 5.6 时间日期计算 时间日期计算以number line为依据计算。原文是Because the timeline is not as reliable as the number line。 minutes(2) dminutes(2) dhours(2) 注意闰年时计算年份的差异 leap_year(2019) ymd(20190101) + dyears(1) ymd(20190101) + years(1) leap_year(2020) ymd(20200101) + dyears(1) # 注意查看闰年时的差异 ymd(20200101) + years(1) lubridate中的函数都已向量化 meeting &lt;- ymd_hms(&quot;2020-12-01 09:00:00&quot;, tz = &quot;asia/shanghai&quot;) meeting &lt;- meeting + weeks(0:5) meeting %within% jsm 除法计算 res / ddays(1) res / dminutes(1) res %/% months(1) res %% months(1) as.period用法 as.period(res %% months(1)) 对于日期而言，因为月天数、年天数不一致，导致不能直接加减天数，如下： jan31 &lt;- ymd(&quot;2020-01-31&quot;) jan31 + months(0:11) lubridate中不存在的日期返回NA 解决方案是：%m+%或%m-% jan31 %m+% months(0:11) jan31 %m-% months(0:11) "],["案例.html", "5.7 案例", " 5.7 案例 5.7.1 年同环比 floor_date()函数根据要求周期回滚日期， floor_date(today(),unit = &#39;year&#39;) floor_date(today(),unit = &#39;month&#39;) #可与rollback函数达到同样效果 floor_date(today(),unit = &#39;week&#39;) 计算年同比 n &lt;- 1 date &lt;- today() # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) current_start_date date # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_start_date last_end_date &lt;- date %m-% years(n) last_end_date 月同比类似，回滚时间周期调整为“month”即可 计算月环比 %m+%或%m-%可以很好解决月份天数不一的问题 as_date(&#39;2020-03-30&#39;) %m-% months(1) today() today() %m-% months(1) 得到了两对时间周期，然后在订单数据或者其他中筛选即可获得同比维度数据 模拟计算 # 构造数据 bill_date &lt;- as_date((as_date(&#39;2019-01-01&#39;):as_date(&#39;2020-12-01&#39;))) area &lt;- sample(c(&#39;华东&#39;,&#39;华西&#39;,&#39;华南&#39;,&#39;华北&#39;),size = length(bill_date),replace = TRUE) dt &lt;- tibble::tibble(bill_date = bill_date ,money = sample(80:150,size = length(bill_date),replace = TRUE),area = area) head(dt) library(dplyr,warn.conflicts = FALSE) y_to_y &lt;- function(.dt,date,n = 1,...){ date &lt;- ymd(date) if(is.na(date)){ stop(&#39;请输入正确日期格式，如20200101&#39;) } # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_end_date &lt;- date %m-% years(n) .dt %&gt;% mutate( 类型 = case_when(between(bill_date,current_start_date,date) ~ &quot;当前&quot;, between(bill_date,last_start_date,last_end_date) ~ &quot;同期&quot;, TRUE ~ &quot;其他&quot;)) %&gt;% filter(类型 != &quot;其他&quot;) %&gt;% group_by(...) %&gt;% summarise(金额 = sum(money,na.rm = TRUE)) %&gt;% ungroup() #%&gt;% pivot_wider(names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) } y_to_y(dt,date = &#39;20200101&#39;,n = 1,area,类型) 5.7.2 清洗不同类型日期格式 如将c('2001/2/13 10:33','1/24/13 11:16')转换为相同格式的日期格式; 通过一个简单自定义函数解决，本质是区分不同类型日期后采用不同函数去解析日期格式 library(lubridate) library(tidyverse) date1 &lt;- c(&#39;2001/2/13 10:33&#39;,&#39;1/24/13 11:16&#39;) myfun &lt;- function(x){ n_length &lt;- length(x) res &lt;- vector(length = n_length) for(i in 1:n_length){ n &lt;- strsplit(x[i],&#39;/&#39;) %&gt;% `[[`(1) %&gt;% `[[`(1) if(str_length(n)==4){ res[i] &lt;- ymd_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } else { res[i] &lt;- mdy_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } } as_datetime(res,tz = &#39;Asia/Shanghai&#39;) } myfun(date1) 5.7.3 扫码后中奖时间匹配 假定有两张表，一张是用户扫码表，一张是用户中奖表，如下所示： 数据源视图 由于中奖时间和扫码时间不完全一致，导致没办法直接通过客户ID以及时间关联匹配找到客户每次中奖时的积分码,现在要求找到客户每次中奖时对应的积分码？ 思路：通过观察数据，发现扫码后如果中奖，一般几秒钟内会有中奖记录，那我们就可以通过“每次中奖时间最近的一次扫码时间的积分码”就是该次中奖对应的积分码解决问题。这样我们通过简单编写自定义函数即可获取答案，即一个时间点从一串时间中找到离自己最近时间点。 testfun &lt;- function(x,y){ result &lt;- data.frame() #应采用列表存储结果向量化 n &lt;- length(x) for( i in 1:n){ res &lt;- x[i]-y res &lt;- abs(res) %&gt;% which.min() #本处不对，应该判断res大于0的部分中谁最小 kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result &lt;- rbind(kong,result) } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 改进代码 testfun &lt;- function(x,y){ n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 理论上不同用户可以在同一时间扫码且同时中奖，那上面的代码即不可以获取正确答案。但是我们只要通过按照用户ID切割数据框后稍微改造上面的自定义函数即可。 testfun &lt;- function(dt){ x &lt;- dt$中奖时间 y &lt;- dt$扫的时间 n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } result &lt;- dplyr::bind_rows(result) return(result) } dtlist &lt;- split(alldt,&#39;客户ID&#39;) purrr::map_dfr(dtlist,testfun) 虽然可以通过寻找最近一次的扫码记录判断积分码，但是因为网络延迟或中途接电话等各种原因导致扫码时间和中奖时间相差并不是几秒，导致情景复杂，那我们就应该在设计系统时就设计好锁定对应关系，从根本上解决问题。 "],["资料.html", "5.8 资料", " 5.8 资料 https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html https://www.rdocumentation.org/packages/lubridate/versions/1.7.8 pdf 下载 https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf Excle中dax时间智能函数 https://docs.microsoft.com/en-us/dax/time-intelligence-functions-dax "],["forcats.html", "6 forcats", " 6 forcats 我在实际工作中因子数据类型使用较少,forcats软件包用来处理因子,该软件包是tidyverse的一部分. 因子是用于对数据进行分类的R的一种数据类型. 它们可以存储字符串和整数.它们在具有有限数量的唯一值的列中很有用. 像“男性”，“女性”和True，False等。它们在统计建模的数据分析中很有用. 因子变量会占用更小空间,R4.0改变了字符默认为因子的方式.想了解更多请参考 https://r4ds.had.co.nz/factors.html object.size(rep(letters,100000)) object.size(rep(forcats::as_factor(letters),100000)) "],["创建因子.html", "6.1 创建因子", " 6.1 创建因子 实际工作中,可能各个事业部或部门之间没有实际顺序,但是在数据处理过程中需要指定顺序可以用因子. library(forcats) vec1 &lt;- c(&#39;部门a&#39;,&#39;部门b&#39;,&#39;部门d&#39;,&#39;部门f&#39;) sort(vec1) vec2 &lt;- as_factor(c(&#39;部门f&#39;,&#39;部门d&#39;,&#39;部门a&#39;,&#39;部门b&#39;)) sort(vec2) 如上所示:实际工作中可以通过指定因子水平从而达到排序效果,在可视化中也可以运用,像指定X轴的顺序. "],["tidyr.html", "7 tidyr", " 7 tidyr 在实际工作中，我们数据分析工作者80%的时间可能贡献在数据准备和数据清晰上。另外发现新问题时，可能又要重复数据准备、数据清晰的过程。如果采用不能完全复现的方式做数据准备清洗的工作，那将是一场灾难。 数据工作者最常用的工具可能是Excel,但是Excel并不具备很强的数据清洗能力，即使Excel有POwer query 、Dax等两大利器。工作中，实际面临原始的数据是脏乱无须的，业务系统仅仅只是记录了历史过程数据。当我们需要分析某一现象时，需要按照自己的需求重新采集数据，清洗为“标准”的数据格式。 标准数据：达到工作需求的数据，可以直接用Excel,power bi ，tableau等BI工具直接使用的程度。 R中的tidyverse系列构建了一种一致的数据结构，当我们用tidyverse软件包提供的“数据整洁工具”整洁数据时，我们将花费更少的时间将数据从一种形式迁移到另外一种形式。从而，我们拥有更多的时间专注在具体的业务问题上。 "],["安装-2.html", "7.1 安装", " 7.1 安装 本章节，我们重点关注tidyr包，这个软件包提供了许多的功能函数整理混乱的数据。tidyr是tidyverse的核心成员包 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;tidyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/tidyr&quot;) # CTEST CODE "],["主要功能.html", "7.2 主要功能", " 7.2 主要功能 整洁的数据表现为： 每个变量是单独的一列 每一个观察的值都在自己的行 每一个值都是独立的单元格 大部分的数据集都是用行和列构成的data.frame。用Excel的单元格来表示，即每列代表不同意义的字段，每行是某个情形下的一系列字段；单元格则是独立的值,属于某个变量的观察值，这样构建的二维数据结构则是“整洁数据”。 library(tidyr) tidyr包中的函数可以分为5个主要大类 pivot_longer() 和 pivot_wider() 宽转长以及长转宽 unnest_longer() 和 unnest_wider(),hoist() 将列表嵌套转化为整洁数据 nest() 数据嵌套 separate(),extract()拆分列,提取新列 replace_na() 缺失值处理 7.2.1 宽转长 详情查看vignette(\"pivot\"),以下是照搬该图册中的内容 7.2.1.1 基础 长数据与宽数据之间的转换，类似我们常用的EXcel中的透视表功能。接下来用tidyr包自带的插图案例记录相关函数用法 在Excel中有时候方便我们肉眼观察，可能一个数据集会有很多列,如下所示： col1 col2 col3 col4 col5 col6 col7 v1 v2 v3 v4 v5 v6 v7 vb1 vb2 vb3 vb4 vb5 vb6 vb7 方便观察，但是不方便统计分析，这是我们需要把数据做处理，从“宽数据变成长数据”即宽转长。 library(tidyr) library(dplyr) library(readr) relig_income %&gt;% pivot_longer(cols = !religion,names_to = &#39;income&#39;,values_to = &quot;count&quot;) 第一个参数是数据集 第二个参数是那些列需要重塑，在该例中除了religion的其他全部列 names_to这个参数是新增的列名 values_to是新增的存储之前数据集中数据的列名 7.2.1.2 列名带数字 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE ) names_prefix 调整内容前缀，配合names_transform参数使用 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, names_transform = list(week = as.integer), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) 经过以上转换week列属性变成了整数，当然达到以上效果有其他的途径，如下： library(tidyverse,warn.conflicts = TRUE) # method 1 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_transform = list(week = readr::parse_number), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) # method 2 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE, ) %&gt;% mutate(week = str_remove(week, &quot;wk&quot;) %&gt;% as.integer()) 7.2.1.3 多变量列名 该案列设计比较复杂的正则表达式,new_?(.*)_(.)(.*)需要一定正则表达式基础。 new_?表示匹配new或new_，(.*)匹配任意0次或多次任意字符。 正则表达式介绍 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, values_to = &quot;count&quot; ) 进一步处理列gender，age 。 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, names_transform = list( gender = ~ readr::parse_factor(.x, levels = c(&quot;f&quot;, &quot;m&quot;)), age = ~ readr::parse_factor( .x, levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), ordered = TRUE ) ), values_to = &quot;count&quot;, ) 7.2.1.4 一行多观测值 family &lt;- tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, &quot;1998-11-26&quot;, &quot;2000-01-29&quot;, 1L, 2L, 2L, &quot;1996-06-22&quot;, NA, 2L, NA, 3L, &quot;2002-07-11&quot;, &quot;2004-04-05&quot;, 2L, 2L, 4L, &quot;2004-10-10&quot;, &quot;2009-08-27&quot;, 1L, 1L, 5L, &quot;2000-12-05&quot;, &quot;2005-02-28&quot;, 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with(&quot;dob&quot;)), parse_date) family family %&gt;% pivot_longer( !family, names_to = c(&quot;.value&quot;, &quot;child&quot;), names_sep = &quot;_&quot;, values_drop_na = TRUE ) anscombe %&gt;% pivot_longer(everything(), names_to = c(&quot;.value&quot;, &quot;set&quot;), names_pattern = &quot;(.)(.)&quot; ) %&gt;% arrange(set) pnl &lt;- tibble( x = 1:4, a = c(1, 1,0, 0), b = c(0, 1, 1, 1), y1 = rnorm(4), y2 = rnorm(4), z1 = rep(3, 4), z2 = rep(-2, 4), ) pnl %&gt;% pivot_longer( !c(x, a, b), names_to = c(&quot;.value&quot;, &quot;time&quot;), names_pattern = &quot;(.)(.)&quot; ) 7.2.1.5 重复列名 df &lt;- tibble(id = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = &quot;minimal&quot;) df %&gt;% pivot_longer(!id, names_to = &quot;name&quot;, values_to = &quot;value&quot;) 7.2.2 长转宽 pivot_wider()功能与pivot_longer()相反。通过增加列数减少行数使数据集变得更宽，通常我们在汇总时候使用，达到类似Excel透视表结果。 7.2.2.1 基础 fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) 缺失值填充 fish_encounters %&gt;% pivot_wider( names_from = station, values_from = seen, values_fill = 0 ) 7.2.2.2 聚合 warpbreaks &lt;- warpbreaks %&gt;% as_tibble() warpbreaks %&gt;% count(wool, tension) 需要通过values_fn指定聚合方式 warpbreaks %&gt;% pivot_wider(names_from = wool, values_from = breaks,values_fn= list(breaks = sum)) 7.2.2.3 从多个变量生成新列名 production &lt;- expand_grid( product = c(&quot;A&quot;, &quot;B&quot;), country = c(&quot;AI&quot;, &quot;EI&quot;), year = 2000:2014 ) %&gt;% filter((product == &quot;A&quot; &amp; country == &quot;AI&quot;) | product == &quot;B&quot;) %&gt;% mutate(production = rnorm(nrow(.))) production production %&gt;% pivot_wider( names_from = c(product, country), values_from = production ) 通过names_sep和names_prefix参数控制新的列名，或通过names_glue production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_sep = &quot;.&quot;, names_prefix = &quot;prod.&quot; ) production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_glue = &quot;prod_{product}_{country}&quot; ) 7.2.2.4 多值变宽 us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) 7.2.3 处理json,html的数据 实际工作中不是经常使用，需要使用的时候往往会用相关的包处理：jsonlite 可通过vignette(\"rectangle\")自行学习 library(tidyr) library(dplyr) library(repurrrsive) users &lt;- tibble(user = gh_users) users users %&gt;% unnest_wider(user) 7.2.4 嵌套数据 library(tidyr) library(dplyr) library(purrr) 7.2.4.1 基础 嵌套数据即：数据框中嵌套数据框，如下所示： df1 &lt;- tibble( g = c(1, 2, 3), data = list( tibble(x = 1, y = 2), tibble(x = 4:5, y = 6:7), tibble(x = 10) ) ) df1 因为data.frame()的列特性【每列都是列表】【不确定理解对不对】：可以做如下操作： df2 &lt;- tribble( ~g, ~x, ~y, 1, 1, 2, 2, 4, 6, 2, 5, 7, 3, 10, NA ) df2 %&gt;% nest(data = c(x, y)) #sample above #df2 %&gt;% group_by(g) %&gt;% nest() nest的反面 unnest df1 %&gt;% unnest(data) 7.2.5 嵌套数据和模型 mtcars_nested &lt;- mtcars %&gt;% group_by(cyl) %&gt;% nest() mtcars_nested mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(data, function(df) lm(mpg ~ wt, data = df))) mtcars_nested mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(model, predict)) mtcars_nested 7.2.6 拆分和合并 7.2.6.1 拆分 有时我们需要将一列拆分为多列： library(tidyr) df &lt;- data.frame(x = c(NA, &quot;a.b&quot;, &quot;a.d&quot;, &quot;b.c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;, &quot;B&quot;)) 拆分数多列或少列时用NA补齐： df &lt;- data.frame(x = c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;, NA)) df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;)) 多余的部分舍弃，缺失填充在左边还是右边： # The same behaviour as previous, but drops the c without warnings: df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;drop&quot;, fill = &quot;right&quot;) 多余部分合并，缺失填充在左边 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;merge&quot;, fill = &quot;left&quot;) 或者全部保留 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 指定分隔符 df %&gt;% separate(x, c(&quot;key&quot;, &quot;value&quot;), sep = &quot;: &quot;, extra = &quot;merge&quot;) 使用正则表达式 # Use regular expressions to separate on multiple characters: df &lt;- data.frame(x = c(NA, &quot;a?b&quot;, &quot;a.d&quot;, &quot;b:c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;,&quot;B&quot;), sep = &quot;([.?:])&quot;) 7.2.6.2 新列提取 df &lt;- data.frame(x = c(NA, &quot;a-b&quot;, &quot;a-d&quot;, &quot;b-c&quot;, &quot;d-e&quot;)) df %&gt;% extract(x, &quot;A&quot;) df %&gt;% extract(x, c(&quot;A&quot;, &quot;B&quot;), &quot;([[:alnum:]]+)-([[:alnum:]]+)&quot;) # [:alnum:] 匹配字母和数字 以上本质是字符处理，正则表达式 7.2.6.3 合并 df &lt;- expand_grid(x = c(&quot;a&quot;, NA), y = c(&quot;b&quot;, NA)) df df %&gt;% unite(&quot;z&quot;, x:y, remove = FALSE) # expand_grid 类似笛卡尔积功能 移除缺失值 df %&gt;% unite(&quot;z&quot;, x:y, na.rm = TRUE, remove = FALSE) 合并后再拆分 df %&gt;% unite(&quot;xy&quot;, x:y) %&gt;% separate(xy, c(&quot;x&quot;, &quot;y&quot;)) 7.2.7 缺失值处理 replace_na()用特定值替换缺失值。 df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;)) df %&gt;% replace_na(list(x = 0, y = &quot;unknown&quot;)) df %&gt;% dplyr::mutate(x = replace_na(x, 0)) "],["dplyr.html", "8 dplyr", " 8 dplyr dplyr包是tidyverse系列中的核心包之一,dplyr是A Grammar of Data Manipulation ，即dplyr是数据处理的语法。 与sql相比，用R实现相同功能的好处： 代码量极大减少 当逻辑复杂时，R可以按照顺序一步步实现，无需嵌套，实现过程简单 该包就是从数据库相关操作中抽象而来，迁移成本低 配合dbplyr包使用，大部分情况下可以扔掉sql语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用 本章节利用R语言完成与Excel透视表或sql语句的功能，将从行条件筛选、排序、分组聚合、表关联等方面记录R的实现方式。 "],["前言.html", "8.1 前言", " 8.1 前言 介绍 dplyr包提供一组动词来解决最常见的数据处理问题： mutate() 添加新变量,现有变量的函数 select() 筛选列,根据现有变量名称选择变量 filter() 筛选行，根据条件筛选 summarise() 按照一定条件汇总聚合 arrange() 行排序 以上动词都可以和group_by()结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过vignette(\"two-table\")查看学习。 安装 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;dplyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/dplyr&quot;) Cheat Sheet dplyr-sheet "],["基础用法-2.html", "8.2 基础用法", " 8.2 基础用法 基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述dplyr功能。 8.2.1 加载包 #library(dplyr) # 禁掉提示 library(dplyr,warn.conflicts = FALSE) 8.2.2 filter filter动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和SQL中where条件一致。 filter条件筛选中可以分为单条件筛选和多条件筛选，多条件中间用,分隔。 单条件 条件为species == \"Droid\"时，如下所示： starwars %&gt;% filter(species == &quot;Droid&quot;) 多条件 多条件筛选时，用英文逗号隔开多个条件。用“and”连接多个条件与用逗号隔开效果相同,“and”在R中用&amp;表示。 starwars %&gt;% filter(species == &quot;Droid&quot;,skin_color == &quot;gold&quot;) # same above # starwars %&gt;% # filter(species == &quot;Droid&quot; &amp; skin_color == &quot;white&quot;) 多情况筛选 类似SQL中 in 的用法，或Excel中筛选条件时“或”条件 starwars %&gt;% filter(species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) 逻辑关系筛选 条件运算分为逻辑运算、关系运算。 关系运算符 &gt;、&lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。 逻辑运算符 &amp;、|、！。 |为 或, &amp; 为并、且条件，!为非。 library(nycflights13) filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) # same above filter(flights, arr_delay &lt;= 120 &amp; dep_delay &lt;= 120) # %in% 的反面 starwars %&gt;% filter(!species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) !的运算级别相比 %in% 更高 8.2.3 select 当完整数据集列数较多时，我们某次分析可能并不需要那么多列，通过动词select()筛选列 基础用法 通过指定列名称筛选，并指定列之间顺序 starwars %&gt;% select(name,height,mass,hair_color,skin_color,eye_color) 列索引 通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。 starwars %&gt;% select(name : eye_color) #same above starwars %&gt;% select(1:6) # starwars %&gt;% # select(c(1,2,4,5,7)) 8.2.4 rename 列重命名使用rename()函数，新名称写前面，如下所示： starwars %&gt;% rename(home_world = homeworld) # 多列同换 starwars %&gt;% rename(home_world = homeworld,skincolor = skin_color) 8.2.5 relocate 更改列顺序，与使用select()动词指定列顺序相似 # sex:homeworld列在height列前面 starwars %&gt;% relocate(sex:homeworld, .before = height) 8.2.6 mutate 动词mutate 新增计算列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% select(name:mass,bmi) 新增计算列基础上新增列， starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2),newbmi = bmi *2) %&gt;% select(name:mass,bmi,newbmi) 删除列 starwars %&gt;% mutate(height = NULL) 8.2.7 arrange 单列排序，默认升序，通过desc()降序排列 starwars %&gt;% arrange(desc(mass)) 多列排序 starwars %&gt;% arrange(height,desc(mass)) 8.2.8 group_by 在汇总前一般都需要分组聚合，group_by()函数实现该功能，与SQL中group by ···类似 8.2.9 summarise 按照分组聚合汇总 starwars %&gt;% group_by(species) %&gt;% summarise( n = n(), mass = mean(mass, na.rm = TRUE) ) "],["表操作.html", "8.3 表操作", " 8.3 表操作 指像sql中的left join,inner join等表格之间的操作，或者是Excel中Power Piovt建模的建立关系，从而实现不同表格间的关联 表格中的列操作，如列求和，均值等 行操作指不同字段间的计算，如Excle的列与列之间计算,Excle中的函数对行列不敏感，没有明显区别，但是R中tidyverse里列计算简单，行间计算依赖rowwise()函数实现 8.3.1 基础 left_join(),full_join,inner_join()等动词关联两个表。详情请查看：vignette(\"two-table\") left_join()实现类似Excel中VLOOKUP函数功能或数据库中left join功能，将“右表”的字段依据“主键”关联到“左表”上。 基础用法 left_join(),right_join(),full_join(),inner_join()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中连接方式一致。 默认会自动寻找两表中相同的字段名作为关联的条件 library(&quot;nycflights13&quot;) # Drop unimportant variables so it&#39;s easier to understand the join results. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% left_join(airlines) 指定关联条件列，类似数据库中on a.column = b.column flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) 不同名称列关联 left_join(x,y,by = c(\"a\" = \"b\", \"c\" = \"d\")) 将会匹配 x\\(a to y\\)b 和 x\\(c to y\\)d 作为关联条件 #出发机场和目的机场信息 flights2 %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) #flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) # 组合条件 多条件时用向量包裹即可c(&quot;dest&quot; = &quot;faa&quot;,&quot;cola&quot; = &quot;colb&quot;)) 筛选连接 anti_join() 删除所有左表中在右表中匹配到的行 semi_join()保留所有左表在右表中匹配到的行 df1 &lt;- tibble(a=letters[1:20],b=1:20) df2 &lt;- tibble(a=letters,b=1:26) df1 %&gt;% semi_join(df2) df2 %&gt;% anti_join(df1) 集合操作 intersect(x,y)返回x,y交集 union(x,y)返回x,y中唯一的值 setdiff(x,y)返回存在x中但是不存在y中的记录 (df1 &lt;- tibble(x = 1:2, y = c(1L, 1L))) (df2 &lt;- tibble(x = 1:2, y = 1:2)) intersect(df1, df2) union(df1, df2) setdiff(df1, df2) setdiff(df2, df1) 8.3.2 多表操作 多表操作请使用purrr::reduce(),当需要合并多个表格时，可用以下方式减少合并代码量。 dt1 &lt;- data.frame(x = letters) dt2 &lt;- data.frame(x = letters,cola = 1:26) dt3 &lt;- data.frame(x = letters,colb = 1:26) dt4 &lt;- data.frame(x = letters,cold = 1:26) dt5 &lt;- data.frame(x = letters,cole = 1:26) dtlist &lt;- list(dt1,dt2,dt3,dt4,dt5) purrr::reduce(dtlist,left_join,by=&#39;x&#39;) "],["列操作.html", "8.4 列操作", " 8.4 列操作 在多列上执行相同的操作是常用的操作，但是通过复制和粘贴代码，麻烦不说还容易错： df %&gt;% group_by(g1, g2) %&gt;% summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d)) 通过across()函数可以更简洁地重写上面代码： df %&gt;% group_by(g1, g2) %&gt;% summarise(across(a:d, mean)) 8.4.1 基本操作 across() 有两个主要参数： 第一个参数，.cols选择要操作的列。它使用tidyr的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。 第二个参数，.fns是要应用于每一列的一个函数或函数列表。这也可以是purrr样式的公式（或公式列表），例如~ .x / 2。 starwars %&gt;% summarise(across(where(is.character), ~ length(unique(.x)))) # 列属性是字符的列求唯一值数 # starwars %&gt;% # summarise(length(unique(name))) # starwars %&gt;% # summarise(length(unique(hair_color))) starwars %&gt;% group_by(species) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(c(sex, gender, homeworld), ~ length(unique(.x)))) starwars %&gt;% group_by(homeworld) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) across() 不会选择分组变量： df &lt;- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9)) df %&gt;% group_by(g) %&gt;% summarise(across(where(is.numeric), sum)) 8.4.2 多种函数功能 通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量： min_max &lt;- list( min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE) ) starwars %&gt;% summarise(across(where(is.numeric), min_max)) 通过.names参数控制名称： NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时 以下是官方图册中的案例，但是报错： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{.fn}.{.col}&quot;)) 修改后正常运行： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}.{col}&quot;)) 区别主要是.names参数的使用方式问题，.加不加的问题。 starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}——{col}&quot;)) 8.4.3 当前列 如果需要，可以通过调用访问内部的“当前”列的名称cur_column()。 该函数不是特别容易理解，需要多尝试使用加深认识。 df &lt;- tibble(x = 1:3, y = 3:5, z = 5:7) mult &lt;- list(x = 1, y = 10, z = 100) df %&gt;% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]])) "],["行操作.html", "8.5 行操作", " 8.5 行操作 在操纵数据框中，dplyr等工具让我们对列操作相对简单，但是对行操作则困难些。 8.5.1 构造数据集 df &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() 像group_by(),rowwise()并没有做任何事情，它的作用是改变其他动词的工作方式： 比较以下代码中不的不同 df %&gt;% mutate(m = mean(c(x, y, z))) df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) data.table中的操作: library(data.table) dt &lt;- data.table(x = 1:2, y = 3:4, z = 5:6) dt[,m:=mean(c(x,y,z))][] dt[,m:=mean(c(x,y,z)),by=.(x)][] 您可以选择在调用中提供“标识符”变量rowwise()。这些变量在您调用时被保留summarise()，因此它们的行为与传递给的分组变量有些相似group_by()： df &lt;- tibble(name = c(&quot;Mara&quot;, &quot;Hadley&quot;), x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() %&gt;% summarise(m = mean(c(x, y, z))) df %&gt;% rowwise(name) %&gt;% summarise(m = mean(c(x, y, z))) 8.5.2 行汇总统计 dplyr::summarise()使得汇总一列中各行的值非常容易。当与之结合使用时rowwise()，还可以轻松汇总一行中各列的值： df &lt;- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45) rf &lt;- df %&gt;% rowwise(id) rf %&gt;% mutate(total = sum(c(w, x, y, z))) rf %&gt;% summarise(total = sum(c(w, x, y, z))) 键入每个变量名称很繁琐，通过c_across()使更简单 rf %&gt;% mutate(total = sum(c_across(w:z))) rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) rf %&gt;% mutate(total = sum(c_across(w:z))) %&gt;% ungroup() %&gt;% mutate(across(w:z, ~ . / total)) "],["分组操作.html", "8.6 分组操作", " 8.6 分组操作 详情: https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html group_by()最重要的分组动词,需要一个数据框和一个或多个变量进行分组： 8.6.1 添加分组 by_species &lt;- starwars %&gt;% group_by(species) by_sex_gender &lt;- starwars %&gt;% group_by(sex, gender) 除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在mutate()之后执行group_by: bmi_breaks &lt;- c(0, 18.5, 25, 30, Inf) starwars %&gt;% group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %&gt;% tally() 8.6.2 删除分组变量 要删除所有分组变量，使用ungroup(): by_species %&gt;% ungroup() %&gt;% tally() 8.6.3 动词 summarise() 计算每个组的汇总，表示从group_keys开始右侧添加汇总变量 by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE) ) 该.groups=参数控制输出的分组结构。删除右侧分组变量的历史行为对应于.groups = “drop_last”没有消息或.groups = NULL有消息（默认值）。 从1.0.0版开始，分组信息可以保留(.groups = \"keep\")或删除 (.groups = 'drop) a &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;drop&#39;) %&gt;% group_vars() b &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;keep&#39;) %&gt;% group_vars() object.size(a) object.size(b) 在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。 "],["常用函数-2.html", "8.7 常用函数", " 8.7 常用函数 8.7.1 条件判断 相比于base::ifelse,if_else更为严格，无论TRUE或FALSE输出类型一致，这样速度更快。与data.table::fifelse()功能相似。 if_else(condition, true, false, missing = NULL) 与ifelse不同的是，if_else保留类型 x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) 8.7.2 case_when 当条件嵌套条件较多时，使用case_when,使代码可读并且不易出错。与sql 中的case when 等价。 Dates &lt;- as.Date(c(&#39;2018-10-01&#39;, &#39;2018-10-02&#39;, &#39;2018-10-03&#39;)) case_when( Dates == &#39;2018-10-01&#39; ~ Dates - 1, Dates == &#39;2018-10-02&#39; ~ Dates + 1, Dates == &#39;2018-10-03&#39; ~ Dates + 2, TRUE ~ Dates ) 8.7.3 计数函数 计数 count()函数用来计数。下面两种表达方式等价。 df %&gt;% count(a, b) # same above df %&gt;% group_by(a, b) %&gt;% summarise(n = n()) starwars %&gt;% count(species) # same above 等价 starwars %&gt;% group_by(species) %&gt;% summarise(n = n()) 非重复计数 n_distinct()与length(unique(x))等价，但是更快更简洁。当我们需要给门店或订单之类数据需要去重计算时采用该函数。 x &lt;- sample(1:10, 1e5, rep = TRUE) length(unique(x)) n_distinct(x) 8.7.4 排序函数 dplyr共六种排序函数，模仿SQL2003中的排名函数。 row_number():等于 rank(ties.method = “first”) min_rank(): 等于 rank(ties.method = “min”) dense_rank(): 与min_rank()相似,但是没有间隔 percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1] x &lt;- c(5, 1, 3, 2, 2, NA) row_number(x) min_rank(x) dense_rank(x) percent_rank(x) cume_dist(x) 8.7.5 提取向量 该系列函数是对[[的包装。 nth(x, n, order_by = NULL, default = default_missing(x)) first(x, order_by = NULL, default = default_missing(x)) last(x, order_by = NULL, default = default_missing(x)) x &lt;- 1:10 y &lt;- 10:1 first(x) last(y) nth(x, 1) nth(x, 5) 8.7.6 group 系列 group_by(),group_map(), group_nest(), group_split(), group_trim()等一系列函数。 其中我常用group_by(),group_split()两个函数。group_by()是大部分数据操作中的分组操作，按照group_by()的指定分组条件。 group_by() #group_by()不会改变数据框 by_cyl &lt;- mtcars %&gt;% group_by(cyl) by_cyl # It changes how it acts with the other dplyr verbs: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) # group_by中可以添加计算字段 即mutate操作 mtcars %&gt;% group_by(vsam = vs + am) %&gt;% group_vars() group_map() group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据库的数据清洗一般不涉及，常用在建模等方面。 但是目前三个函数是实验性的，未来可能会发生变化。 # return a list # 返回列表 mtcars %&gt;% group_by(cyl) %&gt;% group_map(~ head(.x, 2L)) iris %&gt;% group_by(Species) %&gt;% group_modify(~ { .x %&gt;% purrr::map_dfc(fivenum) %&gt;% mutate(nms = c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;)) }) # group_walk dir.create(temp &lt;- tempfile()) iris %&gt;% group_by(Species) %&gt;% group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, &quot;.csv&quot;)))) list.files(temp, pattern = &quot;csv$&quot;) unlink(temp, recursive = TRUE) group_cols() 选择分组变量 gdf &lt;- iris %&gt;% group_by(Species) gdf %&gt;% select(group_cols()) 8.7.7 其它函数 between cummean cumsum cumall cumany 累计系列函数 x &lt;- c(1, 3, 5, 2, 2) cummean(x) cumsum(x) / seq_along(x) cumall(x &lt; 5) cumany(x == 3) distinct df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) distinct(df, x) distinct(df, x, .keep_all = TRUE) distinct(df, diff = abs(x - y)) "],["用dplyr编程.html", "8.8 用dplyr编程", " 8.8 用dplyr编程 Programming with dplyr: https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html 本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。 虽然复杂但是比较实用，尤其是当我们需要定义一些通用功能函数时 以下是对原文引用 两种情况： When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like filter(df, {{ var }}). The following function uses embracing to create a wrapper around summarise() that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised: var_summary &lt;- function(data, var) { data %&gt;% summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])). The following example uses .data to count the number of unique values in each variable of mtcars: for (var in names(mtcars)) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with .data$x or indirectly with .data[[var]]. Don’t expect other functions to work with it. 8.8.1 案例 当我们不知道接下来会用哪个变量汇总时： my_summarise &lt;- function(data, group_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean(mass)) } 如果在多个位置使用： my_summarise2 &lt;- function(data, expr) { data %&gt;% summarise( mean = mean({{ expr }}), sum = sum({{ expr }}), n = n() ) } 当多个表达式时： my_summarise3 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } 如果要输出变量名时： my_summarise4 &lt;- function(data, expr) { data %&gt;% summarise( &quot;mean_{{expr}}&quot; := mean({{ expr }}), &quot;sum_{{expr}}&quot; := sum({{ expr }}), &quot;n_{{expr}}&quot; := n() ) } my_summarise5 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise( &quot;mean_{{mean_var}}&quot; := mean({{ mean_var }}), &quot;sd_{{sd_var}}&quot; := mean({{ sd_var }}) ) } 任意个表达式： 这种使用场景更多 my_summarise &lt;- function(.data, ...) { .data %&gt;% group_by(...) %&gt;% summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE)) } starwars %&gt;% my_summarise(homeworld) starwars %&gt;% my_summarise(sex, gender) "],["loop-structure.html", "9 Loop structure", " 9 Loop structure 实际场景中,当需要重复做某动作时,可运用循环结构。 "],["简单示例.html", "9.1 简单示例", " 9.1 简单示例 利用循环实现1到100连续相加求和 total &lt;- 0 for(i in 1:100){ total &lt;- total+i } print(paste0(&#39;1到100连续相加求和等于:&#39;,total)) # loop structure # for (var in seq) {expr} "],["循环基础.html", "9.2 循环基础", " 9.2 循环基础 9.2.1 循环结构 R中有三种循环结构： Repeat i &lt;- 1 total &lt;- 0 repeat{ total &lt;- total+i i &lt;- i+1 if(i &gt; 100){ print(paste0(&#39;连续相加求和等于:&#39;,total)) break } } while i &lt;- 1 total &lt;- 0 while(i &lt;= 1000){ total &lt;- total+i i &lt;- i+1 } print(paste0(&#39;1到1000连续相加求和等于:&#39;,total)) # not run # sum(1:1000) for 代码如示例所示 library(tidyverse) df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) output &lt;- vector(&quot;double&quot;, ncol(df)) # 1. output for (i in seq_along(df)) { # 2. sequence output[[i]] &lt;- median(df[[i]]) # 3. body } output 循环中尽可能利用R中的向量化,比如指定output的长度,当数据量大的时候效率提升将比较明显,养成向量化的意识对提高代码效率有显著效果. 上面代码中 vector函数创建一个空向量带指定长度，有两个参数，第一个时向量类型(‘逻辑,’‘整数,’‘双精度,’’字符’等)，第二个是向量长度 vector(length=5),类型默认是逻辑型. seq_along可以?seq查看用法. hadely 解释如下: You might not have seen seq_along() before. It’s a safe version of the familiar 1:length(l), with an important difference: if you have a zero-length vector, seq_along() does the right thing: #wrong seq_along(c()) 1:length(c()) # generates the integer sequence 1, 2, ..., length(along.with). (along.with is usually abbreviated to along, and seq_along is much faster.) 9.2.2 next break 用法 next 用法 for(i in letters[1:6] ){ if(i == &quot;d&quot;){ next } print(i) } break 用法 可以当条件满足时跳出循环常常与repeat循环结构配合使用。 9.2.3 嵌套循环 # not run v &lt;- vector(length = 100) for(i in 1:10){ for(j in 1:10){ v[i*j] = i * j } } "],["循环变化.html", "9.3 循环变化", " 9.3 循环变化 9.3.1 修改已有对象 res &lt;- 1:100 for(i in seq_along(res)){ res[i] &lt;- res[i] * i } str(res) 9.3.2 循环模式 共有三种遍历向量的方法,之前展示的都是遍历数字索引for (i in seq_along(xs)),并使用提取值x[[i]].还有两种方式: 循环遍历元素 for(i in xs),例如我们需要保存文件时,可以利用这种循环模式 遍历名称 for (nm in names(xs)),我们可以使用x[[nm]] 该名称访问.当我们要在文件名中使用名称时会比较方便. results &lt;- vector(&quot;list&quot;, length(x)) names(results) &lt;- names(x) 数字索引的循环模式最常用,因为可以根据位置提取名称和值. for (i in seq_along(x)) { name &lt;- names(x)[[i]] value &lt;- x[[i]] } 9.3.3 未知长度输出 有时候我们的循环我们不确定输出的长度是多少.这样会逐步增加向量的长度,如下所示： means &lt;- c(0, 1, 2) output &lt;- double() for (i in seq_along(means)) { n &lt;- sample(100, 1) output &lt;- c(output, rnorm(n, means[[i]])) } str(output) 但是这种方式浪费时间，当数据量大时候效率会很低下.因为时间复杂度为(\\(O(n^2)\\)).解决方案是将结果保存在列表中,然后在完成循环后合并为单个向量: out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)) { n &lt;- sample(100, 1) out[[i]] &lt;- rnorm(n, means[[i]]) } str(out) str(unlist(out)) #unlist将列表向量化 "],["iteration.html", "10 Iteration", " 10 Iteration 常常需要重复操作同样的功能函数，这时可以用迭代来实现。purrr包提供了一套完整的函数来处理循环迭代,可以有效减少重复性工作和代码。 https://purrr.tidyverse.org/ "],["简单用法.html", "10.1 简单用法", " 10.1 简单用法 map 用map循环迭代,map函数始终返回list对象。 library(tidyverse) # define function addTen &lt;- function(.x) { return(.x + 10) } map(.x = c(1, 4, 7), .f = addTen) # not run # map(c(1, 4, 7), addTen) # same above map_dbl 用map_dbl循环迭代，map_dbl函数返回vector。 #library(purrr) add1 &lt;- function(x) { (x+1)*x } result1 &lt;- map_dbl(1:1000,add1) # maP_dbl 输出结果为向量 #for版本 result2 &lt;- vector(length = 1000) for(i in 1:1000){ result2[i] &lt;- (i+1) * i } # test #not run #table(result1 == result2) # all equal identical(result1,result2) "],["map系列常用函数.html", "10.2 map系列常用函数", " 10.2 map系列常用函数 map_chr map_chr(.x, .f) ,map_chr 返回对象为字符串 map_dbl map_dbl(.x, .f) ,map_dbl 返回数字向量(双精度) map_df map_df(.x, .f),map_df 返回对象为数据框,类似函数 map_dfr(.x,.f),map_dfc(.x,.f) map_gl map_lgl(.x, .f) 返回逻辑向量 map_int map_int(.x, .f, ...) 返回整数 map_df()函数示例 # 采用匿名函数 map_df(c(1, 4, 7), function(.x) { return(data.frame(old_number = .x, new_number = addTen(.x))) }) #同上 #step1 定义函数 make_dataframe &lt;- function(x){ data.frame(old_number = x,new_number = addTen(x)) } #step2 计算 map_df(c(1,4,7),make_dataframe) "],["归约累计函数.html", "10.3 归约累计函数", " 10.3 归约累计函数 reduce、accumulate()函数用法介绍. reduce 在实际工作中,我长用reduce函数实现merge()功能。示例如下： reduce(1:100,`+`) reduce(100:1,`-`) 将函数功能不断运用到list上得到最后结果。 n &lt;- 10 dt1 &lt;- data.frame(a=letters[n],b1=rnorm(n)) dt2 &lt;- data.frame(a=letters[n],b2=rnorm(n)) dt3 &lt;- data.frame(a=letters[n],b3=rnorm(n)) dt4 &lt;- data.frame(a=letters[n],b4=rnorm(n)) reduce(list(dt1,dt2,dt3,dt4),merge) # not run # reduce(list(dt1,dt2,dt3,dt4),merge,by=&#39;a&#39;) same above accumulate 1:5 %&gt;% accumulate(`+`) accumulate(letters[1:5], paste, sep = &quot;.&quot;) "],["安全函数.html", "10.4 安全函数", " 10.4 安全函数 possibly() 和 safely(),当循环时候遇到错误报错导致整个程序停止,这不是我们想要的。 l &lt;- list(1,2,3,4,&#39;5&#39;) map(l,function(.x) .x+1) 以上程序将会报错,不能正确得到结果。 l &lt;- list(1,2,3,4,&#39;5&#39;) test_fun &lt;- safely(function(.x) .x+1) map(l,test_fun) 用safely()函数将原始function包裹起来,即使执行过程中遇到错误也可以完成整个任务,不会因为中途报错停止,在大型循环过程中,如爬虫过程中比较实用。 "],["映射多个参数.html", "10.5 映射多个参数", " 10.5 映射多个参数 map2 和 pmap 函数可以映射两个及以上参数。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) map2(li1,li2,`+`) 类似函数 map2_dbl,map2_chr,map2_dfr等等。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) li3 &lt;- list(2,4,6) li1 &lt;- c(1,3,5) li2 &lt;- c(2,4,6) li3 &lt;- c(2,3,4) li &lt;- list(li1,li2,li3) pmap(li,sum) 同上有pmap_int,pmap_dbl,pmap_dfr等函数。 "],["其他函数介绍.html", "10.6 其他函数介绍", " 10.6 其他函数介绍 flatten flatten()系列函数可以将列表输出为稳定类型。purrr package 自带Examples。 x &lt;- rerun(2, sample(4)) x x %&gt;% flatten() x %&gt;% flatten_int() # You can use flatten in conjunction with map x %&gt;% map(1L) %&gt;% flatten_int() # But it&#39;s more efficient to use the typed map instead. x %&gt;% map_int(1L) imap imap()系列函数官方描述： imap_xxx(x, …), an indexed map, is short hand for map2(x, names(x), …) if x has names, or map2(x, seq_along(x), …) if it does not. This is useful if you need to compute on both the value and the position of an element. imap,当x有names(x)或者seq_along(x)属性,imap是map2的另一种表达方式。 使用公式快捷方式时,第一个参数是值(.x),第二个参数是位置/名称(.y)。 详情请查看:?imap 示例1： imap_chr(sample(10), ~ paste0(.y, &quot;: &quot;, .x)) sample(10),没有names(),只有长度信息。转化成map2表达如下: #same above map2_chr(sample(10),1:10,~paste0(.y,&quot;: &quot;,.x)) # 第二个list 为位置信息. "],["define-function.html", "11 define function", " 11 define function 函数功能使我们尽可能避免复制粘贴代码,而且需要更改的时候不需要大面积修改代码仅需要调整函数参数,使代码整体更加模块化. 假设有工作任务需要给商品SKU排名,在代码中需要重复以下代码5次,当区间需要修改的时候就是灾难. 原始代码示例如下: library(tidyverse) num &lt;- sample(1:1000,1000) res1 &lt;- if_else(num &lt;= 50,&quot;1-50&quot;, if_else(num &lt;= 100,&quot;51-100&quot;, if_else(num &lt;= 150,&quot;101-150&quot;, if_else(num &lt;= 200 ,&quot;151-200&quot;, if_else(num &gt;200,&quot;200以上&quot;,&#39;其他&#39;))))) # same above # case_when(num &lt;= 50 ~ &#39;1-50&#39;, # num &lt;= 100 ~ &#39;51-100&#39;, # num &lt;= 150 ~ &#39;101-150&#39;, # num &lt;= 200 ~ &#39;151-200&#39;, # num &gt; 100 ~ &#39;200以上&#39; # ) # 个人倾向data.table # data.table::fifelse() # data.table::fcase() 是sql中case when的实现 函数化后代码示例如下: 当需要修改区间时候仅仅只需要调整参数,而不必大量修改代码,当在脚本中需要调用多次时,能简洁代码. # 排名区间函数 #library(tidyverse) cut_function &lt;- function(vecto,x,n){ vec &lt;- c(0) for(i in 1:n){ kong &lt;- i*x vec &lt;- c(vec,kong) } vec &lt;- c(vec,Inf) labels &lt;- c() j &lt;- 1 while (j&lt;=n) { labels[j] &lt;- str_c(vec[j]+1,&quot;-&quot;,vec[j+1]) j &lt;- j+1 } labels &lt;- c(labels,paste0(vec[j],&#39;以上&#39;)) res &lt;- cut(x = vecto,breaks = vec,labels = labels) %&gt;% as.character() } res2 &lt;- cut_function(num,50,4) # identical(res1,res2) # &gt; TRUE 参考资料 "],["简单示例-1.html", "11.1 简单示例", " 11.1 简单示例 给函数取一个合适名字是很难的事情,徐尽可能从函数名称看出你实现的功能. add_ten &lt;- function(x){ res &lt;- x+10 return(res) #可以不用显示返回 } add_ten(1) 写函数时需要考虑函数使用情况,尽可能考虑容错情况,当输入不符合预期时能友好提示错误. add_ten &lt;- function(x){ if(is.numeric(x)==TRUE){ x+10 } else { print(&#39;Error,请输入数字&#39;) } } "],["条件执行.html", "11.2 条件执行", " 11.2 条件执行 has_name &lt;- function(x) { nms &lt;- names(x) if (is.null(nms)) { rep(FALSE, length(x)) } else { !is.na(nms) &amp; nms != &quot;&quot; } } 11.2.1 多条件执行 if (this) { # do that } else if (that) { # do something else } else { # } 当需要很多if时可考虑用switch()功能 function(x, y, op) { switch(op, plus = x + y, minus = x - y, times = x * y, divide = x / y, stop(&quot;Unknown op!&quot;) ) } "],["函数参数.html", "11.3 函数参数", " 11.3 函数参数 函数的参数通常分为两大类,一组是提供要计算的参数,另外一组提供计算时的细节参数. mean_ci &lt;- function(x, conf = 0.95) { se &lt;- sd(x) / sqrt(length(x)) alpha &lt;- 1 - conf mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2)) } x &lt;- runif(100) mean_ci(x) mean_ci(x, conf = 0.99) 11.3.1 参数名称 参数的名称很重要,方便我们理解参数含义,调用时不会混乱.以下时几个重要的参数名称 x, y, z: vectors. w: a vector of weights. df: a data frame. i, j: numeric indices (typically rows and columns). n: length, or number of rows. p: number of columns. 11.3.2 检查参数值 在写函数时,并不清楚最终函数的输出,在编写函数时进行约束是有必要的. wt_mean &lt;- function(x, w) { if (length(x) != length(w)) { stop(&quot;`x` and `w` must be the same length&quot;, call. = FALSE) } sum(w * x) / sum(w) } 11.3.3 …参数 R中的许多函数都能接受任意数量的输入： sum(1,2,3,4,5,6,7,8,9,10) stringr::str_c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;) 下面的例子中 commas &lt;- function(...) stringr::str_c(..., collapse = &quot;, &quot;) commas(letters[1:10]) #&gt; [1] &quot;a, b, c, d, e, f, g, h, i, j&quot; rule &lt;- function(..., pad = &quot;-&quot;) { title &lt;- paste0(...) width &lt;- getOption(&quot;width&quot;) - nchar(title) - 5 cat(title, &quot; &quot;, stringr::str_dup(pad, width), &quot;\\n&quot;, sep = &quot;&quot;) } rule(&quot;Important output&quot;) "],["返回值.html", "11.4 返回值", " 11.4 返回值 11.4.1 显式返回 函数返回的通常是最后一句代码的计算结果,可以显式利用return()提前返回。但是R for Data Science 中作者说: ‘我认为最好不要使用return()来表示,您可以使用更简单的解决方案尽早返回’ A common reason to do this is because the inputs are empty: complicated_function &lt;- function(x, y, z) { if (length(x) == 0 || length(y) == 0) { return(0) } # Complicated code here } Another reason is because you have a if statement with one complex block and one simple block. For example, you might write an if statement like this: f &lt;- function() { if (x) { # Do # something # that # takes # many # lines # to # express } else { # return something short } } 11.4.2 编写管道函数 管道函数有两种基本类型: transformations and side-effects。使用transformations时，会将对象传递到函数的第一个参数，然后返回修改后的对象。使用side-effects时,不会对传递的对象进行转换。相反，该函数对对象执行操作，例如绘制图或保存文件。副作用函数应该“无形地”返回第一个参数，以便在不打印它们时仍可以在管道中使用它们。例如，以下简单函数在数据框中打印缺失值的数量： 以上从 R for Data Science 中翻译得来。 show_missings &lt;- function(df) { n &lt;- sum(is.na(df)) cat(&quot;Missing values: &quot;, n, &quot;\\n&quot;, sep = &quot;&quot;) invisible(df) } 以交互invisible()方式调用它,则意味着输入df不会被打印出来: show_missings(mtcars) 但是结果仍存在，默认情况下只是不打印显示出来: x &lt;- show_missings(mtcars) class(x) dim(x) 在管道中继续使用 mtcars %&gt;% show_missings() %&gt;% mutate(mpg = ifelse(mpg &lt; 20, NA, mpg)) %&gt;% show_missings() "],["环境.html", "11.5 环境", " 11.5 环境 环境是复杂的,建议阅读原文. The last component of a function is its environment. This is not something you need to understand deeply when you first start writing functions. However, it’s important to know a little bit about environments because they are crucial to how functions work. The environment of a function controls how R finds the value associated with a name. For example, take this function: f &lt;- function(x) { x + y } 在很多其他的编程语言中这样定义函数是错误的，因为没有定义y.在R中,这是有效的代码,因为R使用称为lexical scoping的方式寻找关联值.在函数内部没有定义y,将在上一层环境中查看y: y &lt;- 100 f(10) y &lt;- 1000 f(10) 具体详细的资料请查阅： https://r4ds.had.co.nz/functions.html#environment http://adv-r.had.co.nz/ "],["拓展部分.html", "11.6 拓展部分", " 11.6 拓展部分 在我之前工作中遇到需要分组计算时,我想要编写一个函数实现某些功能,但是分组的group_by()字段不一样时,导致代码没办法复用。 参考资料：https://dplyr.tidyverse.org/articles/programming.html #library(tidyverse) mean_mpg = function(data, group_col) { data %&gt;% group_by(group_col) %&gt;% summarize(mean_mpg = mean(mpg)) } mtcars %&gt;% mean_mpg(cyl) mtcars %&gt;% mean_mpg(gear) 当编写如下函数时,代码将成功运行 #自定义函数 my_summarise3 &lt;- function(data, group_var,mean_var, sd_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } res1 &lt;- my_summarise3(data = mtcars,group_var = cyl,mean_var = carb,sd_var = gear) my_summarise3(data = mtcars,group_var = am,mean_var = carb,sd_var = gear) #正常写法 res2 &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarise(mean=mean(carb),sd=mean(gear)) identical(res1,res2) #res1 和res2 结果完全一致 以上my_summarise3()函数可以按照需求任意指定聚合汇总字段。 "]]
