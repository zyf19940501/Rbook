[["dplyr.html", "8 dplyr", " 8 dplyr dplyr包是tidyverse系列中的核心包之一,dplyr是A Grammar of Data Manipulation ，即dplyr是数据处理的语法。 与sql相比，用R实现相同功能的好处： 代码量极大减少 当逻辑复杂时，R可以按照顺序一步步实现，无需嵌套，实现过程简单 该包就是从数据库相关操作中抽象而来，迁移成本低 配合dbplyr包使用，大部分情况下可以扔掉sql语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用 本章节利用R语言完成与Excel透视表或sql语句的功能，将从行条件筛选、排序、分组聚合、表关联等方面记录R的实现方式。 本章节会照搬dplyr包中的部分案例 "],["前言.html", "8.1 前言", " 8.1 前言 数据操作在数据库中往往被增、改、删、查四字描述，加上表连接查询基本涵盖了大部分的数据库数据操作。在tidyverse系列中的dplyr包通过一组动词来解决相似数据操作动作。 在本章介绍部分，我们将拿R与Excel中的数据操作做类比，以达到Excel中透视表等功能。 8.1.1 安装 dplyr包可以直接安装。 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;dplyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/dplyr&quot;) 8.1.2 介绍 dplyr包提供一组动词来解决最常见的数据处理问题： mutate() 添加新变量,现有变量的函数 select() 筛选列,根据现有变量名称选择变量 filter() 筛选行，根据条件筛选 summarise() 按照一定条件汇总聚合 arrange() 行排序 以上动词都可以和group_by()结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过vignette(\"two-table\")查看学习。 Excel类比 类比Excel数据操作功能,filter实现筛选，mutate实现列计算，summarise配合group_by实现数据透视表，arrange实现排序功能。 另外配合dplyr::left_join()等表连接功能，实现Excel中的vlookup,xlookup等函数效果。 dplyr包中的动词可实现Excel中的大部分数据操作功能。 如下所示：筛选订单表中的1-5月订单数据，按照城市汇总，求每个城市的销售额和门店数(去重)。 data %&gt;% filter(between(月,1,5)) %&gt;% group_by(城市) %&gt;% summarise(金额 = sum(金额),门店数 = n_distinct(门店编码)) Cheat Sheet 手册搬运于dplyr官方介绍 dplyr-sheet Rstudio其它手册:https://www.rstudio.com/resources/cheatsheets/ "],["基础用法-2.html", "8.2 基础用法", " 8.2 基础用法 基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述dplyr动词功能。 8.2.1 加载包 #library(dplyr) # 禁掉提示 library(dplyr,warn.conflicts = FALSE) 8.2.2 filter filter动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和SQL中where条件一致。 filter条件筛选中可以分为单条件筛选和多条件筛选；多条件中间用,分隔。 单条件 条件为species == \"Droid\"时，如下所示： starwars %&gt;% filter(species == &quot;Droid&quot;) #&gt; # A tibble: 6 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculi~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none masculi~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none masculi~ #&gt; 4 IG-88 200 140 none metal red 15 none masculi~ #&gt; 5 R4-P17 96 NA none silver, red red, blue NA none feminine #&gt; 6 BB8 NA NA none none black NA none masculi~ #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species = &quot;Droid&quot; -- 注意=与==的区别 多条件 多条件筛选时，用英文逗号隔开多个条件。用“and”连接多个条件与用逗号隔开效果相同,“and”在R中用&amp;表示。 starwars %&gt;% filter(species == &quot;Droid&quot;,skin_color == &quot;gold&quot;) #&gt; # A tibble: 1 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculine #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; # same above # starwars %&gt;% # filter(species == &quot;Droid&quot; &amp; skin_color == &quot;gold&quot;) select * from starwars where species = &quot;Droid&quot; and skin_color = &quot;gold&quot; 多情况筛选 类似SQL中 in 的用法，或Excel中筛选条件时“或”条件 starwars %&gt;% filter(species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 7 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none mascu~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ #&gt; 4 IG-88 200 140 none metal red 15 none mascu~ #&gt; 5 Zam We~ 168 55 blonde fair, green~ yellow NA fema~ femin~ #&gt; 6 R4-P17 96 NA none silver, red red, blue NA none femin~ #&gt; # ... with 1 more row, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species in (&quot;Droid&quot;,&quot;Clawdite&quot;) --sql查询 逻辑关系筛选 条件运算分为逻辑运算、关系运算。 关系运算符 &gt;、&lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。 逻辑运算符 &amp;、|、！。 |为 或, &amp; 为并、且条件，!为非。 library(nycflights13) filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # same above filter(flights, arr_delay &lt;= 120 &amp; dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # %in% 的反面 starwars %&gt;% filter(!species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 80 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 3 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 4 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; 5 Beru Wh~ 165 75 brown light blue 47 fema~ femin~ #&gt; 6 Biggs D~ 183 84 black light brown 24 male mascu~ #&gt; # ... with 74 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; !的运算级别相比 %in% 更高 8.2.3 select 当完整数据集列数较多时，我们某次分析可能并不需要那么多列，通过动词select()筛选列 基础用法 通过指定列名称筛选，并指定列之间顺序 starwars %&gt;% select(name,height,mass,hair_color,skin_color,eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows 列索引 通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。 starwars %&gt;% select(name : eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows #same above starwars %&gt;% select(1:6) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows # starwars %&gt;% # select(c(1,2,4,5,7)) 8.2.4 rename 列重命名使用rename()函数，新名称写前面，如下所示： starwars %&gt;% rename(home_world = homeworld) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # 多列同换 starwars %&gt;% rename(home_world = homeworld,skincolor = skin_color) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skincolor eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * ,homeworld as home_word from starwars select * ,homeworld home_word from starwars as 可以省略，但中间有一个以上空格。与R的差异是新增home_word列，原始列继续存在，R中是替换列名。 8.2.5 relocate 更改列顺序，与使用select()动词指定列顺序功能相似。 参数 relocate(.data, ..., .before = NULL, .after = NULL) # sex:homeworld列在height列前面 starwars %&gt;% relocate(sex:homeworld, .before = height) #&gt; # A tibble: 87 x 14 #&gt; name sex gender homeworld height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ male mascul~ Tatooine 172 77 blond fair blue #&gt; 2 C-3PO none mascul~ Tatooine 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 none mascul~ Naboo 96 32 &lt;NA&gt; white, bl~ red #&gt; 4 Darth V~ male mascul~ Tatooine 202 136 none white yellow #&gt; 5 Leia Or~ female femini~ Alderaan 150 49 brown light brown #&gt; 6 Owen La~ male mascul~ Tatooine 178 120 brown, gr~ light blue #&gt; # ... with 81 more rows, and 5 more variables: birth_year &lt;dbl&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 8.2.6 mutate 动词mutate 新增计算列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% select(name:mass,bmi) #&gt; # A tibble: 87 x 4 #&gt; name height mass bmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 #&gt; 2 C-3PO 167 75 26.9 #&gt; 3 R2-D2 96 32 34.7 #&gt; 4 Darth Vader 202 136 33.3 #&gt; 5 Leia Organa 150 49 21.8 #&gt; 6 Owen Lars 178 120 37.9 #&gt; # ... with 81 more rows 新增计算列基础上新增列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2),newbmi = bmi *2) %&gt;% select(name:mass,bmi,newbmi) #&gt; # A tibble: 87 x 5 #&gt; name height mass bmi newbmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 52.1 #&gt; 2 C-3PO 167 75 26.9 53.8 #&gt; 3 R2-D2 96 32 34.7 69.4 #&gt; 4 Darth Vader 202 136 33.3 66.7 #&gt; 5 Leia Organa 150 49 21.8 43.6 #&gt; 6 Owen Lars 178 120 37.9 75.7 #&gt; # ... with 81 more rows 删除列 starwars %&gt;% mutate(height = NULL) #&gt; # A tibble: 87 x 13 #&gt; name mass hair_color skin_color eye_color birth_year sex gender homeworld #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke ~ 77 blond fair blue 19 male mascu~ Tatooine #&gt; 2 C-3PO 75 &lt;NA&gt; gold yellow 112 none mascu~ Tatooine #&gt; 3 R2-D2 32 &lt;NA&gt; white, bl~ red 33 none mascu~ Naboo #&gt; 4 Darth~ 136 none white yellow 41.9 male mascu~ Tatooine #&gt; 5 Leia ~ 49 brown light brown 19 fema~ femin~ Alderaan #&gt; 6 Owen ~ 120 brown, gr~ light blue 52 male mascu~ Tatooine #&gt; # ... with 81 more rows, and 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; 8.2.7 arrange 单列排序，默认升序，通过desc()降序排列 starwars %&gt;% arrange(desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Jabba ~ 175 1358 &lt;NA&gt; green-tan,~ orange 600 herm~ mascu~ #&gt; 2 Grievo~ 216 159 none brown, whi~ green, y~ NA male mascu~ #&gt; 3 IG-88 200 140 none metal red 15 none mascu~ #&gt; 4 Darth ~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Tarfful 234 136 brown brown blue NA male mascu~ #&gt; 6 Owen L~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 多列排序 starwars %&gt;% arrange(height,desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Yoda 66 17 white green brown 896 male mascu~ #&gt; 2 Ratts Ty~ 79 15 none grey, blue unknown NA male mascu~ #&gt; 3 Wicket S~ 88 20 brown brown brown 8 male mascu~ #&gt; 4 Dud Bolt 94 45 none blue, grey yellow NA male mascu~ #&gt; 5 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 6 R4-P17 96 NA none silver, r~ red, blue NA none femin~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars order by height,mass desc 8.2.8 summarise summarise常与group_by结合使用。 mtcars %&gt;% summarise(mean = mean(disp), n = n()) #&gt; mean n #&gt; 1 231 32 n()是dplyr包中的计算当前组的大小，用在summarise()和mutate()中。通常可用来组计算。 8.2.9 group_by 聚合前一般都需要分组，group_by()动词实现该功能，与SQL中group by ···类似。 starwars %&gt;% group_by(species) %&gt;% summarise( n = n(), mass = mean(mass, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n mass #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 15 #&gt; 2 Besalisk 1 102 #&gt; 3 Cerean 1 82 #&gt; 4 Chagrian 1 NaN #&gt; 5 Clawdite 1 55 #&gt; 6 Droid 6 69.8 #&gt; # ... with 32 more rows SELECT species, count(species) n, AVG(mass) mass FROM [spb].[dbo].[starwars] GROUP BY species "],["表操作.html", "8.3 表操作", " 8.3 表操作 指像sql中的left join,inner join等表格之间的操作，或者是Excel中Power Piovt建模的建立关系，从而实现不同表格间的关联 表格中的列操作，如列求和，均值等 行操作指不同字段间的计算，如Excle的列与列之间计算,Excle中的函数对行列不敏感，没有明显区别，但是R中tidyverse里列计算简单，行间计算依赖rowwise()函数实现 8.3.1 基础 left_join(),full_join,inner_join()等动词关联两个表。详情请查看：vignette(\"two-table\") left_join()实现类似Excel中VLOOKUP函数功能或数据库中left join功能，将“右表”的字段依据“主键”关联到“左表”上。 基础用法 left_join(),right_join(),full_join(),inner_join()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中连接方式一致。 默认会自动寻找两表中相同的字段名作为关联的条件 library(&quot;nycflights13&quot;) # Drop unimportant variables so it&#39;s easier to understand the join results. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% left_join(airlines) #&gt; Joining, by = &quot;carrier&quot; #&gt; # A tibble: 336,776 x 9 #&gt; year month day hour origin dest tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. #&gt; # ... with 336,770 more rows 指定关联条件列，类似数据库中on a.column = b.column flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) #&gt; # A tibble: 336,776 x 16 #&gt; year.x month day hour origin dest tailnum carrier year.y type #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing multi~ #&gt; 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing multi~ #&gt; 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing multi~ #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing multi~ #&gt; 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing multi~ #&gt; 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing multi~ #&gt; # ... with 336,770 more rows, and 6 more variables: manufacturer &lt;chr&gt;, #&gt; # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt; 不同名称列关联 left_join(x,y,by = c(\"a\" = \"b\", \"c\" = \"d\")) 将会匹配 x\\(a to y\\)b 和 x\\(c to y\\)d 作为关联条件 #出发机场和目的机场信息 flights2 %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 x 15 #&gt; year month day hour origin dest tailnum carrier name lat lon alt #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA George~ 30.0 -95.3 97 #&gt; 2 2013 1 1 5 LGA IAH N24211 UA George~ 30.0 -95.3 97 #&gt; 3 2013 1 1 5 JFK MIA N619AA AA Miami ~ 25.8 -80.3 8 #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 &lt;NA&gt; NA NA NA #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Hartsf~ 33.6 -84.4 1026 #&gt; 6 2013 1 1 5 EWR ORD N39463 UA Chicag~ 42.0 -87.9 668 #&gt; # ... with 336,770 more rows, and 3 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, #&gt; # tzone &lt;chr&gt; #flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) # 组合条件 多条件时用向量包裹即可c(&quot;dest&quot; = &quot;faa&quot;,&quot;cola&quot; = &quot;colb&quot;)) 筛选连接 anti_join() 删除所有左表中在右表中匹配到的行 semi_join()保留所有左表在右表中匹配到的行 df1 &lt;- tibble(a=letters[1:20],b=1:20) df2 &lt;- tibble(a=letters,b=1:26) df1 %&gt;% semi_join(df2) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 20 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 a 1 #&gt; 2 b 2 #&gt; 3 c 3 #&gt; 4 d 4 #&gt; 5 e 5 #&gt; 6 f 6 #&gt; # ... with 14 more rows df2 %&gt;% anti_join(df1) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 6 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 u 21 #&gt; 2 v 22 #&gt; 3 w 23 #&gt; 4 x 24 #&gt; 5 y 25 #&gt; 6 z 26 集合操作 intersect(x,y)返回x,y交集 union(x,y)返回x,y中唯一的值 setdiff(x,y)返回存在x中但是不存在y中的记录 (df1 &lt;- tibble(x = 1:2, y = c(1L, 1L))) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 (df2 &lt;- tibble(x = 1:2, y = 1:2)) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 2 intersect(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 union(df1, df2) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 2 2 setdiff(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 1 setdiff(df2, df1) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 2 8.3.2 多表操作 多表操作请使用purrr::reduce(),当需要合并多个表格时，可用以下方式减少合并代码量。 dt1 &lt;- data.frame(x = letters) dt2 &lt;- data.frame(x = letters,cola = 1:26) dt3 &lt;- data.frame(x = letters,colb = 1:26) dt4 &lt;- data.frame(x = letters,cold = 1:26) dt5 &lt;- data.frame(x = letters,cole = 1:26) dtlist &lt;- list(dt1,dt2,dt3,dt4,dt5) purrr::reduce(dtlist,left_join,by=&#39;x&#39;) #&gt; x cola colb cold cole #&gt; 1 a 1 1 1 1 #&gt; 2 b 2 2 2 2 #&gt; 3 c 3 3 3 3 #&gt; 4 d 4 4 4 4 #&gt; 5 e 5 5 5 5 #&gt; 6 f 6 6 6 6 #&gt; 7 g 7 7 7 7 #&gt; 8 h 8 8 8 8 #&gt; 9 i 9 9 9 9 #&gt; 10 j 10 10 10 10 #&gt; 11 k 11 11 11 11 #&gt; 12 l 12 12 12 12 #&gt; 13 m 13 13 13 13 #&gt; 14 n 14 14 14 14 #&gt; 15 o 15 15 15 15 #&gt; 16 p 16 16 16 16 #&gt; 17 q 17 17 17 17 #&gt; 18 r 18 18 18 18 #&gt; 19 s 19 19 19 19 #&gt; 20 t 20 20 20 20 #&gt; 21 u 21 21 21 21 #&gt; 22 v 22 22 22 22 #&gt; 23 w 23 23 23 23 #&gt; 24 x 24 24 24 24 #&gt; 25 y 25 25 25 25 #&gt; 26 z 26 26 26 26 "],["列操作.html", "8.4 列操作", " 8.4 列操作 在多列上执行相同的操作是常用的操作，但是通过复制和粘贴代码，麻烦不说还容易错： df %&gt;% group_by(g1, g2) %&gt;% summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d)) 通过across()函数可以更简洁地重写上面代码： df %&gt;% group_by(g1, g2) %&gt;% summarise(across(a:d, mean)) 8.4.1 基本操作 across() 有两个主要参数： 第一个参数，.cols选择要操作的列。它使用tidyr的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。 第二个参数，.fns是要应用于每一列的一个函数或函数列表。这也可以是purrr样式的公式（或公式列表），例如~ .x / 2。 starwars %&gt;% summarise(across(where(is.character), ~ length(unique(.x)))) #&gt; # A tibble: 1 x 8 #&gt; name hair_color skin_color eye_color sex gender homeworld species #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 87 13 31 15 5 3 49 38 # 列属性是字符的列求唯一值数 # starwars %&gt;% # summarise(length(unique(name))) # starwars %&gt;% # summarise(length(unique(hair_color))) starwars %&gt;% group_by(species) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(c(sex, gender, homeworld), ~ length(unique(.x)))) #&gt; # A tibble: 9 x 4 #&gt; species sex gender homeworld #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Droid 1 2 3 #&gt; 2 Gungan 1 1 1 #&gt; 3 Human 2 2 16 #&gt; 4 Kaminoan 2 2 1 #&gt; 5 Mirialan 1 1 1 #&gt; 6 Twi&#39;lek 2 2 1 #&gt; # ... with 3 more rows starwars %&gt;% group_by(homeworld) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) #&gt; # A tibble: 10 x 4 #&gt; homeworld height mass birth_year #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 176. 64 43 #&gt; 2 Corellia 175 78.5 25 #&gt; 3 Coruscant 174. 50 91 #&gt; 4 Kamino 208. 83.1 31.5 #&gt; 5 Kashyyyk 231 124 200 #&gt; 6 Mirial 168 53.1 49 #&gt; # ... with 4 more rows across() 不会选择分组变量： df &lt;- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9)) df %&gt;% group_by(g) %&gt;% summarise(across(where(is.numeric), sum)) #&gt; # A tibble: 2 x 3 #&gt; g x y #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 -5 #&gt; 2 2 3 -9 8.4.2 多种函数功能 通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量： min_max &lt;- list( min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE) ) starwars %&gt;% summarise(across(where(is.numeric), min_max)) #&gt; # A tibble: 1 x 6 #&gt; height_min height_max mass_min mass_max birth_year_min birth_year_max #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 通过.names参数控制名称： NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时 以下是官方图册中的案例，但是报错： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{.fn}.{.col}&quot;)) 修改后正常运行： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}.{col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; min.height max.height min.mass max.mass min.birth_year max.birth_year #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 区别主要是.names参数的使用方式问题，.加不加的问题。 starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}——{col}&quot;)) 8.4.3 当前列 如果需要，可以通过调用访问内部的“当前”列的名称cur_column()。 该函数不是特别容易理解，需要多尝试使用加深认识。 df &lt;- tibble(x = 1:3, y = 3:5, z = 5:7) mult &lt;- list(x = 1, y = 10, z = 100) df %&gt;% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]])) #&gt; # A tibble: 3 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 30 500 #&gt; 2 2 40 600 #&gt; 3 3 50 700 "],["行操作.html", "8.5 行操作", " 8.5 行操作 在操纵数据框中，dplyr等工具让我们对列操作相对简单，但是对行操作则困难些。 8.5.1 构造数据集 df &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() #&gt; # A tibble: 2 x 3 #&gt; # Rowwise: #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 #&gt; 2 2 4 6 像group_by(),rowwise()并没有做任何事情，它的作用是改变其他动词的工作方式： 比较以下代码中不的不同 df %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3.5 #&gt; 2 2 4 6 3.5 df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3 #&gt; 2 2 4 6 4 data.table中的操作: library(data.table) dt &lt;- data.table(x = 1:2, y = 3:4, z = 5:6) dt[,m:=mean(c(x,y,z))][] dt[,m:=mean(c(x,y,z)),by=.(x)][] 您可以选择在调用中提供“标识符”变量rowwise()。这些变量在您调用时被保留summarise()，因此它们的行为与传递给的分组变量有些相似group_by()： df &lt;- tibble(name = c(&quot;Mara&quot;, &quot;Hadley&quot;), x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has ungrouped output. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 1 #&gt; m #&gt; &lt;dbl&gt; #&gt; 1 3 #&gt; 2 4 df %&gt;% rowwise(name) %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has grouped output by &#39;name&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 2 #&gt; # Groups: name [2] #&gt; name m #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Mara 3 #&gt; 2 Hadley 4 8.5.2 行汇总统计 dplyr::summarise()使得汇总一列中各行的值非常容易。当与之结合使用时rowwise()，还可以轻松汇总一行中各列的值： df &lt;- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45) rf &lt;- df %&gt;% rowwise(id) rf %&gt;% mutate(total = sum(c(w, x, y, z))) #&gt; # A tibble: 6 x 6 #&gt; # Rowwise: id #&gt; id w x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 10 20 30 40 100 #&gt; 2 2 11 21 31 41 104 #&gt; 3 3 12 22 32 42 108 #&gt; 4 4 13 23 33 43 112 #&gt; 5 5 14 24 34 44 116 #&gt; 6 6 15 25 35 45 120 rf %&gt;% summarise(total = sum(c(w, x, y, z))) #&gt; `summarise()` has grouped output by &#39;id&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 6 x 2 #&gt; # Groups: id [6] #&gt; id total #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 100 #&gt; 2 2 104 #&gt; 3 3 108 #&gt; 4 4 112 #&gt; 5 5 116 #&gt; 6 6 120 键入每个变量名称很繁琐，通过c_across()使更简单 rf %&gt;% mutate(total = sum(c_across(w:z))) #&gt; # A tibble: 6 x 6 #&gt; # Rowwise: id #&gt; id w x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 10 20 30 40 100 #&gt; 2 2 11 21 31 41 104 #&gt; 3 3 12 22 32 42 108 #&gt; 4 4 13 23 33 43 112 #&gt; 5 5 14 24 34 44 116 #&gt; 6 6 15 25 35 45 120 rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) #&gt; # A tibble: 6 x 6 #&gt; # Rowwise: id #&gt; id w x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 10 20 30 40 100 #&gt; 2 2 11 21 31 41 104 #&gt; 3 3 12 22 32 42 108 #&gt; 4 4 13 23 33 43 112 #&gt; 5 5 14 24 34 44 116 #&gt; 6 6 15 25 35 45 120 rf %&gt;% mutate(total = sum(c_across(w:z))) %&gt;% ungroup() %&gt;% mutate(across(w:z, ~ . / total)) #&gt; # A tibble: 6 x 6 #&gt; id w x y z total #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 1 0.1 0.2 0.3 0.4 100 #&gt; 2 2 0.106 0.202 0.298 0.394 104 #&gt; 3 3 0.111 0.204 0.296 0.389 108 #&gt; 4 4 0.116 0.205 0.295 0.384 112 #&gt; 5 5 0.121 0.207 0.293 0.379 116 #&gt; 6 6 0.125 0.208 0.292 0.375 120 "],["分组操作.html", "8.6 分组操作", " 8.6 分组操作 详情: https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html group_by()最重要的分组动词,需要一个数据框和一个或多个变量进行分组： 8.6.1 添加分组 by_species &lt;- starwars %&gt;% group_by(species) by_sex_gender &lt;- starwars %&gt;% group_by(sex, gender) 除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在mutate()之后执行group_by: bmi_breaks &lt;- c(0, 18.5, 25, 30, Inf) starwars %&gt;% group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %&gt;% tally() #&gt; # A tibble: 5 x 2 #&gt; bmi_cat n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 (0,18.5] 10 #&gt; 2 (18.5,25] 24 #&gt; 3 (25,30] 13 #&gt; 4 (30,Inf] 12 #&gt; 5 &lt;NA&gt; 28 8.6.2 删除分组变量 要删除所有分组变量，使用ungroup(): by_species %&gt;% ungroup() %&gt;% tally() #&gt; # A tibble: 1 x 1 #&gt; n #&gt; &lt;int&gt; #&gt; 1 87 8.6.3 动词 summarise() 计算每个组的汇总，表示从group_keys开始右侧添加汇总变量 by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n height #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 79 #&gt; 2 Besalisk 1 198 #&gt; 3 Cerean 1 198 #&gt; 4 Chagrian 1 196 #&gt; 5 Clawdite 1 168 #&gt; 6 Droid 6 131. #&gt; # ... with 32 more rows 该.groups=参数控制输出的分组结构。删除右侧分组变量的历史行为对应于.groups = “drop_last”没有消息或.groups = NULL有消息（默认值）。 从1.0.0版开始，分组信息可以保留(.groups = \"keep\")或删除 (.groups = 'drop) a &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;drop&#39;) %&gt;% group_vars() b &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;keep&#39;) %&gt;% group_vars() object.size(a) #&gt; 48 bytes object.size(b) #&gt; 112 bytes 在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。 "],["常用函数-2.html", "8.7 常用函数", " 8.7 常用函数 8.7.1 条件判断 相比于base::ifelse,if_else更为严格，无论TRUE或FALSE输出类型一致，这样速度更快。与data.table::fifelse()功能相似。 if_else(condition, true, false, missing = NULL) 与ifelse不同的是，if_else保留类型 x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] NA NA NA NA 1 NA NA NA 2 3 if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; a &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; b c #&gt; Levels: a b c d e 8.7.2 case_when 当条件嵌套条件较多时，使用case_when,使代码可读并且不易出错。与sql 中的case when 等价。 Dates &lt;- as.Date(c(&#39;2018-10-01&#39;, &#39;2018-10-02&#39;, &#39;2018-10-03&#39;)) case_when( Dates == &#39;2018-10-01&#39; ~ Dates - 1, Dates == &#39;2018-10-02&#39; ~ Dates + 1, Dates == &#39;2018-10-03&#39; ~ Dates + 2, TRUE ~ Dates ) #&gt; [1] &quot;2018-09-30&quot; &quot;2018-10-03&quot; &quot;2018-10-05&quot; 8.7.3 计数函数 计数 count()函数用来计数。下面两种表达方式等价。 df %&gt;% count(a, b) # same above df %&gt;% group_by(a, b) %&gt;% summarise(n = n()) starwars %&gt;% count(species) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows # same above 等价 starwars %&gt;% group_by(species) %&gt;% summarise(n = n()) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows 非重复计数 n_distinct()与length(unique(x))等价，但是更快更简洁。当我们需要给门店或订单之类数据需要去重计算时采用该函数。 x &lt;- sample(1:10, 1e5, rep = TRUE) length(unique(x)) #&gt; [1] 10 n_distinct(x) #&gt; [1] 10 8.7.4 排序函数 dplyr共六种排序函数，模仿SQL2003中的排名函数。 row_number():等于 rank(ties.method = “first”) min_rank(): 等于 rank(ties.method = “min”) dense_rank(): 与min_rank()相似,但是没有间隔 percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1] x &lt;- c(5, 1, 3, 2, 2, NA) row_number(x) #&gt; [1] 5 1 4 2 3 NA min_rank(x) #&gt; [1] 5 1 4 2 2 NA dense_rank(x) #&gt; [1] 4 1 3 2 2 NA percent_rank(x) #&gt; [1] 1.00 0.00 0.75 0.25 0.25 NA cume_dist(x) #&gt; [1] 1.0 0.2 0.8 0.6 0.6 NA 8.7.5 提取向量 该系列函数是对[[的包装。 nth(x, n, order_by = NULL, default = default_missing(x)) first(x, order_by = NULL, default = default_missing(x)) last(x, order_by = NULL, default = default_missing(x)) x &lt;- 1:10 y &lt;- 10:1 first(x) #&gt; [1] 1 last(y) #&gt; [1] 1 nth(x, 1) #&gt; [1] 1 nth(x, 5) #&gt; [1] 5 8.7.6 group 系列 group_by(),group_map(), group_nest(), group_split(), group_trim()等一系列函数。 其中我常用group_by(),group_split()两个函数。group_by()是大部分数据操作中的分组操作，按照group_by()的指定分组条件。 group_by() #group_by()不会改变数据框 by_cyl &lt;- mtcars %&gt;% group_by(cyl) by_cyl #&gt; # A tibble: 32 x 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows # It changes how it acts with the other dplyr verbs: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) #&gt; # A tibble: 3 x 3 #&gt; cyl disp hp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 105. 82.6 #&gt; 2 6 183. 122. #&gt; 3 8 353. 209. # group_by中可以添加计算字段 即mutate操作 mtcars %&gt;% group_by(vsam = vs + am) %&gt;% group_vars() #&gt; [1] &quot;vsam&quot; group_map() group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据库的数据清洗一般不涉及，常用在建模等方面。 但是目前三个函数是实验性的，未来可能会发生变化。 # return a list # 返回列表 mtcars %&gt;% group_by(cyl) %&gt;% group_map(~ head(.x, 2L)) #&gt; [[1]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 22.8 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; #&gt; [[2]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; #&gt; [[3]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 18.7 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 2 14.3 360 245 3.21 3.57 15.8 0 0 3 4 iris %&gt;% group_by(Species) %&gt;% group_modify(~ { .x %&gt;% purrr::map_dfc(fivenum) %&gt;% mutate(nms = c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;)) }) #&gt; # A tibble: 15 x 6 #&gt; # Groups: Species [3] #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width nms #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 setosa 4.3 2.3 1 0.1 min #&gt; 2 setosa 4.8 3.2 1.4 0.2 Q1 #&gt; 3 setosa 5 3.4 1.5 0.2 median #&gt; 4 setosa 5.2 3.7 1.6 0.3 Q3 #&gt; 5 setosa 5.8 4.4 1.9 0.6 max #&gt; 6 versicolor 4.9 2 3 1 min #&gt; # ... with 9 more rows # group_walk dir.create(temp &lt;- tempfile()) iris %&gt;% group_by(Species) %&gt;% group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, &quot;.csv&quot;)))) list.files(temp, pattern = &quot;csv$&quot;) unlink(temp, recursive = TRUE) group_cols() 选择分组变量 gdf &lt;- iris %&gt;% group_by(Species) gdf %&gt;% select(group_cols()) #&gt; # A tibble: 150 x 1 #&gt; # Groups: Species [3] #&gt; Species #&gt; &lt;fct&gt; #&gt; 1 setosa #&gt; 2 setosa #&gt; 3 setosa #&gt; 4 setosa #&gt; 5 setosa #&gt; 6 setosa #&gt; # ... with 144 more rows 8.7.7 其它函数 between cummean cumsum cumall cumany 累计系列函数 x &lt;- c(1, 3, 5, 2, 2) cummean(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumsum(x) / seq_along(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumall(x &lt; 5) #&gt; [1] TRUE TRUE FALSE FALSE FALSE cumany(x == 3) #&gt; [1] FALSE TRUE TRUE TRUE TRUE distinct df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) distinct(df, x) distinct(df, x, .keep_all = TRUE) distinct(df, diff = abs(x - y)) "],["用dplyr编程.html", "8.8 用dplyr编程", " 8.8 用dplyr编程 Programming with dplyr: https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html 本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。 虽然复杂但是比较实用，尤其是当我们需要定义一些通用功能函数时 以下是对原文引用 两种情况： When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like filter(df, {{ var }}). The following function uses embracing to create a wrapper around summarise() that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised: var_summary &lt;- function(data, var) { data %&gt;% summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])). The following example uses .data to count the number of unique values in each variable of mtcars: for (var in names(mtcars)) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with .data$x or indirectly with .data[[var]]. Don’t expect other functions to work with it. 8.8.1 案例 当我们不知道接下来会用哪个变量汇总时： my_summarise &lt;- function(data, group_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean(mass)) } 如果在多个位置使用： my_summarise2 &lt;- function(data, expr) { data %&gt;% summarise( mean = mean({{ expr }}), sum = sum({{ expr }}), n = n() ) } 当多个表达式时： my_summarise3 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } 如果要输出变量名时： my_summarise4 &lt;- function(data, expr) { data %&gt;% summarise( &quot;mean_{{expr}}&quot; := mean({{ expr }}), &quot;sum_{{expr}}&quot; := sum({{ expr }}), &quot;n_{{expr}}&quot; := n() ) } my_summarise5 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise( &quot;mean_{{mean_var}}&quot; := mean({{ mean_var }}), &quot;sd_{{sd_var}}&quot; := mean({{ sd_var }}) ) } 任意个表达式： 这种使用场景更多 my_summarise &lt;- function(.data, ...) { .data %&gt;% group_by(...) %&gt;% summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE)) } starwars %&gt;% my_summarise(homeworld) #&gt; # A tibble: 49 x 3 #&gt; homeworld mass height #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 64 176. #&gt; 2 Aleen Minor 15 79 #&gt; 3 Bespin 79 175 #&gt; 4 Bestine IV 110 180 #&gt; 5 Cato Neimoidia 90 191 #&gt; 6 Cerea 82 198 #&gt; # ... with 43 more rows starwars %&gt;% my_summarise(sex, gender) #&gt; `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 6 x 4 #&gt; # Groups: sex [5] #&gt; sex gender mass height #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 female feminine 54.7 169. #&gt; 2 hermaphroditic masculine 1358 175 #&gt; 3 male masculine 81.0 179. #&gt; 4 none feminine NaN 96 #&gt; 5 none masculine 69.8 140 #&gt; 6 &lt;NA&gt; &lt;NA&gt; 48 181. "]]
