[["data-read-write-description.html", "1 数据导入导出", " 1 数据导入导出 作为一名普通的数据分析师，我日常接触最多的数据是业务系统中的销售订单表、商品库存表、会员信息表，门店信息表，商品信息表等之类的业务表，但最初接触R时，看到的演示代码以及数据集大部分都是R包中内置的数据集，没有很明确操作数据的意义，没有代入感。在刚开始学习使用R做数据处理后，我就想使用自己的数据集来操作数据，用R去实现Excel的透视表或sql功能。这时就首先需要将原始数据导入1R中。 现实生活中数据来源复杂，商业环境中数据源同样具有多样性，如SAP,不同的数据库、OA系统、EXCEL手工文件等;我们想要统一数据做分析，就需要将不同的数据源整合导入R中。 我们从读取方式简单区分为本地文件数据、数据库数据，本章主要说明常用的Excel文件和csv2、txt等文本文件的读写方式。关于数据库的数据的读取，可以参照后续database章节。 相信大家随便使用搜索引擎搜索诸如“将Excel导入R”的关键词都能得到一些行之有效的方法，但是不够系统全面。本章主要简述R中数据导入导出的相关R包，如readxl,writexl,openxlsx,readr, vroom等主要处理csv或Excel的R包。 当有其它数据格式需求的时候，那时候的你肯定已经会自行查找相关R包使用了。 在本章开始前，假定已经有一些R相关基础。如使用Rstudio查看导入的数据，R的数据结构等有一定认识。本章节主要分为: excel读写 csv等平面文件读写 文件路径 由于R是将数据加载至内存中，故数据集大小超过内存大小将导入失败。↩︎ csv即Comma-Separated Values，逗号分隔值，分隔符也可是不是逗号。 csv文件是一种以纯文本形式存储的表格数据,可以通过记事本打开。与Excel不同的是，CSV是一种文本格式，也不受Excel最大行数(1048576)限制。 csv文件也被称作平面文件，结构简单，平面文件比结构文件占用更少的空间；平面文件在数据仓库项目中广泛用于导入数据。↩︎ "],["readxl-description.html", "1.1 readxl", " 1.1 readxl readxl软件包使R获取Excel数据变得方便简洁。与现有的软件包(例如：xlsx)相比，readxl没有外部依赖性，xlsx等包依赖java环境。readxl包容易在所有的操作系统安装使用。 readxl项目地址，本节大部分代码来源项目官网介绍，可自行查阅官网。 1.1.1 安装 从CRAN安装最新发行版本的最简单方法是安装整个tidyverse。 install.packages(&quot;tidyverse&quot;) 由于readxl不是tidyverse核心加载包，使用时仅需加载library(readxl) 或者是从CRAN仅安装readxl; install.packages(&quot;readxl&quot;) 从github安装开发版： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readxl&quot;) 1.1.2 用法 readxl包的核心函数是读取函数read_excel()，该函数能将Excel文件数据加载到R中。readxl包中包含了几个示例文件，我们在接下来的案例中使用。 1.读取 通过readxl_example()查看readxl包中自带xlsx文件。 library(readxl) readxl_example() #&gt; [1] &quot;clippy.xls&quot; &quot;clippy.xlsx&quot; &quot;datasets.xls&quot; &quot;datasets.xlsx&quot; #&gt; [5] &quot;deaths.xls&quot; &quot;deaths.xlsx&quot; &quot;geometry.xls&quot; &quot;geometry.xlsx&quot; #&gt; [9] &quot;type-me.xls&quot; &quot;type-me.xlsx&quot; readxl_example(&quot;clippy.xls&quot;) #&gt; [1] &quot;/Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library/readxl/extdata/clippy.xls&quot; 需要注意read_excel()可读取xls和xlsx文件，函数会自动识别。 xls和xlsx的区别: xls 是 excel2003 及以前版本生成的文件格式，而 xlsx 是 excel2007 及以后版本生成的文件格式。xlsx格式是向下兼容的，可兼容xls格式。老旧的业务使用的格式可能是xls格式。 xlsx_example &lt;- readxl_example(&quot;datasets.xlsx&quot;) #返回datasets.xlsx文件所在路径 dt &lt;- read_excel(xlsx_example) 查看数据 head(dt) #&gt; # A tibble: 6 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa 将Excel中的数据通过read_excel()读取保存到R中，该对象属于tbl_df类，是tidyverse系列的数据框结构，是对base R中的data.frame结构的改造，但是兼容data.frame。 # 查看dt类 class(dt) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # 查看数据类型 str(dt) #&gt; tibble [150 × 5] (S3: tbl_df/tbl/data.frame) #&gt; $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : chr [1:150] &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; ... 关于tbl_df类，可以查阅vignette(\"tibble\")。 2.指定sheet读取 通过函数excel_sheets()查看Excel的sheet名称 excel_sheets(xlsx_example) #&gt; [1] &quot;iris&quot; &quot;mtcars&quot; &quot;chickwts&quot; &quot;quakes&quot; 当我们要读取Excel文件有多个sheets时，通过指定sheet参数,读取指定的sheet，sheet参数可以是sheet的名称或顺序号。 read_excel(xlsx_example, sheet = &quot;chickwts&quot;) #&gt; # A tibble: 71 x 2 #&gt; weight feed #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 179 horsebean #&gt; 2 160 horsebean #&gt; 3 136 horsebean #&gt; 4 227 horsebean #&gt; 5 217 horsebean #&gt; 6 168 horsebean #&gt; # … with 65 more rows # not run #read_excel(xlsx_example, sheet = 1) #read_excel(xlsx_example, sheet = 3) 3.指定读取范围 读取Excel文件指定范围。read_excel()中range参数接受单元格范围，最简单的表示方式即Excle中单元格表示方法,如 range = “D12:F15” or range = “R1C12:R6C15”。 read_excel(xlsx_example, sheet = &quot;iris&quot;) #&gt; # A tibble: 150 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; # … with 144 more rows dt1 &lt;- read_excel(xlsx_example, sheet = &quot;iris&quot;,range = &#39;a1:e6&#39;) dt2 &lt;- read_excel(xlsx_example, sheet = &quot;iris&quot;,range = &#39;R1C1:R6C5&#39;) # dt1 dt2 是否相等 identical(dt1,dt2) #&gt; [1] TRUE 4.read_excel参数 readxl::read_excel参数如下,请?read_excel()查看参数。 read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot;) read_excel参数 解释 path xls或xlsx文件的路径 sheet 默认是第一个sheet，可以是数字或sheet的名称 range Excel中表示范围的字符，或者通过cell_类方法指定 col_name 默认为TRUE,用第一行做列名;或者用默认名称,或者指定列名 col_types 默认为NULL，猜测各列类型，可指定各列的类型 trim_ws 默认去掉表头字段中两边的空格 skip 读取之前要跳过的行数，默认为空 n_max 读取的最大行数 guess_max 猜测列类型的最大行数,默认为1000 progress 读取过程是否显示进度 .name_repair 自动处理列名，避免列名不为空以及不重复 col_types 参数个人觉得比较重要，可以指定列的类型，可以避免一些错误。可用选项:“skip,” “guess,” “logical,” “numeric,” “date,” “text” or “list”。 .name_repair 参数能自动避免重复字段，可避免手工Excel出现字段名不唯一的情况。 1.1.3 批量读取 实际工作中，某文件夹下有相同格式的Excel文件(sheet名称以及列字段相同)，想要合并全部Excel数据，熟悉Excel的可以通过Excel的power query的获取数据完成合并，那么在R中该如何实现呢？ 示例： 文件夹内 excel 文件 #&gt; data/read-write/ #&gt; ├── a.xlsx #&gt; ├── b.xlsx #&gt; └── 批量读写.xlsx R代码如下 allfiles &lt;- list.files(path = &#39;./data/read-write/&#39;,pattern = &#39;.xlsx$&#39;,full.names = T) # 使用purrr包合并读取 purrr::map_dfr(allfiles,read_excel) list.files()函数按照规则返回某文件目录下的全部文件。关于R语言中文件系统操作可以查看章节R语言文件系统操作 1.1.4 批量输出 我们按照一定条件拆解数据集，分别输出，代码如下： library(tidyverse) #&gt; ─ Attaching packages ──────────────────── tidyverse 1.3.1 ─ #&gt; ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.1.2 ✓ dplyr 1.0.6 #&gt; ✓ tidyr 1.1.3 ✓ stringr 1.4.0 #&gt; ✓ readr 1.4.0 ✓ forcats 0.5.1 #&gt; ─ Conflicts ───────────────────── tidyverse_conflicts() ─ #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() library(readxl) dt &lt;- read_xlsx(path = &#39;./data/read-write/批量读写.xlsx&#39;) dt %&gt;% group_by(name) %&gt;% group_walk(~ write.csv(.x,file = file.path(&#39;data/read-write&#39;,paste0(.y$name,&#39;.csv&#39;)))) list.files(path = &#39;data/read-write/&#39;) #&gt; [1] &quot;批量读写.xlsx&quot; &quot;a.csv&quot; &quot;a.xlsx&quot; &quot;b.csv&quot; #&gt; [5] &quot;b.xlsx&quot; &quot;d.csv&quot; &quot;Id-card-data.csv&quot; 暂时不用理解批量读取和输出的代码具体含义，可以先记住用法。 "],["writexl.html", "1.2 writexl", " 1.2 writexl 截止到2021年5月17日，writexl包功能比较简单，仅有输出Excel功能。快速、不依赖java和Excle是它绝对的优势，并且输出文件相比openxlsx包较小。 项目地址 1.2.1 用法 1.安装 从CRAN安装发行版 install.packages(&quot;writexl&quot;) 2.函数参数 write_xlsx()函数参数如下： write_xlsx( x, path = tempfile(fileext = &quot;.xlsx&quot;), col_names = TRUE, format_headers = TRUE, use_zip64 = FALSE ) write_xlsx参数 解释 x 要输出的数据框和数据框列表 path 输出Excel的文件名称 col_names 是否输出表头，默认为TRUE format_headers 是否将表头居中并加粗，默认为TRUE use_zip64 是否支持4Gb文件大小，不是所有的系统都支持 use_zip64:不确定该参数的理解是否正确，请自行阅读官方文档，绝大部分时候不用理解该参数。 3.输出Excel write_xlsx()函数将数据框保存到Excel。如想要输出多个sheet时，用list(mysheet1 = iris,mysheet2 = iris)表示即可，代码如下： library(writexl) writexl::write_xlsx(iris,path = &#39;iris.xlsx&#39;) # 输出多sheet write_xlsx(list(mysheet1 = iris,mysheet2 = iris),path = &#39;iris.xlsx&#39;) 4.效率比较 和openxlsx包比较输出效率。 library(microbenchmark) library(nycflights13) microbenchmark( writexl = writexl::write_xlsx(flights, tempfile()), openxlsx = openxlsx::write.xlsx(flights, tempfile()), times = 2 ) 5.文件大小比较 和openxlsx包比较输出后的Excel文件大小。 library(nycflights13) writexl::write_xlsx(flights, tmp1 &lt;- tempfile()) file.info(tmp1)$size #&gt; [1] 29139353 openxlsx::write.xlsx(flights, tmp2 &lt;- tempfile()) file.info(tmp2)$size #&gt; [1] 26833692 按照writexl官方文档的说法，writexl输出的Excel文件应该较少，但实际上并不是，不确定是不是openxlsx更新优化过。 6.其它功能 Excel 公式以及超级链接格式。 df &lt;- data.frame( name = c(&quot;UCLA&quot;, &quot;Berkeley&quot;, &quot;Jeroen&quot;), founded = c(1919, 1868, 2030), website = xl_hyperlink(c(&quot;http://www.ucla.edu&quot;, &quot;http://www.berkeley.edu&quot;, NA), &quot;homepage&quot;) ) df$age &lt;- xl_formula(&#39;=(YEAR(TODAY()) - INDIRECT(&quot;B&quot; &amp; ROW()))&#39;) write_xlsx(df, &#39;universities.xlsx&#39;) # cleanup unlink(&#39;universities.xlsx&#39;) 当需要输出大型Excel文件时，比如超过50万行，我会采用writexl包输出。但是在曾经使用过程中，定时任务采用writexl包输出Excel有时会报错，感觉不稳定，原因不明。现在一般临时性的输出我会采用writexl包，定时任务中采用openxlsx "],["openxlsx-description.html", "1.3 openxlsx", " 1.3 openxlsx openxlsx是当我需要定制输出Excel表格或报表时常用R包。目前该包的版本4.2.3，通过使用Rcpp加速，包的读写速度在Excel的百万级下是可接受状态，包的相关函数功能完善且简易好用，并且正在积极开发中，相信它以后功能会越来越强大。 项目官方地址:https://ycphs.github.io/openxlsx/index.html openxlsx主要优势： 不依赖java环境 读写速度可接受 可设置条件格式，与Excel中『开始』选项卡的条件格式功能接近 可批量插入ggplot2图 可插入公式 可渲染大部分Excel格式，并且效率相比部分python包高效 可添加页眉页脚以及其他格式，方便直接打印 功能稳定可用并且在积极开发中 版本信息查看 packageVersion(&quot;openxlsx&quot;) #&gt; [1] &#39;4.2.3&#39; 关于openxlsx更加详细的阐述:https://mp.weixin.qq.com/s/ZD0dJb0y8fsWGI1dCPh2mQ 1.3.1 安装 从CRAN安装发行版 # 稳定版 install.packages(&quot;openxlsx&quot;, dependencies = TRUE, repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;) 从Github安装开发版 install.packages(c(&quot;Rcpp&quot;, &quot;devtools&quot;), dependencies = TRUE) library(devtools) install_github(&quot;ycphs/openxlsx&quot;) 1.3.2 基础功能 本文仅呈现基础功能部分，即读写EXCEL文件。其它功能，请查阅项目官方地址或微信公众号文章R包-openxlsx-学习笔记 1.3.2.1 读取Excel read.xlsx()函数读取Excel文件。 library(openxlsx) read.xlsx(&#39;./data/read-write/批量读写.xlsx&#39;) #&gt; name num #&gt; 1 a 1 #&gt; 2 a 2 #&gt; 3 a 3 #&gt; 4 b 4 #&gt; 5 b 5 #&gt; 6 b 6 #&gt; 7 d 7 #&gt; 8 d 8 #&gt; 9 d 9 read.xlsx()参数如下： library(openxlsx) read.xlsx( xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = &quot;.&quot;, namedRegion = NULL, na.strings = &quot;NA&quot;, fillMergedCells = FALSE ) 以上参数中需要注意：detecDates参数，当你的Excel表格中带日期列时需要将参数设置为TRUE,不然将会把日期识别为数字读入。 fillMergedCells参数，当你读取的表格中存在合并单元格，将用值填充其他全部单元格,如下所示： merge-cell read.xlsx(&#39;./test.xlsx&#39;,detectDates = TRUE,fillMergedCells = TRUE) 读取后如下所示： openxlsx-merge-xlsx readWorkbook()也可以读取Excel表格数据，参数与read.xlsx基本一致。 xlsxFile &lt;- system.file(&quot;extdata&quot;, &quot;readTest.xlsx&quot;, package = &quot;openxlsx&quot;) df1 &lt;- readWorkbook(xlsxFile = xlsxFile, sheet = 1) 1.3.2.2 写入Excel 数据清洗完之后，或者是透视表已经完成，需要将结果从R导出到Excle，这时就利用函数将结果数据集写入Excle中。 write.xlsx()函数写入 write.xlsx(iris, file = &quot;writeXLSX1.xlsx&quot;, colNames = TRUE, borders = &quot;columns&quot;) 带格式输出 hs &lt;- createStyle( textDecoration = &quot;BOLD&quot;, fontColour = &quot;#FFFFFF&quot;, fontSize = 12, fontName = &quot;Arial Narrow&quot;, fgFill = &quot;#4F80BD&quot; ) ## Not run: write.xlsx(iris, file = &quot;writeXLSX3.xlsx&quot;, colNames = TRUE, borders = &quot;rows&quot;, headerStyle = hs ) #4F80BD格式属于十六进制颜色码。 1.3.3 定制格式输出 openxlsx包有两套输出函数，wrire.xlsx()是其中一种，还有如下一种。 输出过程共分为四步，第一步创建workbook,第二步添加sheet,第三步写入数据，第四步保存workbook。在输出的过程中可以通过addStyle()、createStyle()或conditionalFormatting添加格式或条件格式。 df &lt;- data.frame(a=1:10,b=1:10,d=1:10) wb &lt;- createWorkbook(creator = &#39;zhongyf&#39;,title = &#39;test&#39;) addWorksheet(wb,sheetName = &#39;test&#39;) writeDataTable(wb,sheet = &#39;test&#39;,x = df) saveWorkbook(wb, &quot;test.xlsx&quot;, overwrite = TRUE) 我们以上面四步输出的方式，查看包自带的例子。 createWorkbook() addWorksheet() writeDataTable() saveWorkbook() wb &lt;- createWorkbook(&quot;Fred&quot;) ## Add 3 worksheets addWorksheet(wb, &quot;Sheet 1&quot;) addWorksheet(wb, &quot;Sheet 2&quot;, gridLines = FALSE) addWorksheet(wb, &quot;Sheet 3&quot;, tabColour = &quot;red&quot;) addWorksheet(wb, &quot;Sheet 4&quot;, gridLines = FALSE, tabColour = &quot;#4F81BD&quot;) ## Headers and Footers addWorksheet(wb, &quot;Sheet 5&quot;, header = c(&quot;ODD HEAD LEFT&quot;, &quot;ODD HEAD CENTER&quot;, &quot;ODD HEAD RIGHT&quot;), footer = c(&quot;ODD FOOT RIGHT&quot;, &quot;ODD FOOT CENTER&quot;, &quot;ODD FOOT RIGHT&quot;), evenHeader = c(&quot;EVEN HEAD LEFT&quot;, &quot;EVEN HEAD CENTER&quot;, &quot;EVEN HEAD RIGHT&quot;), evenFooter = c(&quot;EVEN FOOT RIGHT&quot;, &quot;EVEN FOOT CENTER&quot;, &quot;EVEN FOOT RIGHT&quot;), firstHeader = c(&quot;TOP&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;), firstFooter = c(&quot;BOTTOM&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;) ) addWorksheet(wb, &quot;Sheet 6&quot;, header = c(&quot;&amp;[Date]&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;&amp;[Page] / &amp;[Pages]&quot;), footer = c(&quot;&amp;[Path]&amp;[File]&quot;, NA, &quot;&amp;[Tab]&quot;), firstHeader = c(NA, &quot;Center Header of First Page&quot;, NA), firstFooter = c(NA, &quot;Center Footer of First Page&quot;, NA) ) addWorksheet(wb, &quot;Sheet 7&quot;, header = c(&quot;ALL HEAD LEFT 2&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;ALL HEAD RIGHT 2&quot;), footer = c(&quot;ALL FOOT RIGHT 2&quot;, &quot;ALL FOOT CENTER 2&quot;, &quot;ALL FOOT RIGHT 2&quot;) ) addWorksheet(wb, &quot;Sheet 8&quot;, firstHeader = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;), firstFooter = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;) ) addWorksheet(wb,&#39;dataframe&#39;) ## Need data on worksheet to see all headers and footers writeData(wb, sheet = 5, 1:400) writeData(wb, sheet = 6, 1:400) writeData(wb, sheet = 7, 1:400) writeData(wb, sheet = 8, 1:400) writeDataTable(wb,sheet = &#39;dataframe&#39;,iris) ## Save workbook ## Not run: saveWorkbook(wb, &quot;addWorksheetExample.xlsx&quot;, overwrite = TRUE) 1.3.4 函数参数 本小节主要讲createWorkbook()，addWorksheet(),writeDataTable(),saveWorkbook()四个函数的参数以及用法。 createWorkbook createWorkbook( creator = ifelse(.Platform$OS.type == &quot;windows&quot;, Sys.getenv(&quot;USERNAME&quot;), Sys.getenv(&quot;USER&quot;)), title = NULL, subject = NULL, category = NULL ) wb &lt;- createWorkbook( creator = &quot;宇飞的世界&quot;, title = &quot;标题&quot;, subject = &quot;主题&quot;, category = &quot;类别目录&quot; ) addWorksheet addWorksheet()函数添加sheet。 addWorksheet( wb, sheetName, gridLines = TRUE, tabColour = NULL, zoom = 100, header = NULL, footer = NULL, evenHeader = NULL, evenFooter = NULL, firstHeader = NULL, firstFooter = NULL, visible = TRUE, paperSize = getOption(&quot;openxlsx.paperSize&quot;, default = 9), orientation = getOption(&quot;openxlsx.orientation&quot;, default = &quot;portrait&quot;), vdpi = getOption(&quot;openxlsx.vdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)), hdpi = getOption(&quot;openxlsx.hdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)) ) addWorksheet()参数解释如下： gridLines参数：表格中是否有网格线，在Excle『视图』选项卡下面的网格线去除打勾的效果一致 tabColour参数：输出表格sheet标签颜色 zoom：发大缩小，默认是100，可选范围10-400 header:页眉 长度为3的字符向量，左、中、右三个位置，用Na可跳过一位置，以下页眉页脚相同。 footer: 页脚 evenHeader: 每页页眉 evenFooter: 每页页脚 firstHeader: 第一页页眉 firstFooter: 第一页页脚 visible:sheet是否隐藏，如果为否sheet将被隐藏 paperSize:页面大小,详见 ?pageSetup orientation:One of &quot;portrait&quot; or &quot;landscape&quot; 不清楚干嘛用 vdpi: 屏幕分辨率 默认值即可，不用调整 hdpi: 屏幕分辨率 默认值即可，不用调整 writeDataTable writeDataTable()函数将data.frame写入Excel。 writeDataTable( wb, sheet, x, startCol = 1, startRow = 1, xy = NULL, colNames = TRUE, rowNames = FALSE, tableStyle = &quot;TableStyleLight9&quot;, tableName = NULL, headerStyle = NULL, withFilter = TRUE, keepNA = FALSE, na.string = NULL, sep = &quot;, &quot;, stack = FALSE, firstColumn = FALSE, lastColumn = FALSE, bandedRows = TRUE, bandedCols = FALSE ) writeDataTable()参数解释如下： wb:即createWorkbook()函数创建的workbook对象 sheet:将输入写入的sheet名，由addWorksheet()函数创建 x : a data.frame startCol: 从哪一列开始写入,接受数字 startRow：从哪一行开始写入，接受数字 xy: 指定开始行以及开始列的向量，xy = c(2,3)即从2列3行位置开始写入 colNames: 如果TRUE,列名写入 rowNames: 如果TRUE,行名写入 tableStyle:一些表格样式，在中文版Excle『开始』选项卡下面的套用表格格式，可以使用预定义的表格样式 tableName:workbook中的表中，表名必须是唯一的，熟悉Power Pivot的人应该很清晰“表”概念 headerStyle:自定义列样式应用,用createStyle()函数创建 withFilter: 在第一行是否由筛选 keepNA:如果TRUE,NA值转化为#NA，如果否，变为空 na.string :如果参数不是NULL,如果keepNA是TRUE,NA将会在Excel中转为该参数指定的字符 sep： stack :请参照函数使用 firstColumn:logical. If TRUE, the first column is bold lastColumn :logical. If TRUE, the last column is bold bandedRows:logical. If TRUE, rows are colour banded 即行线,默认为TRUE bandedCols:logical. If TRUE, the columns are colour banded 即列线 ,默认为TRUE saveWorkbook saveWorkbook(wb, file, overwrite = FALSE, returnValue = FALSE) 参数较为简单，wb即上文中的workbook对象，file即输出的文件名，overwrite即如果存在是否覆盖，returnValue如果设置为TRUE，返回TRUE代表保存成功 1.3.5 总结 openxlsx包功能较为强大，更多详细用法大家可自行探索，或关注我的语雀笔记，笔记会不定期持续更新。 R包openxlsx学习笔记:https://www.yuque.com/docs/share/7a768e6f-95e0-417c-a9b5-dfc8862dc6be?# 语雀个人主页:https://www.yuque.com/zyufei "],["readr-package.html", "1.4 readr", " 1.4 readr readr提供了一种快速友好的方式读取矩形数据3(如：csv,tsv,fwf)，且当读取大型数据集时默认有进度条显示。 如果对readr包不熟悉，可以直接阅读包作者，大神Hadley Wickham的书R for data science 中data import chapter章节。 1.4.1 安装 由于readr包是tidyverse系列核心包，可以直接安装tidyverse使用，或者单独安装readr。 # 安装整个tidyverse install.packages(&quot;tidyverse&quot;) # 仅安装readr install.packages(&quot;readr&quot;) # 从github安装开发版 # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readr&quot;) 1.4.2 用法 readr包是tidyverse系列的核心包，可以加载tidyverse使用。 library(tidyverse) # 或者 library(readr) 1.4.2.1 主要函数 readr包支持七种read_功能的文件格式。 — read_csv():逗号分隔符文件 - read_tsv():制表符分割文件 - read_delim():规定分隔符文件 - read_fwf():固定宽度文件 - read_table():表格文件，列间用空格隔开 - read_log():Web日志文件 在大多数情况下，我们常使用read_csv()，提供文件路径，将得到数据表。示例如下: mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;)) #&gt; #&gt; ─ Column specification ──────────────────────────── #&gt; cols( #&gt; mpg = col_double(), #&gt; cyl = col_double(), #&gt; disp = col_double(), #&gt; hp = col_double(), #&gt; drat = col_double(), #&gt; wt = col_double(), #&gt; qsec = col_double(), #&gt; vs = col_double(), #&gt; am = col_double(), #&gt; gear = col_double(), #&gt; carb = col_double() #&gt; ) 通过上述输出反馈，我们可以知道读进去的数据集每列类型。如果发现不对可以通过col_types参数修改。大多数情况下，我们并不需要指定列的类型，readr会自动猜测列类型。 mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), col_types = cols( mpg = col_double(), cyl = col_integer(), disp = col_double(), hp = col_integer(), drat = col_double(), vs = col_integer(), wt = col_double(), qsec = col_double(), am = col_integer(), gear = col_integer(), carb = col_integer() ) ) 1.4.2.2 参数 read_csv()的参数如下： read_csv( file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, quote = &quot;\\&quot;&quot;, comment = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), skip_empty_rows = TRUE ) 通过对前文readxl的了解，我们发现两个函数的部分参数是一致的。 col_types :指定列类型，可用项如下所示(含简写): c = character，i = integer，n = number，d = double，l = logical，f = factor，D = date，T = date time，t = time，默认值为guess. locale:locale参数是readr中很重要的一个参数，指定日期使用的月和日的名称，时区，字符编码，日期格式，数字的小数和点位数和分隔符。 locale()的第一个参数是date_names，控制月份和日期的名称，指定最简单的方式ISO 639 language code locale(&#39;zh&#39;) # 中文 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: 星期日 (周日), 星期一 (周一), 星期二 (周二), 星期三 (周三), 星期四 #&gt; (周四), 星期五 (周五), 星期六 (周六) #&gt; Months: 一月 (1月), 二月 (2月), 三月 (3月), 四月 (4月), 五月 (5月), 六月 (6月), #&gt; 七月 (7月), 八月 (8月), 九月 (9月), 十月 (10月), 十一月 (11月), #&gt; 十二月 (12月) #&gt; AM/PM: 上午/下午 locale(&#39;ja&#39;) #日本 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: 日曜日 (日), 月曜日 (月), 火曜日 (火), 水曜日 (水), 木曜日 (木), 金曜日 #&gt; (金), 土曜日 (土) #&gt; Months: 1月, 2月, 3月, 4月, 5月, 6月, 7月, 8月, 9月, 10月, 11月, 12月 #&gt; AM/PM: 午前/午後 locale(&#39;ko&#39;) #韩国 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: 일요일 (일), 월요일 (월), 화요일 (화), 수요일 (수), 목요일 (목), 금요일 #&gt; (금), 토요일 (토) #&gt; Months: 1월, 2월, 3월, 4월, 5월, 6월, 7월, 8월, 9월, 10월, 11월, 12월 #&gt; AM/PM: 오전/오후 编码和时区问题是我们常面临的问题， 不正确设定导致我们的数据读取错误。 read_csv(readr_example(&quot;mtcars.csv&quot;),locale = locale(encoding = &#39;UTF-8&#39;,tz = &#39;Asia/Shanghai&#39;)) 关于locales,详细信息查看手册vignette(\"locales\")。 1.4.3 导出功能 由于系统缘故，在win系统下可能面临编码问题。我用readr导出数据时一般采用write_excel_csv()功能导出，目前还未遇到乱码情况。 需要说明的是write_系列函数可以将输出文件压缩。 data(storms, package = &quot;dplyr&quot;) write_csv(storms, &quot;storms.csv&quot;) write_csv(storms, &quot;storms.csv.gz&quot;) 1.4.4 总结 大部分情况下，当数据整洁时且不涉及时间(日期不影响)时，采用默认参数读取数据即可。当数据集前面行缺失值较多，readr自动猜数据列类型错误时，需要我们人为指定列类型。 read_csv(&#39;test.csv&#39;,col_types = &#39;cccnnnnDcnn&#39;) 由于Excel数字位数限制，在输出数字订单号或身份证时需要注意,: id_card &lt;- c(&#39;440327199910010123&#39;,&#39;440327199910010125&#39;) write_excel_csv(data.frame(id_card),&#39;test.csv&#39;) Excel最多只能存储15位数字型数字，15为之后都为0。 上面的输出显然会改变真实的身份证号码，这时我们就建议输出为xlsx的字符型或者是txt等格式，因为输出CSV会导致后面的全部变成0。 当编码时区不一致时，需指定locale()，如下： read_csv(readr_example(&quot;mtcars.csv&quot;),locale = locale(encoding = &#39;UTF-8&#39;,tz = &#39;Asia/Shanghai&#39;)) 矩形数据英文中表示为 rectangular data，矩形数据每一列都是变量(特征)，而每一行都是案例或记录,关系数据库中的单表就是矩形数据的一种。↩︎ "],["data-vroom.html", "1.5 vroom", " 1.5 vroom vroom实现读取矩形数据到R中,如 comma separated(csv),tab separated(tsv), fixed width files(fwf)。该包的功能类似readr::read_csv(),data.table::fread()和read.csv(),但是对于许多数据集来说，vroom::vroom()读取速度会快得多。 vroom项目地址 1.5.1 安装 # 从cran安装 install.packages(&quot;vroom&quot;) # install.packages(&quot;devtools&quot;) devtools::install_dev(&quot;vroom&quot;) 1.5.2 用法 读取文件 library(vroom) file &lt;- vroom_example(&quot;mtcars.csv&quot;) file #&gt; [1] &quot;/Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library/vroom/extdata/mtcars.csv&quot; vroom(file) #&gt; Rows: 32 #&gt; Columns: 12 #&gt; Delimiter: &quot;,&quot; #&gt; chr [ 1]: model #&gt; dbl [11]: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 32 x 12 #&gt; model mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Dr… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spor… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # … with 26 more rows vroom(file, delim = &quot;,&quot;) #&gt; Rows: 32 #&gt; Columns: 12 #&gt; Delimiter: &quot;,&quot; #&gt; chr [ 1]: model #&gt; dbl [11]: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 32 x 12 #&gt; model mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Dr… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spor… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # … with 26 more rows 读取多文件 即vroom::vroom()具备迭代效果,具体情况如下： mt &lt;- tibble::rownames_to_column(mtcars, &quot;model&quot;) purrr::iwalk( split(mt, mt$cyl), ~ vroom_write(.x, glue::glue(&quot;mtcars_{.y}.csv&quot;), &quot;\\t&quot;) ) files &lt;- fs::dir_ls(glob = &quot;mtcars*csv&quot;) files # read_csv purrr::map_dfr(files,readr::read_delim,delim=&quot;\\t&quot;) # vroom same above vroom(files) 读取压缩文件 vroom支持zip,gz,bz2,xz等压缩文件，只需要将压缩文件名称传递给vroom即可。 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file) 读取网络文件 #file &lt;- &quot;https://raw.githubusercontent.com/r-lib/vroom/master/inst/extdata/mtcars.csv&quot; file &lt;- &quot;http://www.zhongyufei.com/Rbook/data/data-table-groupingsets.csv&quot; vroom(file) #&gt; Rows: 18 #&gt; Columns: 4 #&gt; Delimiter: &quot;,&quot; #&gt; chr [3]: store_id, store_type, area #&gt; dbl [1]: value #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 18 x 4 #&gt; store_id store_type area value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A1 不可比 华东 9 #&gt; 2 A 可比 华东 87 #&gt; 3 B1 可比 华西 2 #&gt; 4 B 不可比 华西 42 #&gt; 5 C 可比 华南 79 #&gt; 6 D 不可比 华北 16 #&gt; # … with 12 more rows 选择列读取 room提供了与dplyr::select()相同的列选择和重命名接口 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file, col_select = c(model, cyl, gear)) #&gt; # A tibble: 32 x 3 #&gt; model cyl gear #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 6 4 #&gt; 2 Mazda RX4 Wag 6 4 #&gt; 3 Datsun 710 4 4 #&gt; 4 Hornet 4 Drive 6 3 #&gt; 5 Hornet Sportabout 8 3 #&gt; 6 Valiant 6 3 #&gt; # … with 26 more rows # vroom(file, col_select = c(1, 3, 11)) # vroom(file, col_select = list(car = model, everything())) "],["data-rstudio-addins.html", "1.6 Rstudio导入", " 1.6 Rstudio导入 1.6.1 利用rstudio工具栏导入 本质也是调用readr和readxl包，如下所示： rstudio-load-data 1.6.2 插件导入 项目地址 datapasta是一个addins插件，方便将数据复制到R。 1.安装 install.packages(&quot;datapasta&quot;) 2.使用 datapasta "],["data-file-path.html", "1.7 文件路径", " 1.7 文件路径 我们读取数据时都是读取某路径下的某文件，但是由于系统等原因，路径在不同系统下的表示方式不一致。 1.7.1 指定路径 win 路径 winOS系统：C:\\Users\\zhongyf\\Desktop\\Rbook，注意路径中是一个反斜杠()。 win-path 在R中读取时需要用一个正斜杠或两个反斜杠。 readr::read_csv(&#39;C:/Users/zhongyf/Desktop/Rbook/data/flights.csv&#39;) readr::read_csv(&#39;C:\\\\Users\\\\zhongyf\\\\Desktop\\\\Rbook\\\\data\\flights.csv&#39;) # same above readr:::read_csv(file = r&quot;(C:\\Users\\zhongyf\\Desktop\\Rbook\\data\\flights.csv)&quot;) # same above 工作中，当需要读取或写入共享盘4中文件时，路径表示方式为： the_shared_disk &lt;- r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot; # load data into R readr::read_csv(file = &quot;\\\\\\\\192.168.2.117\\\\公司A-新\\\\01事业部\\\\flights.csv&quot;) readr::read_csv(file = r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot;) r“()”用法是R-4.0-之后的特性。在win系统下表示路径特别有用 mac 路径 macOS系统: /User/vega_mac/Desktop/r,路径中是一个正斜杠。 mac-path readr::read_csv(&#39;/User/vega_mac/Desktop/r/Rbook/data/flights.csv&#39;) 1.7.2 默认路径 getwd()是查看当前工作目录的函数，在进行文件读写时的默认路径，也就是当没有明确指定路径时，读取导出的默认路径是getwd()。想要改变工作目录，通过设定setwd()即可。 getwd() #&gt; [1] &quot;/Users/zhongyf/Desktop/r/Rbook&quot; # not run setwd(&#39;C:/Users/zhongyf/Desktop/Rbook/data&#39;) getwd() 共享盘的地址即某电脑(服务器)的地址，知道共享盘在局域网中的ip地址后在 开始-&gt;运行中输入\\192.168.1.247即可打开共享盘。↩︎ "],["data-expand.html", "1.8 拓展", " 1.8 拓展 feather项目地址https://github.com/wesm/feather qs提供接口，用于快速将R对象保存到磁盘以及从磁盘读取。该包的目标是替换R中的saveRDS和readRDS。项目地址https://github.com/traversc/qs arrow是feather的接替项目，地址https://arrow.apache.org/docs/r/ 其它统计学软件数据如spss，stata,SAs等可用foreign包读取 "]]
