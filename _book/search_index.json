[["index.html", "R语言学习笔记 欢迎", " R语言学习笔记 Yufei Zhong 2021-05-29 欢迎 本文主要是我作为商业数据分析师的R语言学习笔记，主要是数据清洗相关包的介绍。 使用R语言自动完成如下报表: .tabwid table{ border-collapse:collapse; line-height:1; margin-left:auto; margin-right:auto; border-width: 0; display: table; margin-top: 1.275em; margin-bottom: 1.275em; border-spacing: 0; border-color: transparent; } .tabwid_left table{ margin-left:0; } .tabwid_right table{ margin-right:0; } .tabwid td { padding: 0; } .tabwid a { text-decoration: none; } .tabwid thead { background-color: transparent; } .tabwid tfoot { background-color: transparent; } .tabwid table tr { background-color: transparent; } .cl-5ba65a74{border-collapse:collapse;}.cl-5b9df4d8{font-family:'Arial';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(255, 255, 255, 1.00);background-color:transparent;}.cl-5b9df4d9{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-5b9df4da{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:italic;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-5b9df4db{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-5b9df4dc{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-5b9df4dd{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-5b9e442e{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e442f{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4430{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4431{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4432{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4433{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4434{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4435{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4436{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4437{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e4438{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b3e{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b3f{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b40{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b41{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b42{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b43{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b44{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b45{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b46{width:81.7pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b47{width:53.5pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e6b48{width:57.8pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e9244{width:63.3pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e9245{width:60.3pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e9246{width:53.5pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-5b9e9247{width:61.8pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;} 一级部门分析大类当前销额当前%同比销额同比%金额增长%当前销量同比销量销量同比%当前折扣同比折扣事业部衬衣55,148,05635.4%51,999,20928.1%6.1%282,426358,658-21.3%81.0%60.1%箱包72,439,03846.5%92,585,62650.0%-21.8%124,584163,813-23.9%92.4%93.0%篮球鞋21,872,49514.0%33,590,83518.2%-34.9%44,26070,666-37.4%87.3%89.0%太阳镜1,526,9081.0%952,9340.5%60.2%6,6093,94467.6%94.0%97.0%周边商品1,691,8101.1%372,0500.2%354.7%11,7772,249423.7%87.0%87.0%袜子692,5910.4%587,5550.3%17.9%243,679271,089-10.1%94.7%22.2%其它2,312,9501.5%4,946,5102.7%-53.2%5,58110,128-44.9%94.0%93.1%事业部汇总155,683,848100.0%185,034,718100.0%-15.9%718,916880,547-18.4%87.3%79.3%数据更新时间:2021-05-29 "],["abstract.html", "内容概要", " 内容概要 主要内容是为了将数据报表，数据报告，数据可视化等需求利用R语言自动化实现，从而解放双手。 数据导入导出 读Excel:readxl,openxlsx;写Excel:openxlsx,writexl,读写CSV,TSV,TXT等:readr,vroom,data.table; 数据操作 dplyr 数据整洁 tidyr 字符处理 stringr 日期时间处理 lubridate 因子处理 forcats 数据处理利器 data.table 数据库使用 主要是odbc,DBI,ROracle,RMySQL等 循环结构 循环迭代之purrr包介绍 自定义函数功能 文件系统管理 数据操作处理分为:tidyverse系列，data.table两大语法体系。 "],["sec-licenses.html", "授权说明", " 授权说明 本书采用Creative Commons Attribution-ShareAlike 4.0 International License 许可，请君自重。 项目中代码使用 MIT协议 开源。 Creative Commons Attribution-ShareAlike 4.0 International License. "],["session.html", "运行信息", " 运行信息 xfun::session_info(packages = c( &quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;bookdown&quot;,&quot;collapse&quot;, &quot;data.table&quot;, &quot;DT&quot;, &quot;reactable&quot;,&quot;flextable&quot;, &quot;patchwork&quot;, &quot;plotly&quot;, &quot;shiny&quot;,&quot;formattable&quot;, &quot;ggplot2&quot;, &quot;dplyr&quot;, &quot;tidyverse&quot;,&quot;DBI&quot;,&quot;ROracle&quot;,&quot;dbplyr&quot; ), dependencies = FALSE) #&gt; R version 4.1.0 (2021-05-18) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 19041) #&gt; #&gt; Locale: #&gt; LC_COLLATE=Chinese (Simplified)_China.936 #&gt; LC_CTYPE=Chinese (Simplified)_China.936 #&gt; LC_MONETARY=Chinese (Simplified)_China.936 #&gt; LC_NUMERIC=C #&gt; LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; Package version: #&gt; bookdown_0.22 collapse_1.5.3 data.table_1.14.0 DBI_1.1.1 #&gt; dbplyr_2.1.1 dplyr_1.0.6 DT_0.18 flextable_0.6.6 #&gt; formattable_0.2.1 ggplot2_3.3.3 knitr_1.33 patchwork_1.1.1 #&gt; plotly_4.9.3 reactable_0.2.3 rmarkdown_2.8 ROracle_1.3.1 #&gt; shiny_1.6.0 tidyverse_1.3.1 #&gt; #&gt; Pandoc version: 2.11.4 "],["author.html", "关于本人", " 关于本人 一名热爱R语言的商业数据分析师。R极大拓展了我数据处理能力,让我很轻松方便处理数据，有更多精力时间聚焦在具体问题上。 因个人能力有限，本书难免出现错误，如发现错误，欢迎联系本人更正。 Email: 598253220@qq.com 公众号: 宇飞的世界 语雀: https://www.yuque.com/zyufei "],["data-read-write-description.html", "1 数据导入导出", " 1 数据导入导出 作为一名普通的数据分析师，我日常接触最多的数据是业务系统中的销售订单表、商品库存表、会员信息表，门店信息表，商品信息表等之类的业务表，但最初接触R时，看到的演示代码以及数据集大部分都是R包中内置的数据集，没有很明确操作数据的意义，没有代入感。在刚开始学习使用R做数据处理后，我就想使用自己的数据集来操作数据，用R去实现Excel的透视表或sql功能。这时就首先需要将原始数据导入1R中。 现实生活中数据来源复杂，商业环境中数据源同样具有多样性，如SAP,不同的数据库、OA系统、EXCEL手工文件等;我们想要统一数据做分析，就需要将不同的数据源整合导入R中。 我们从读取方式简单区分为本地文件数据、数据库数据，本章主要说明常用的Excel文件和csv2、txt等文本文件的读写方式。关于数据库的数据的读取，可以参照后续database章节。 相信大家随便使用搜索引擎搜索诸如“将Excel导入R”的关键词都能得到一些行之有效的方法，但是不够系统全面。本章主要简述R中数据导入导出的相关R包，如readxl,writexl,openxlsx,readr, vroom等主要处理csv或Excel的R包。 当有其它数据格式需求的时候，那时候的你肯定已经会自行查找相关R包使用了。 在本章开始前，假定已经有一些R相关基础。如使用Rstudio查看导入的数据，R的数据结构等有一定认识。本章节主要分为: excel读写 csv等平面文件读写 文件路径 由于R是将数据加载至内存中，故数据集大小超过内存大小将导入失败。↩︎ csv即Comma-Separated Values，逗号分隔值，分隔符也可是不是逗号。 csv文件是一种以纯文本形式存储的表格数据,可以通过记事本打开。与Excel不同的是，CSV是一种文本格式，也不受Excel最大行数(1048576)限制。 csv文件也被称作平面文件，结构简单，平面文件比结构文件占用更少的空间；平面文件在数据仓库项目中广泛用于导入数据。↩︎ "],["readxl-description.html", "1.1 readxl", " 1.1 readxl readxl软件包使R获取Excel数据变得方便简洁。与现有的软件包(例如：xlsx)相比，readxl没有外部依赖性，xlsx等包依赖java环境。readxl包容易在所有的操作系统安装使用。 readxl项目地址，本节大部分代码来源项目官网介绍，可自行查阅官网。 1.1.1 安装 从CRAN安装最新发行版本的最简单方法是安装整个tidyverse。 install.packages(&quot;tidyverse&quot;) 由于readxl不是tidyverse核心加载包，使用时仅需加载library(readxl) 或者是从CRAN仅安装readxl; install.packages(&quot;readxl&quot;) 从github安装开发版： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readxl&quot;) 1.1.2 用法 readxl包的核心函数是读取函数read_excel()，该函数能将Excel文件数据加载到R中。readxl包中包含了几个示例文件，我们在接下来的案例中使用。 1.读取 通过readxl_example()查看readxl包中自带xlsx文件。 library(readxl) readxl_example() #&gt; [1] &quot;clippy.xls&quot; &quot;clippy.xlsx&quot; &quot;datasets.xls&quot; &quot;datasets.xlsx&quot; #&gt; [5] &quot;deaths.xls&quot; &quot;deaths.xlsx&quot; &quot;geometry.xls&quot; &quot;geometry.xlsx&quot; #&gt; [9] &quot;type-me.xls&quot; &quot;type-me.xlsx&quot; readxl_example(&quot;clippy.xls&quot;) #&gt; [1] &quot;C:/R/R-4.1.0/library/readxl/extdata/clippy.xls&quot; 需要注意read_excel()可读取xls和xlsx文件，函数会自动识别。 xls和xlsx的区别: xls 是 excel2003 及以前版本生成的文件格式，而 xlsx 是 excel2007 及以后版本生成的文件格式。xlsx格式是向下兼容的，可兼容xls格式。老旧的业务使用的格式可能是xls格式。 xlsx_example &lt;- readxl_example(&quot;datasets.xlsx&quot;) #返回datasets.xlsx文件所在路径 dt &lt;- read_excel(xlsx_example) 查看数据 head(dt) #&gt; # A tibble: 6 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa 将Excel中的数据通过read_excel()读取保存到R中，该对象属于tbl_df类，是tidyverse系列的数据框结构，是对base R中的data.frame结构的改造，但是兼容data.frame。 # 查看dt类 class(dt) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # 查看数据类型 str(dt) #&gt; tibble [150 x 5] (S3: tbl_df/tbl/data.frame) #&gt; $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : chr [1:150] &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; ... 关于tbl_df类，可以查阅vignette(\"tibble\")。 2.指定sheet读取 通过函数excel_sheets()查看Excel的sheet名称 excel_sheets(xlsx_example) #&gt; [1] &quot;iris&quot; &quot;mtcars&quot; &quot;chickwts&quot; &quot;quakes&quot; 当我们要读取Excel文件有多个sheets时，通过指定sheet参数,读取指定的sheet，sheet参数可以是sheet的名称或顺序号。 read_excel(xlsx_example, sheet = &quot;chickwts&quot;) #&gt; # A tibble: 71 x 2 #&gt; weight feed #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 179 horsebean #&gt; 2 160 horsebean #&gt; 3 136 horsebean #&gt; 4 227 horsebean #&gt; 5 217 horsebean #&gt; 6 168 horsebean #&gt; # ... with 65 more rows # not run #read_excel(xlsx_example, sheet = 1) #read_excel(xlsx_example, sheet = 3) 3.指定读取范围 读取Excel文件指定范围。read_excel()中range参数接受单元格范围，最简单的表示方式即Excle中单元格表示方法,如 range = “D12:F15” or range = “R1C12:R6C15”。 read_excel(xlsx_example, sheet = &quot;iris&quot;) #&gt; # A tibble: 150 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; # ... with 144 more rows dt1 &lt;- read_excel(xlsx_example, sheet = &quot;iris&quot;,range = &#39;a1:e6&#39;) dt2 &lt;- read_excel(xlsx_example, sheet = &quot;iris&quot;,range = &#39;R1C1:R6C5&#39;) # dt1 dt2 是否相等 identical(dt1,dt2) #&gt; [1] TRUE 4.read_excel参数 readxl::read_excel参数如下,请?read_excel()查看参数。 read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot;) read_excel参数 解释 path xls或xlsx文件的路径 sheet 默认是第一个sheet，可以是数字或sheet的名称 range Excel中表示范围的字符，或者通过cell_类方法指定 col_name 默认为TRUE,用第一行做列名;或者用默认名称,或者指定列名 col_types 默认为NULL，猜测各列类型，可指定各列的类型 trim_ws 默认去掉表头字段中两边的空格 skip 读取之前要跳过的行数，默认为空 n_max 读取的最大行数 guess_max 猜测列类型的最大行数,默认为1000 progress 读取过程是否显示进度 .name_repair 自动处理列名，避免列名不为空以及不重复 col_types 参数个人觉得比较重要，可以指定列的类型，可以避免一些错误。可用选项:“skip,” “guess,” “logical,” “numeric,” “date,” “text” or “list”。 .name_repair 参数能自动避免重复字段，可避免手工Excel出现字段名不唯一的情况。 1.1.3 批量读取 实际工作中，某文件夹下有相同格式的Excel文件(sheet名称以及列字段相同)，想要合并全部Excel数据，熟悉Excel的可以通过Excel的power query的获取数据完成合并，那么在R中该如何实现呢？ 示例： 文件夹内 excel 文件 #&gt; data/read-write/ #&gt; +-- a.xlsx #&gt; +-- b.xlsx #&gt; \\-- 批量读写.xlsx R代码如下 allfiles &lt;- list.files(path = &#39;./data/read-write/&#39;,pattern = &#39;.xlsx$&#39;,full.names = T) # 使用purrr包合并读取 purrr::map_dfr(allfiles,read_excel) list.files()函数按照规则返回某文件目录下的全部文件。关于R语言中文件系统操作可以查看章节R语言文件系统操作 1.1.4 批量输出 我们按照一定条件拆解数据集，分别输出，代码如下： library(tidyverse) library(readxl) dt &lt;- read_xlsx(path = &#39;./data/read-write/批量读写.xlsx&#39;) dt %&gt;% group_by(name) %&gt;% group_walk(~ write.csv(.x,file = file.path(&#39;data/read-write&#39;,paste0(.y$name,&#39;.csv&#39;)))) list.files(path = &#39;data/read-write/&#39;) #&gt; [1] &quot;a.csv&quot; &quot;a.xlsx&quot; &quot;b.csv&quot; &quot;b.xlsx&quot; #&gt; [5] &quot;d.csv&quot; &quot;Id-card-data.csv&quot; &quot;批量读写.xlsx&quot; 暂时不用理解批量读取和输出的代码具体含义，可以先记住用法。 "],["writexl.html", "1.2 writexl", " 1.2 writexl 截止到2021年5月17日，writexl包功能比较简单，仅有输出Excel功能。快速、不依赖java和Excle是它绝对的优势，并且输出文件相比openxlsx包较小。 项目地址 1.2.1 用法 1.安装 从CRAN安装发行版 install.packages(&quot;writexl&quot;) 2.函数参数 write_xlsx()函数参数如下： write_xlsx( x, path = tempfile(fileext = &quot;.xlsx&quot;), col_names = TRUE, format_headers = TRUE, use_zip64 = FALSE ) write_xlsx参数 解释 x 要输出的数据框和数据框列表 path 输出Excel的文件名称 col_names 是否输出表头，默认为TRUE format_headers 是否将表头居中并加粗，默认为TRUE use_zip64 是否支持4Gb文件大小，不是所有的系统都支持 use_zip64:不确定该参数的理解是否正确，请自行阅读官方文档，绝大部分时候不用理解该参数。 3.输出Excel write_xlsx()函数将数据框保存到Excel。如想要输出多个sheet时，用list(mysheet1 = iris,mysheet2 = iris)表示即可，代码如下： library(writexl) writexl::write_xlsx(iris,path = &#39;iris.xlsx&#39;) # 输出多sheet write_xlsx(list(mysheet1 = iris,mysheet2 = iris),path = &#39;iris.xlsx&#39;) 4.效率比较 和openxlsx包比较输出效率。 library(microbenchmark) library(nycflights13) microbenchmark( writexl = writexl::write_xlsx(flights, tempfile()), openxlsx = openxlsx::write.xlsx(flights, tempfile()), times = 2 ) 5.文件大小比较 和openxlsx包比较输出后的Excel文件大小。 library(nycflights13) writexl::write_xlsx(flights, tmp1 &lt;- tempfile()) file.info(tmp1)$size #&gt; [1] 29139353 openxlsx::write.xlsx(flights, tmp2 &lt;- tempfile()) file.info(tmp2)$size #&gt; [1] 26833694 按照writexl官方文档的说法，writexl输出的Excel文件应该较少，但实际上并不是，不确定是不是openxlsx更新优化过。 6.其它功能 Excel 公式以及超级链接格式。 df &lt;- data.frame( name = c(&quot;UCLA&quot;, &quot;Berkeley&quot;, &quot;Jeroen&quot;), founded = c(1919, 1868, 2030), website = xl_hyperlink(c(&quot;http://www.ucla.edu&quot;, &quot;http://www.berkeley.edu&quot;, NA), &quot;homepage&quot;) ) df$age &lt;- xl_formula(&#39;=(YEAR(TODAY()) - INDIRECT(&quot;B&quot; &amp; ROW()))&#39;) write_xlsx(df, &#39;universities.xlsx&#39;) # cleanup unlink(&#39;universities.xlsx&#39;) 当需要输出大型Excel文件时，比如超过50万行，我会采用writexl包输出。但是在曾经使用过程中，定时任务采用writexl包输出Excel有时会报错，感觉不稳定，原因不明。现在一般临时性的输出我会采用writexl包，定时任务中采用openxlsx "],["openxlsx-description.html", "1.3 openxlsx", " 1.3 openxlsx openxlsx是当我需要定制输出Excel表格或报表时常用R包。目前该包的版本4.2.3，通过使用Rcpp加速，包的读写速度在Excel的百万级下是可接受状态，包的相关函数功能完善且简易好用，并且正在积极开发中，相信它以后功能会越来越强大。 项目官方地址:https://ycphs.github.io/openxlsx/index.html openxlsx主要优势： 不依赖java环境 读写速度可接受 可设置条件格式，与Excel中『开始』选项卡的条件格式功能接近 可批量插入ggplot2图 可插入公式 可渲染大部分Excel格式，并且效率相比部分python包高效 可添加页眉页脚以及其他格式，方便直接打印 功能稳定可用并且在积极开发中 版本信息查看 packageVersion(&quot;openxlsx&quot;) #&gt; [1] &#39;4.2.3&#39; 关于openxlsx更加详细的阐述:https://mp.weixin.qq.com/s/ZD0dJb0y8fsWGI1dCPh2mQ 1.3.1 安装 从CRAN安装发行版 # 稳定版 install.packages(&quot;openxlsx&quot;, dependencies = TRUE, repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;) 从Github安装开发版 install.packages(c(&quot;Rcpp&quot;, &quot;devtools&quot;), dependencies = TRUE) library(devtools) install_github(&quot;ycphs/openxlsx&quot;) 1.3.2 基础功能 本文仅呈现基础功能部分，即读写EXCEL文件。其它功能，请查阅项目官方地址或微信公众号文章R包-openxlsx-学习笔记 1.3.2.1 读取Excel read.xlsx()是读取函数，主要参数如下： library(openxlsx) read.xlsx( xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = &quot;.&quot;, namedRegion = NULL, na.strings = &quot;NA&quot;, fillMergedCells = FALSE ) 以上参数中需要注意 ： detecDates参数，当你的Excel表格中带日期列时需要将参数设置为TRUE,不然将会把日期识别为数字读入。 fillMergedCells参数，当你读取的表格中存在合并单元格，将用值填充其他全部单元格,如下所示： merge-cell read.xlsx(&#39;./test.xlsx&#39;,detectDates = TRUE,fillMergedCells = TRUE) 读取后如下所示： openxlsx-merge-xlsx readWorkbook()也可以读取Excel表格数据，参数与read.xlsx基本一致。 xlsxFile &lt;- system.file(&quot;extdata&quot;, &quot;readTest.xlsx&quot;, package = &quot;openxlsx&quot;) df1 &lt;- readWorkbook(xlsxFile = xlsxFile, sheet = 1) 1.3.2.2 写入Excel 数据清洗完之后，或者是透视表已经完成，需要将结果从R导出到Excle，这时就利用函数将结果数据集写入Excle中。 write.xlsx()函数写入 write.xlsx(iris, file = &quot;writeXLSX1.xlsx&quot;, colNames = TRUE, borders = &quot;columns&quot;) 带格式输出 hs &lt;- createStyle( textDecoration = &quot;BOLD&quot;, fontColour = &quot;#FFFFFF&quot;, fontSize = 12, fontName = &quot;Arial Narrow&quot;, fgFill = &quot;#4F80BD&quot; ) ## Not run: write.xlsx(iris, file = &quot;writeXLSX3.xlsx&quot;, colNames = TRUE, borders = &quot;rows&quot;, headerStyle = hs ) #4F80BD格式属于十六进制颜色码。 1.3.3 定制格式输出 openxlsx包有两套输出函数，wrire.xlsx()是其中一种，还有如下一种。 输出过程共分为四步，第一步创建workbook,第二步添加sheet,第三步写入数据，第四步保存workbook。在输出的过程中可以通过addStyle()、createStyle()或conditionalFormatting添加格式或条件格式。 df &lt;- data.frame(a=1:10,b=1:10,d=1:10) wb &lt;- createWorkbook(creator = &#39;zhongyf&#39;,title = &#39;test&#39;) addWorksheet(wb,sheetName = &#39;test&#39;) writeDataTable(wb,sheet = &#39;test&#39;,x = df) saveWorkbook(wb, &quot;test.xlsx&quot;, overwrite = TRUE) 我们以上面四步输出的方式，查看包自带的例子。 createWorkbook() addWorksheet() writeDataTable() saveWorkbook() wb &lt;- createWorkbook(&quot;Fred&quot;) ## Add 3 worksheets addWorksheet(wb, &quot;Sheet 1&quot;) addWorksheet(wb, &quot;Sheet 2&quot;, gridLines = FALSE) addWorksheet(wb, &quot;Sheet 3&quot;, tabColour = &quot;red&quot;) addWorksheet(wb, &quot;Sheet 4&quot;, gridLines = FALSE, tabColour = &quot;#4F81BD&quot;) ## Headers and Footers addWorksheet(wb, &quot;Sheet 5&quot;, header = c(&quot;ODD HEAD LEFT&quot;, &quot;ODD HEAD CENTER&quot;, &quot;ODD HEAD RIGHT&quot;), footer = c(&quot;ODD FOOT RIGHT&quot;, &quot;ODD FOOT CENTER&quot;, &quot;ODD FOOT RIGHT&quot;), evenHeader = c(&quot;EVEN HEAD LEFT&quot;, &quot;EVEN HEAD CENTER&quot;, &quot;EVEN HEAD RIGHT&quot;), evenFooter = c(&quot;EVEN FOOT RIGHT&quot;, &quot;EVEN FOOT CENTER&quot;, &quot;EVEN FOOT RIGHT&quot;), firstHeader = c(&quot;TOP&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;), firstFooter = c(&quot;BOTTOM&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;) ) addWorksheet(wb, &quot;Sheet 6&quot;, header = c(&quot;&amp;[Date]&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;&amp;[Page] / &amp;[Pages]&quot;), footer = c(&quot;&amp;[Path]&amp;[File]&quot;, NA, &quot;&amp;[Tab]&quot;), firstHeader = c(NA, &quot;Center Header of First Page&quot;, NA), firstFooter = c(NA, &quot;Center Footer of First Page&quot;, NA) ) addWorksheet(wb, &quot;Sheet 7&quot;, header = c(&quot;ALL HEAD LEFT 2&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;ALL HEAD RIGHT 2&quot;), footer = c(&quot;ALL FOOT RIGHT 2&quot;, &quot;ALL FOOT CENTER 2&quot;, &quot;ALL FOOT RIGHT 2&quot;) ) addWorksheet(wb, &quot;Sheet 8&quot;, firstHeader = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;), firstFooter = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;) ) addWorksheet(wb,&#39;dataframe&#39;) ## Need data on worksheet to see all headers and footers writeData(wb, sheet = 5, 1:400) writeData(wb, sheet = 6, 1:400) writeData(wb, sheet = 7, 1:400) writeData(wb, sheet = 8, 1:400) writeDataTable(wb,sheet = &#39;dataframe&#39;,iris) ## Save workbook ## Not run: saveWorkbook(wb, &quot;addWorksheetExample.xlsx&quot;, overwrite = TRUE) 1.3.4 函数参数 本小节主要讲createWorkbook()，addWorksheet(),writeDataTable(),saveWorkbook()四个函数的参数以及用法。 createWorkbook createWorkbook( creator = ifelse(.Platform$OS.type == &quot;windows&quot;, Sys.getenv(&quot;USERNAME&quot;), Sys.getenv(&quot;USER&quot;)), title = NULL, subject = NULL, category = NULL ) wb &lt;- createWorkbook( creator = &quot;宇飞的世界&quot;, title = &quot;标题&quot;, subject = &quot;主题&quot;, category = &quot;类别目录&quot; ) addWorksheet addWorksheet( wb, sheetName, gridLines = TRUE, tabColour = NULL, zoom = 100, header = NULL, footer = NULL, evenHeader = NULL, evenFooter = NULL, firstHeader = NULL, firstFooter = NULL, visible = TRUE, paperSize = getOption(&quot;openxlsx.paperSize&quot;, default = 9), orientation = getOption(&quot;openxlsx.orientation&quot;, default = &quot;portrait&quot;), vdpi = getOption(&quot;openxlsx.vdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)), hdpi = getOption(&quot;openxlsx.hdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)) ) gridLines参数：表格中是否有网格线，在Excle『视图』选项卡下面的网格线去除打勾的效果一致 tabColour参数：输出表格sheet标签颜色 zoom：发大缩小，默认是100，可选范围10-400 header:页眉 长度为3的字符向量，左、中、右三个位置，用Na可跳过一位置，以下页眉页脚相同。 footer: 页脚 evenHeader: 每页页眉 evenFooter: 每页页脚 firstHeader: 第一页页眉 firstFooter: 第一页页脚 visible:sheet是否隐藏，如果为否sheet将被隐藏 paperSize:页面大小,详见 ?pageSetup orientation:One of &quot;portrait&quot; or &quot;landscape&quot; 不清楚干嘛用 vdpi: 屏幕分辨率 默认值即可，不用调整 hdpi: 屏幕分辨率 默认值即可，不用调整 writeDataTable writeDataTable()函数将data.frame写入Excel。 writeDataTable( wb, sheet, x, startCol = 1, startRow = 1, xy = NULL, colNames = TRUE, rowNames = FALSE, tableStyle = &quot;TableStyleLight9&quot;, tableName = NULL, headerStyle = NULL, withFilter = TRUE, keepNA = FALSE, na.string = NULL, sep = &quot;, &quot;, stack = FALSE, firstColumn = FALSE, lastColumn = FALSE, bandedRows = TRUE, bandedCols = FALSE ) saveWorkbook saveWorkbook(wb, file, overwrite = FALSE, returnValue = FALSE) 参数较为简单，wb即上文中的workbook对象，file即输出的文件名，overwrite即如果存在是否覆盖，returnValue如果设置为TRUE，返回TRUE代表保存成功 1.3.5 总结 openxlsx包功能较为强大，更多详细用法大家可自行探索，或关注我的语雀笔记，笔记会不定期持续更新。 R包openxlsx学习笔记:https://www.yuque.com/docs/share/7a768e6f-95e0-417c-a9b5-dfc8862dc6be?# 语雀个人主页:https://www.yuque.com/zyufei "],["readr-package.html", "1.4 readr", " 1.4 readr readr提供了一种快速友好的方式读取矩形数据3(如：csv,tsv,fwf)，且当读取大型数据集时默认有进度条显示。 如果对readr包不熟悉，可以直接阅读包作者，大神Hadley Wickham的书R for data science 中data import chapter章节。 1.4.1 安装 由于readr包是tidyverse系列核心包，可以直接安装tidyverse使用，或者单独安装readr。 # 安装整个tidyverse install.packages(&quot;tidyverse&quot;) # 仅安装readr install.packages(&quot;readr&quot;) # 从github安装开发版 # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readr&quot;) 1.4.2 用法 readr包是tidyverse系列的核心包，可以加载tidyverse使用。 library(tidyverse) # 或者 library(readr) 1.4.2.1 主要函数 readr包支持七种read_功能的文件格式。 — read_csv():逗号分隔符文件 - read_tsv():制表符分割文件 - read_delim():规定分隔符文件 - read_fwf():固定宽度文件 - read_table():表格文件，列间用空格隔开 - read_log():Web日志文件 在大多数情况下，我们常使用read_csv()，提供文件路径，将得到数据表。示例如下: mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;)) #&gt; #&gt; -- Column specification -------------------------------------------------------- #&gt; cols( #&gt; mpg = col_double(), #&gt; cyl = col_double(), #&gt; disp = col_double(), #&gt; hp = col_double(), #&gt; drat = col_double(), #&gt; wt = col_double(), #&gt; qsec = col_double(), #&gt; vs = col_double(), #&gt; am = col_double(), #&gt; gear = col_double(), #&gt; carb = col_double() #&gt; ) 通过上述输出反馈，我们可以知道读进去的数据集每列类型。如果发现不对可以通过col_types参数修改。大多数情况下，我们并不需要指定列的类型，readr会自动猜测列类型。 mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), col_types = cols( mpg = col_double(), cyl = col_integer(), disp = col_double(), hp = col_integer(), drat = col_double(), vs = col_integer(), wt = col_double(), qsec = col_double(), am = col_integer(), gear = col_integer(), carb = col_integer() ) ) 1.4.2.2 参数 read_csv()的参数如下： read_csv( file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, quote = &quot;\\&quot;&quot;, comment = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), skip_empty_rows = TRUE ) 通过对前文readxl的了解，我们发现两个函数的部分参数是一致的。 col_types :指定列类型，可用项如下所示(含简写): c = character，i = integer，n = number，d = double，l = logical，f = factor，D = date，T = date time，t = time，默认值为guess. locale:locale参数是readr中很重要的一个参数，指定日期使用的月和日的名称，时区，字符编码，日期格式，数字的小数和点位数和分隔符。 locale()的第一个参数是date_names，控制月份和日期的名称，指定最简单的方式ISO 639 language code locale(&#39;zh&#39;) # 中文 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: 星期日 (周日), 星期一 (周一), 星期二 (周二), 星期三 (周三), 星期四 #&gt; (周四), 星期五 (周五), 星期六 (周六) #&gt; Months: 一月 (1月), 二月 (2月), 三月 (3月), 四月 (4月), 五月 (5月), 六月 (6月), #&gt; 七月 (7月), 八月 (8月), 九月 (9月), 十月 (10月), 十一月 (11月), #&gt; 十二月 (12月) #&gt; AM/PM: 上午/下午 locale(&#39;ja&#39;) #日本 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: 日曜日 (日), 月曜日 (月), 火曜日 (火), 水曜日 (水), 木曜日 (木), 金曜日 #&gt; (金), 土曜日 (土) #&gt; Months: 1月, 2月, 3月, 4月, 5月, 6月, 7月, 8月, 9月, 10月, 11月, 12月 #&gt; AM/PM: 午前/午後 locale(&#39;ko&#39;) #韩国 #&gt; &lt;locale&gt; #&gt; Numbers: 123,456.78 #&gt; Formats: %AD / %AT #&gt; Timezone: UTC #&gt; Encoding: UTF-8 #&gt; &lt;date_names&gt; #&gt; Days: &lt;U+C77C&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C77C&gt;), &lt;U+C6D4&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C6D4&gt;), &lt;U+D654&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+D654&gt;), &lt;U+C218&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C218&gt;), &lt;U+BAA9&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+BAA9&gt;), &lt;U+AE08&gt;&lt;U+C694&gt;&lt;U+C77C&gt; #&gt; (&lt;U+AE08&gt;), &lt;U+D1A0&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+D1A0&gt;) #&gt; Months: 1&lt;U+C6D4&gt;, 2&lt;U+C6D4&gt;, 3&lt;U+C6D4&gt;, 4&lt;U+C6D4&gt;, 5&lt;U+C6D4&gt;, 6&lt;U+C6D4&gt;, 7&lt;U+C6D4&gt;, 8&lt;U+C6D4&gt;, 9&lt;U+C6D4&gt;, 10&lt;U+C6D4&gt;, 11&lt;U+C6D4&gt;, 12&lt;U+C6D4&gt; #&gt; AM/PM: &lt;U+C624&gt;&lt;U+C804&gt;/&lt;U+C624&gt;&lt;U+D6C4&gt; 编码和时区问题是我们常面临的问题， 不正确设定导致我们的数据读取错误。 read_csv(readr_example(&quot;mtcars.csv&quot;),locale = locale(encoding = &#39;UTF-8&#39;,tz = &#39;Asia/Shanghai&#39;)) 关于locales,详细信息查看手册vignette(\"locales\")。 1.4.3 导出功能 由于系统缘故，在win系统下可能面临编码问题。我用readr导出数据时一般采用write_excel_csv()功能导出，目前还未遇到乱码情况。 需要说明的是write_系列函数可以将输出文件压缩。 data(storms, package = &quot;dplyr&quot;) write_csv(storms, &quot;storms.csv&quot;) write_csv(storms, &quot;storms.csv.gz&quot;) 1.4.4 总结 大部分情况下，当数据整洁时且不涉及时间(日期不影响)时，采用默认参数读取数据即可。当数据集前面行缺失值较多，readr自动猜数据列类型错误时，需要我们人为指定列类型。 read_csv(&#39;test.csv&#39;,col_types = &#39;cccnnnnDcnn&#39;) 由于Excel数字位数限制，在输出数字订单号或身份证时需要注意,: id_card &lt;- c(&#39;440327199910010123&#39;,&#39;440327199910010125&#39;) write_excel_csv(data.frame(id_card),&#39;test.csv&#39;) Excel最多只能存储15位数字型数字，15为之后都为0。 上面的输出显然会改变真实的身份证号码，这时我们就建议输出为xlsx的字符型或者是txt等格式，因为输出CSV会导致后面的全部变成0。 当编码时区不一致时，需指定locale()，如下： read_csv(readr_example(&quot;mtcars.csv&quot;),locale = locale(encoding = &#39;UTF-8&#39;,tz = &#39;Asia/Shanghai&#39;)) 矩形数据英文中表示为 rectangular data，矩形数据每一列都是变量(特征)，而每一行都是案例或记录,关系数据库中的单表就是矩形数据的一种。↩︎ "],["data-vroom.html", "1.5 vroom", " 1.5 vroom vroom实现读取矩形数据到R中,如 comma separated(csv),tab separated(tsv), fixed width files(fwf)。该包的功能类似readr::read_csv(),data.table::fread()和read.csv(),但是对于许多数据集来说，vroom::vroom()读取速度会快得多。 vroom项目地址 1.5.1 安装 # 从cran安装 install.packages(&quot;vroom&quot;) # install.packages(&quot;devtools&quot;) devtools::install_dev(&quot;vroom&quot;) 1.5.2 用法 读取文件 library(vroom) file &lt;- vroom_example(&quot;mtcars.csv&quot;) file #&gt; [1] &quot;C:/R/R-4.1.0/library/vroom/extdata/mtcars.csv&quot; vroom(file) #&gt; Rows: 32 #&gt; Columns: 12 #&gt; Delimiter: &quot;,&quot; #&gt; chr [ 1]: model #&gt; dbl [11]: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 32 x 12 #&gt; model mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 W~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Dr~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spor~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows vroom(file, delim = &quot;,&quot;) #&gt; Rows: 32 #&gt; Columns: 12 #&gt; Delimiter: &quot;,&quot; #&gt; chr [ 1]: model #&gt; dbl [11]: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 32 x 12 #&gt; model mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 Mazda RX4 W~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 Hornet 4 Dr~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 Hornet Spor~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows 读取多文件 即vroom::vroom()具备迭代效果,具体情况如下： mt &lt;- tibble::rownames_to_column(mtcars, &quot;model&quot;) purrr::iwalk( split(mt, mt$cyl), ~ vroom_write(.x, glue::glue(&quot;mtcars_{.y}.csv&quot;), &quot;\\t&quot;) ) files &lt;- fs::dir_ls(glob = &quot;mtcars*csv&quot;) files # read_csv purrr::map_dfr(files,readr::read_delim,delim=&quot;\\t&quot;) # vroom same above vroom(files) 读取压缩文件 vroom支持zip,gz,bz2,xz等压缩文件，只需要将压缩文件名称传递给vroom即可。 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file) 读取网络文件 #file &lt;- &quot;https://raw.githubusercontent.com/r-lib/vroom/master/inst/extdata/mtcars.csv&quot; file &lt;- &quot;http://www.zhongyufei.com/Rbook/data/data-table-groupingsets.csv&quot; vroom(file) #&gt; Rows: 18 #&gt; Columns: 4 #&gt; Delimiter: &quot;,&quot; #&gt; chr [3]: store_id, store_type, area #&gt; dbl [1]: value #&gt; #&gt; Use `spec()` to retrieve the guessed column specification #&gt; Pass a specification to the `col_types` argument to quiet this message #&gt; # A tibble: 18 x 4 #&gt; store_id store_type area value #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 A1 不可比 华东 9 #&gt; 2 A 可比 华东 87 #&gt; 3 B1 可比 华西 2 #&gt; 4 B 不可比 华西 42 #&gt; 5 C 可比 华南 79 #&gt; 6 D 不可比 华北 16 #&gt; # ... with 12 more rows 选择列读取 room提供了与dplyr::select()相同的列选择和重命名接口 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file, col_select = c(model, cyl, gear)) #&gt; # A tibble: 32 x 3 #&gt; model cyl gear #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Mazda RX4 6 4 #&gt; 2 Mazda RX4 Wag 6 4 #&gt; 3 Datsun 710 4 4 #&gt; 4 Hornet 4 Drive 6 3 #&gt; 5 Hornet Sportabout 8 3 #&gt; 6 Valiant 6 3 #&gt; # ... with 26 more rows # vroom(file, col_select = c(1, 3, 11)) # vroom(file, col_select = list(car = model, everything())) "],["data-rstudio-addins.html", "1.6 Rstudio导入", " 1.6 Rstudio导入 1.6.1 利用rstudio工具栏导入 本质也是调用readr和readxl包，如下所示： rstudio-load-data 1.6.2 插件导入 项目地址 datapasta是一个addins插件，方便将数据复制到R。 1.安装 install.packages(&quot;datapasta&quot;) 2.使用 datapasta "],["data-file-path.html", "1.7 文件路径", " 1.7 文件路径 我们读取数据时都是读取某路径下的某文件，但是由于系统等原因，路径在不同系统下的表示方式不一致。 1.7.1 指定路径 win 路径 winOS系统：C:\\Users\\zhongyf\\Desktop\\Rbook，注意路径中是一个反斜杠()。 win-path 在R中读取时需要用一个正斜杠或两个反斜杠。 readr::read_csv(&#39;C:/Users/zhongyf/Desktop/Rbook/data/flights.csv&#39;) readr::read_csv(&#39;C:\\\\Users\\\\zhongyf\\\\Desktop\\\\Rbook\\\\data\\flights.csv&#39;) # same above readr:::read_csv(file = r&quot;(C:\\Users\\zhongyf\\Desktop\\Rbook\\data\\flights.csv)&quot;) # same above 工作中，当需要读取或写入共享盘4中文件时，路径表示方式为： the_shared_disk &lt;- r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot; # load data into R readr::read_csv(file = &quot;\\\\\\\\192.168.2.117\\\\公司A-新\\\\01事业部\\\\flights.csv&quot;) readr::read_csv(file = r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot;) r“()”用法是R-4.0-之后的特性。在win系统下表示路径特别有用 mac 路径 macOS系统: /User/vega_mac/Desktop/r,路径中是一个正斜杠。 mac-path readr::read_csv(&#39;/User/vega_mac/Desktop/r/Rbook/data/flights.csv&#39;) 1.7.2 默认路径 getwd()是查看当前工作目录的函数，在进行文件读写时的默认路径，也就是当没有明确指定路径时，读取导出的默认路径是getwd()。想要改变工作目录，通过设定setwd()即可。 getwd() #&gt; [1] &quot;C:/Users/zhongyf/Desktop/Rbook&quot; # not run setwd(&#39;C:/Users/zhongyf/Desktop/Rbook/data&#39;) getwd() 共享盘的地址即某电脑(服务器)的地址，知道共享盘在局域网中的ip地址后在 开始-&gt;运行中输入\\192.168.1.247即可打开共享盘。↩︎ "],["data-expand.html", "1.8 拓展", " 1.8 拓展 feather项目地址https://github.com/wesm/feather qs提供接口，用于快速将R对象保存到磁盘以及从磁盘读取。该包的目标是替换R中的saveRDS和readRDS。项目地址https://github.com/traversc/qs arrow是feather的接替项目，地址https://arrow.apache.org/docs/r/ 其它统计学软件数据如spss，stata,SAs等可用foreign包读取 "],["Data-Manipulation-dplyr.html", "2 数据处理之-dplyr", " 2 数据处理之-dplyr 本章节主要目的是通过阐述dplyr动词用法，实现与Excel透视表或sql相同功能，从而达到不同的数据整理、聚合需求。 本章主要从以下方面阐述： 行条件筛选 列筛选 字段重命名 列位置排序 行排序 新增计算字段 分组聚合 表关联 行列操作 使用dplyr编写自定义函数 其中9,10行列操作和自定义函数有一定难度，大家可以先熟悉dplyr基本用法后再了解其用法。 与sql相比，用dplyr的优势： 代码量极大减少 逻辑复杂时，dplyr动词可以按照顺序一步步实现，无需嵌套，实现过程简单 代码可读性好 配合dbplyr包使用，大部分情况下可以扔掉sql语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用 本章节中部分案例照搬dplyr包的官方案例， dplyr动词从数据库相关操作中抽象而来，从sql迁移成本低 "],["dplyr-description.html", "2.1 前言", " 2.1 前言 dplyr包是tidyverse系列的核心包之一。dplyr是A Grammar of Data Manipulation ，即dplyr是数据处理的语法。数据操作在数据库中往往被增、改、删、查四字描述，加上表连接查询基本涵盖了大部分的数据操作。 dplyr包通过提供一组动词来解决最常见的数据处理问题： mutate() 添加新变量,现有变量的函数 select() 筛选列,根据现有变量名称选择变量 filter() 筛选行，根据条件筛选 summarise() 按照一定条件汇总聚合 arrange() 行排序 以上动词都可以和group_by()结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过vignette(\"two-table\")查看学习。 2.1.1 安装 dplyr包可以直接安装。 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;dplyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/dplyr&quot;) 在开始使用前，请确保自己dplyr版本是较新版本，因为1.0.0版本有较大更新。 packageVersion(&#39;dplyr&#39;) #&gt; [1] &#39;1.0.6&#39; 2.1.2 Excel and Sql 类比 与Excel相比,dplyr使用filter实现筛选，mutate实现列新增计算，summarise配合group_by实现数据透视表，arrange实现排序功能。 dplyr::left_join()等表连接功能，实现Excel中的vlookup,xlookup等函数效果。 请看案例： 案例中使用的数据集是R包nycflights13带的flights数据集。 Excel实现 透视表截图 R实现： library(tidyverse,warn.conflicts = FALSE) data &lt;- readr::read_csv(&quot;./data/flights.csv&quot;) data %&gt;% filter(year==2014,month==6) %&gt;% group_by(origin,dest) %&gt;% summarise(distance求和项 = sum(distance)) #&gt; # A tibble: 195 x 3 #&gt; # Groups: origin [3] #&gt; origin dest distance求和项 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 EWR ALB 715 #&gt; 2 EWR ANC 13480 #&gt; 3 EWR ATL 317050 #&gt; 4 EWR AUS 88736 #&gt; 5 EWR AVL 13409 #&gt; 6 EWR BDL 8236 #&gt; # ... with 189 more rows Sql实现： select origin,dest,sum(distance) distance求和项 from flights where year = 2014 and month =6 group by origin,dest Table 2.1: Displaying records 1 - 10 origin dest distance求和项 EWR ALB 715 EWR ANC 13480 EWR ATL 317050 EWR AUS 88736 EWR AVL 13409 EWR BDL 8236 EWR BNA 138380 EWR BOS 92600 EWR BQN 47550 EWR BTV 15960 2.1.3 常见问题 筛选订单表中的1-5月订单数据，按照城市汇总，求每个城市的销售额和门店数(去重)? data %&gt;% filter(between(月,1,5)) %&gt;% group_by(城市) %&gt;% summarise(金额 = sum(金额),门店数 = n_distinct(门店编码)) 近30天商品销量排名? data %&gt;% filter(订单日期 &gt;= Sys.Date()-30) %&gt;% group_by(分析大类,商品编码) %&gt;% summarise(商品销量 = sum(数量)) %&gt;% group_by(分析大类) %&gt;% mutate(商品排名 = dense_rank(desc(商品销量))) # 注意用desc倒序，销量高排第一 销售和库存形成笛卡尔积表，计算商品有货率、动销率? Cheat Sheet 手册搬运于dplyr官方介绍,方便下载查阅。 dplyr-sheet Rstudio提供的其它手册:https://www.rstudio.com/resources/cheatsheets/ "],["dplyr-usage.html", "2.2 基础用法", " 2.2 基础用法 基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述dplyr动词功能。 首先加载包，加载包时可能会有一些重名函数的提示，可以通过warn.conflict参数禁掉提示。如下所示： # 禁掉提示 library(dplyr,warn.conflicts = FALSE) 2.2.1 filter filter动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和SQL中where条件一致。 filter条件筛选中可以分为单条件筛选和多条件筛选；多条件中间用,分隔。 单条件 条件为species == \"Droid\"时，如下所示： starwars %&gt;% filter(species == &quot;Droid&quot;) #&gt; # A tibble: 6 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculi~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none masculi~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none masculi~ #&gt; 4 IG-88 200 140 none metal red 15 none masculi~ #&gt; 5 R4-P17 96 NA none silver, red red, blue NA none feminine #&gt; 6 BB8 NA NA none none black NA none masculi~ #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species = &quot;Droid&quot; -- 注意=与==的区别 多条件 多条件筛选时，用英文逗号隔开多个条件。用“and”连接多个条件与用逗号隔开效果相同,“and”在R中用&amp;表示。 starwars %&gt;% filter(species == &quot;Droid&quot;,skin_color == &quot;gold&quot;) #&gt; # A tibble: 1 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculine #&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; # same above # starwars %&gt;% # filter(species == &quot;Droid&quot; &amp; skin_color == &quot;gold&quot;) select * from starwars where species = &quot;Droid&quot; and skin_color = &quot;gold&quot; 多情况筛选 类似SQL中 in 的用法，或Excel中筛选条件时“或”条件 starwars %&gt;% filter(species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 7 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 2 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none mascu~ #&gt; 3 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ #&gt; 4 IG-88 200 140 none metal red 15 none mascu~ #&gt; 5 Zam We~ 168 55 blonde fair, green~ yellow NA fema~ femin~ #&gt; 6 R4-P17 96 NA none silver, red red, blue NA none femin~ #&gt; # ... with 1 more row, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars where species in (&quot;Droid&quot;,&quot;Clawdite&quot;) --sql查询 逻辑关系筛选 条件运算分为逻辑运算、关系运算。 关系运算符 &gt;、&lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。 逻辑运算符 &amp;、|、！。 |为 或, &amp; 为并、且条件，!为非。 library(nycflights13) filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # same above filter(flights, arr_delay &lt;= 120 &amp; dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 316,044 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; # %in% 的反面 starwars %&gt;% filter(!species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) #&gt; # A tibble: 80 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 3 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 4 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; 5 Beru Wh~ 165 75 brown light blue 47 fema~ femin~ #&gt; 6 Biggs D~ 183 84 black light brown 24 male mascu~ #&gt; # ... with 74 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; !的运算级别相比 %in% 更高 2.2.2 select 当完整数据集列较多时，我们某次分析可能并不需要那么多列，通过动词select()筛选列,剔除不需要的列。 基础用法 通过指定列名称筛选，并指定列之间顺序 starwars %&gt;% select(name,height,mass,hair_color,skin_color,eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows 列索引 通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。 starwars %&gt;% select(name : eye_color) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows #same above starwars %&gt;% select(1:6) #&gt; # A tibble: 87 x 6 #&gt; name height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Skywalker 172 77 blond fair blue #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, blue red #&gt; 4 Darth Vader 202 136 none white yellow #&gt; 5 Leia Organa 150 49 brown light brown #&gt; 6 Owen Lars 178 120 brown, grey light blue #&gt; # ... with 81 more rows # starwars %&gt;% select(c(1,2,4,5,7)) 新增列筛选方式 # starwars %&gt;% select(!(name:mass)) # iris %&gt;% select(!ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) &amp; ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) | ends_with(&quot;Width&quot;)) 2.2.3 rename 列重命名使用rename()函数，新名称写前面，如下所示： starwars %&gt;% rename(home_world = homeworld) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; # 多列同换 starwars %&gt;% rename(home_world = homeworld,skincolor = skin_color) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skincolor eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ 172 77 blond fair blue 19 male mascu~ #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 4 Darth V~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Leia Or~ 150 49 brown light brown 19 fema~ femin~ #&gt; 6 Owen La~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: home_world &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * ,homeworld as home_word from starwars select * ,homeworld home_word from starwars as 可以省略，但中间有一个以上空格。与R的差异是新增home_word列，原始列继续存在，R中是替换列名。 2.2.4 relocate 更改列顺序，与使用select()动词指定列顺序功能相似。 relocate参数如下： relocate(.data, ..., .before = NULL, .after = NULL) # sex:homeworld列在height列前面 starwars %&gt;% relocate(sex:homeworld, .before = height) #&gt; # A tibble: 87 x 14 #&gt; name sex gender homeworld height mass hair_color skin_color eye_color #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke Sk~ male mascul~ Tatooine 172 77 blond fair blue #&gt; 2 C-3PO none mascul~ Tatooine 167 75 &lt;NA&gt; gold yellow #&gt; 3 R2-D2 none mascul~ Naboo 96 32 &lt;NA&gt; white, bl~ red #&gt; 4 Darth V~ male mascul~ Tatooine 202 136 none white yellow #&gt; 5 Leia Or~ female femini~ Alderaan 150 49 brown light brown #&gt; 6 Owen La~ male mascul~ Tatooine 178 120 brown, gr~ light blue #&gt; # ... with 81 more rows, and 5 more variables: birth_year &lt;dbl&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 2.2.5 mutate 动词mutate可以新增计算列，删除列，更新已有列，列之间的计算都可以通过mutate实现。 新增计算列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% select(name:mass,bmi) #&gt; # A tibble: 87 x 4 #&gt; name height mass bmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 #&gt; 2 C-3PO 167 75 26.9 #&gt; 3 R2-D2 96 32 34.7 #&gt; 4 Darth Vader 202 136 33.3 #&gt; 5 Leia Organa 150 49 21.8 #&gt; 6 Owen Lars 178 120 37.9 #&gt; # ... with 81 more rows 新增计算列基础上新增列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2),newbmi = bmi *2) %&gt;% select(name:mass,bmi,newbmi) #&gt; # A tibble: 87 x 5 #&gt; name height mass bmi newbmi #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Luke Skywalker 172 77 26.0 52.1 #&gt; 2 C-3PO 167 75 26.9 53.8 #&gt; 3 R2-D2 96 32 34.7 69.4 #&gt; 4 Darth Vader 202 136 33.3 66.7 #&gt; 5 Leia Organa 150 49 21.8 43.6 #&gt; 6 Owen Lars 178 120 37.9 75.7 #&gt; # ... with 81 more rows 删除列 starwars %&gt;% mutate(height = NULL) #&gt; # A tibble: 87 x 13 #&gt; name mass hair_color skin_color eye_color birth_year sex gender homeworld #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Luke ~ 77 blond fair blue 19 male mascu~ Tatooine #&gt; 2 C-3PO 75 &lt;NA&gt; gold yellow 112 none mascu~ Tatooine #&gt; 3 R2-D2 32 &lt;NA&gt; white, bl~ red 33 none mascu~ Naboo #&gt; 4 Darth~ 136 none white yellow 41.9 male mascu~ Tatooine #&gt; 5 Leia ~ 49 brown light brown 19 fema~ femin~ Alderaan #&gt; 6 Owen ~ 120 brown, gr~ light blue 52 male mascu~ Tatooine #&gt; # ... with 81 more rows, and 4 more variables: species &lt;chr&gt;, films &lt;list&gt;, #&gt; # vehicles &lt;list&gt;, starships &lt;list&gt; 2.2.6 arrange 单列排序，默认升序，通过desc()降序排列 starwars %&gt;% arrange(desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Jabba ~ 175 1358 &lt;NA&gt; green-tan,~ orange 600 herm~ mascu~ #&gt; 2 Grievo~ 216 159 none brown, whi~ green, y~ NA male mascu~ #&gt; 3 IG-88 200 140 none metal red 15 none mascu~ #&gt; 4 Darth ~ 202 136 none white yellow 41.9 male mascu~ #&gt; 5 Tarfful 234 136 brown brown blue NA male mascu~ #&gt; 6 Owen L~ 178 120 brown, grey light blue 52 male mascu~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 多列排序 starwars %&gt;% arrange(height,desc(mass)) #&gt; # A tibble: 87 x 14 #&gt; name height mass hair_color skin_color eye_color birth_year sex gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Yoda 66 17 white green brown 896 male mascu~ #&gt; 2 Ratts Ty~ 79 15 none grey, blue unknown NA male mascu~ #&gt; 3 Wicket S~ 88 20 brown brown brown 8 male mascu~ #&gt; 4 Dud Bolt 94 45 none blue, grey yellow NA male mascu~ #&gt; 5 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ #&gt; 6 R4-P17 96 NA none silver, r~ red, blue NA none femin~ #&gt; # ... with 81 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, #&gt; # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; select * from starwars order by height,mass desc 2.2.7 summarise summarise常与group_by结合使用。 mtcars %&gt;% summarise(mean = mean(disp), n = n()) #&gt; # A tibble: 1 x 2 #&gt; mean n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 231. 32 n()是dplyr包中的计算当前组的大小，用在summarise()和mutate()中。通常可用来组计算。 2.2.8 group_by 聚合前一般都需要分组，group_by()动词实现该功能，与SQL中group by ···类似。 starwars %&gt;% group_by(species) %&gt;% summarise( n = n(), mass = mean(mass, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n mass #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 15 #&gt; 2 Besalisk 1 102 #&gt; 3 Cerean 1 82 #&gt; 4 Chagrian 1 NaN #&gt; 5 Clawdite 1 55 #&gt; 6 Droid 6 69.8 #&gt; # ... with 32 more rows SELECT species, count(species) n, AVG(mass) mass FROM [spb].[dbo].[starwars] GROUP BY species "],["dplyr-merge-two-table.html", "2.3 表关联", " 2.3 表关联 表关联指像sql中的left join,inner join等表格之间的操作，或者是Excel中Power Piovt建模的建立关系，从而实现不同表格间的关联。 2.3.1 基础操作 left_join(),full_join,inner_join()等动词关联两个表。详情请查看：vignette(\"two-table\") left_join()实现类似Excel中VLOOKUP函数功能或数据库中left join功能，将“右表”的字段依据“主键”关联到“左表”上。 基础用法 left_join(),right_join(),full_join(),inner_join()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中连接方式一致。 默认会自动寻找两表中相同的字段名作为关联的条件 library(&quot;nycflights13&quot;) # Drop unimportant variables so it&#39;s easier to understand the join results. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% left_join(airlines) #&gt; Joining, by = &quot;carrier&quot; #&gt; # A tibble: 336,776 x 9 #&gt; year month day hour origin dest tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. #&gt; # ... with 336,770 more rows 指定关联条件列，类似数据库中on a.column = b.column。 R实现 flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) #&gt; # A tibble: 336,776 x 16 #&gt; year.x month day hour origin dest tailnum carrier year.y type #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA 1999 Fixed wing multi~ #&gt; 2 2013 1 1 5 LGA IAH N24211 UA 1998 Fixed wing multi~ #&gt; 3 2013 1 1 5 JFK MIA N619AA AA 1990 Fixed wing multi~ #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 2012 Fixed wing multi~ #&gt; 5 2013 1 1 6 LGA ATL N668DN DL 1991 Fixed wing multi~ #&gt; 6 2013 1 1 5 EWR ORD N39463 UA 2012 Fixed wing multi~ #&gt; # ... with 336,770 more rows, and 6 more variables: manufacturer &lt;chr&gt;, #&gt; # model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt; Sql实现 select * from flights2 a left join planes b on a.tailnum = b.tailnum 不同名称列关联 left_join(x,y,by = c(\"a\" = \"b\", \"c\" = \"d\")) 将会匹配 x$a to y$b 和 x$c to y$d 作为关联条件 #出发机场和目的机场信息 flights2 %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 x 15 #&gt; year month day hour origin dest tailnum carrier name lat lon alt #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA George~ 30.0 -95.3 97 #&gt; 2 2013 1 1 5 LGA IAH N24211 UA George~ 30.0 -95.3 97 #&gt; 3 2013 1 1 5 JFK MIA N619AA AA Miami ~ 25.8 -80.3 8 #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 &lt;NA&gt; NA NA NA #&gt; 5 2013 1 1 6 LGA ATL N668DN DL Hartsf~ 33.6 -84.4 1026 #&gt; 6 2013 1 1 5 EWR ORD N39463 UA Chicag~ 42.0 -87.9 668 #&gt; # ... with 336,770 more rows, and 3 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, #&gt; # tzone &lt;chr&gt; #flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) # 组合条件 多条件时用向量包裹即可c(&quot;dest&quot; = &quot;faa&quot;,&quot;cola&quot; = &quot;colb&quot;)) 筛选连接 anti_join() 删除所有左表中在右表中匹配到的行 semi_join()保留所有左表在右表中匹配到的行 df1 &lt;- tibble(a=letters[1:20],b=1:20) df2 &lt;- tibble(a=letters,b=1:26) df1 %&gt;% semi_join(df2) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 20 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 a 1 #&gt; 2 b 2 #&gt; 3 c 3 #&gt; 4 d 4 #&gt; 5 e 5 #&gt; 6 f 6 #&gt; # ... with 14 more rows df2 %&gt;% anti_join(df1) #&gt; Joining, by = c(&quot;a&quot;, &quot;b&quot;) #&gt; # A tibble: 6 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 u 21 #&gt; 2 v 22 #&gt; 3 w 23 #&gt; 4 x 24 #&gt; 5 y 25 #&gt; 6 z 26 集合操作 intersect(x,y)返回x,y交集 union(x,y)返回x,y中唯一的值 setdiff(x,y)返回存在x中但是不存在y中的记录 (df1 &lt;- tibble(x = 1:2, y = c(1L, 1L))) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 (df2 &lt;- tibble(x = 1:2, y = 1:2)) #&gt; # A tibble: 2 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 2 intersect(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 union(df1, df2) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 2 2 setdiff(df1, df2) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 1 setdiff(df2, df1) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2 2 2.3.2 多表操作 当我们需要将多个表格连续关联时: 常规写法 dt1 &lt;- data.frame(x = letters) dt2 &lt;- data.frame(x = letters,cola = 1:26) dt3 &lt;- data.frame(x = letters,colb = 1:26) dt4 &lt;- data.frame(x = letters,cold = 1:26) dt5 &lt;- data.frame(x = letters,cole = 1:26) dt1 %&gt;% left_join(dt2) %&gt;% left_join(dt3) %&gt;% left_join(dt4) %&gt;% left_join(dt5) #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; Joining, by = &quot;x&quot; #&gt; x cola colb cold cole #&gt; 1 a 1 1 1 1 #&gt; 2 b 2 2 2 2 #&gt; 3 c 3 3 3 3 #&gt; 4 d 4 4 4 4 #&gt; 5 e 5 5 5 5 #&gt; 6 f 6 6 6 6 #&gt; 7 g 7 7 7 7 #&gt; 8 h 8 8 8 8 #&gt; 9 i 9 9 9 9 #&gt; 10 j 10 10 10 10 #&gt; 11 k 11 11 11 11 #&gt; 12 l 12 12 12 12 #&gt; 13 m 13 13 13 13 #&gt; 14 n 14 14 14 14 #&gt; 15 o 15 15 15 15 #&gt; 16 p 16 16 16 16 #&gt; 17 q 17 17 17 17 #&gt; 18 r 18 18 18 18 #&gt; 19 s 19 19 19 19 #&gt; 20 t 20 20 20 20 #&gt; 21 u 21 21 21 21 #&gt; 22 v 22 22 22 22 #&gt; 23 w 23 23 23 23 #&gt; 24 x 24 24 24 24 #&gt; 25 y 25 25 25 25 #&gt; 26 z 26 26 26 26 改进写法 当需要合并多个表格时，可用purrr::reduce()实现 dtlist &lt;- list(dt1,dt2,dt3,dt4,dt5) purrr::reduce(dtlist,left_join,by=&#39;x&#39;) #&gt; x cola colb cold cole #&gt; 1 a 1 1 1 1 #&gt; 2 b 2 2 2 2 #&gt; 3 c 3 3 3 3 #&gt; 4 d 4 4 4 4 #&gt; 5 e 5 5 5 5 #&gt; 6 f 6 6 6 6 #&gt; 7 g 7 7 7 7 #&gt; 8 h 8 8 8 8 #&gt; 9 i 9 9 9 9 #&gt; 10 j 10 10 10 10 #&gt; 11 k 11 11 11 11 #&gt; 12 l 12 12 12 12 #&gt; 13 m 13 13 13 13 #&gt; 14 n 14 14 14 14 #&gt; 15 o 15 15 15 15 #&gt; 16 p 16 16 16 16 #&gt; 17 q 17 17 17 17 #&gt; 18 r 18 18 18 18 #&gt; 19 s 19 19 19 19 #&gt; 20 t 20 20 20 20 #&gt; 21 u 21 21 21 21 #&gt; 22 v 22 22 22 22 #&gt; 23 w 23 23 23 23 #&gt; 24 x 24 24 24 24 #&gt; 25 y 25 25 25 25 #&gt; 26 z 26 26 26 26 "],["dplyr-functions.html", "2.4 常用函数", " 2.4 常用函数 本小节介绍数据分析中常用的函数，类似Excel中的if函数，sql中的case_when,count,distinct,row_number,between等函数。 2.4.1 条件判断 相比于base::ifelse,if_else更为严格，无论TRUE或FALSE输出类型一致，这样速度更快。与data.table::fifelse()功能相似。 if_else(condition, true, false, missing = NULL) 与ifelse不同的是，if_else保留类型 x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] 1 2 NA 2 1 NA 1 2 3 1 if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) #&gt; [1] a b &lt;NA&gt; b a &lt;NA&gt; a b c a #&gt; Levels: a b c d e 2.4.2 case_when 当条件嵌套条件较多时，使用case_when,使代码可读并且不易出错。与sql 中的case when 等价。 Dates &lt;- as.Date(c(&#39;2018-10-01&#39;, &#39;2018-10-02&#39;, &#39;2018-10-03&#39;,&#39;2018-10-04&#39;)) case_when( Dates == &#39;2018-10-01&#39; ~ Dates - 1, Dates == &#39;2018-10-02&#39; ~ Dates + 1, Dates == &#39;2018-10-03&#39; ~ Dates + 2, TRUE ~ Dates ) #&gt; [1] &quot;2018-09-30&quot; &quot;2018-10-03&quot; &quot;2018-10-05&quot; &quot;2018-10-04&quot; 2.4.3 计数函数 计数 count()函数用来计数。下面两种表达方式等价。 df %&gt;% count(a, b) # same above df %&gt;% group_by(a, b) %&gt;% summarise(n = n()) starwars %&gt;% count(species) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows # same above 等价 starwars %&gt;% group_by(species) %&gt;% summarise(n = n()) #&gt; # A tibble: 38 x 2 #&gt; species n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aleena 1 #&gt; 2 Besalisk 1 #&gt; 3 Cerean 1 #&gt; 4 Chagrian 1 #&gt; 5 Clawdite 1 #&gt; 6 Droid 6 #&gt; # ... with 32 more rows 非重复计数 n_distinct()与length(unique(x))等价，但是更快更简洁。当我们需要给门店或订单之类数据需要去重计算时采用该函数。 x &lt;- sample(1:10, 1e5, rep = TRUE) length(unique(x)) #&gt; [1] 10 n_distinct(x) #&gt; [1] 10 2.4.4 排序函数 dplyr共六种排序函数，模仿SQL2003中的排名函数。 row_number():等于 rank(ties.method = “first”) min_rank(): 等于 rank(ties.method = “min”) dense_rank(): 与min_rank()相似,但是没有间隔 percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1] x &lt;- c(5, 1, 3, 2, 2, NA) row_number(x) #&gt; [1] 5 1 4 2 3 NA min_rank(x) #&gt; [1] 5 1 4 2 2 NA dense_rank(x) #&gt; [1] 4 1 3 2 2 NA percent_rank(x) #&gt; [1] 1.00 0.00 0.75 0.25 0.25 NA cume_dist(x) #&gt; [1] 1.0 0.2 0.8 0.6 0.6 NA 2.4.5 提取向量 该系列函数是对[[的包装。 nth(x, n, order_by = NULL, default = default_missing(x)) first(x, order_by = NULL, default = default_missing(x)) last(x, order_by = NULL, default = default_missing(x)) x &lt;- 1:10 y &lt;- 10:1 first(x) #&gt; [1] 1 last(y) #&gt; [1] 1 nth(x, 1) #&gt; [1] 1 nth(x, 5) #&gt; [1] 5 2.4.6 group 系列 group_by(),group_map(), group_nest(), group_split(), group_trim()等一系列函数。 其中我常用group_by(),group_split()两个函数。group_by()是大部分数据操作中的分组操作，按照group_by()的指定分组条件。 group_by() #group_by()不会改变数据框 by_cyl &lt;- mtcars %&gt;% group_by(cyl) by_cyl #&gt; # A tibble: 32 x 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with 26 more rows # It changes how it acts with the other dplyr verbs: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) #&gt; # A tibble: 3 x 3 #&gt; cyl disp hp #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 105. 82.6 #&gt; 2 6 183. 122. #&gt; 3 8 353. 209. # group_by中可以添加计算字段 即mutate操作 mtcars %&gt;% group_by(vsam = vs + am) %&gt;% group_vars() #&gt; [1] &quot;vsam&quot; group_map() group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据的数据清洗一般不涉及，常用在建模等方面。 但是目前三个函数是实验性的，未来可能会发生变化。 # return a list # 返回列表 mtcars %&gt;% group_by(cyl) %&gt;% group_map(~ head(.x, 2L)) #&gt; [[1]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 22.8 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; #&gt; [[2]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 21 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; #&gt; [[3]] #&gt; # A tibble: 2 x 10 #&gt; mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 18.7 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 2 14.3 360 245 3.21 3.57 15.8 0 0 3 4 iris %&gt;% group_by(Species) %&gt;% group_modify(~ { .x %&gt;% purrr::map_dfc(fivenum) %&gt;% mutate(nms = c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;)) }) #&gt; # A tibble: 15 x 6 #&gt; # Groups: Species [3] #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width nms #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 setosa 4.3 2.3 1 0.1 min #&gt; 2 setosa 4.8 3.2 1.4 0.2 Q1 #&gt; 3 setosa 5 3.4 1.5 0.2 median #&gt; 4 setosa 5.2 3.7 1.6 0.3 Q3 #&gt; 5 setosa 5.8 4.4 1.9 0.6 max #&gt; 6 versicolor 4.9 2 3 1 min #&gt; # ... with 9 more rows 分组后批量输出 # group_walk dir.create(temp &lt;- tempfile()) iris %&gt;% group_by(Species) %&gt;% group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, &quot;.csv&quot;)))) list.files(temp, pattern = &quot;csv$&quot;) unlink(temp, recursive = TRUE) group_cols() 选择分组变量 gdf &lt;- iris %&gt;% group_by(Species) gdf %&gt;% select(group_cols()) #&gt; # A tibble: 150 x 1 #&gt; # Groups: Species [3] #&gt; Species #&gt; &lt;fct&gt; #&gt; 1 setosa #&gt; 2 setosa #&gt; 3 setosa #&gt; 4 setosa #&gt; 5 setosa #&gt; 6 setosa #&gt; # ... with 144 more rows 2.4.7 其它函数 between cummean cumsum cumall cumany 累计系列函数 x &lt;- c(1, 3, 5, 2, 2) cummean(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumsum(x) / seq_along(x) #&gt; [1] 1.00 2.00 3.00 2.75 2.60 cumall(x &lt; 5) #&gt; [1] TRUE TRUE FALSE FALSE FALSE cumany(x == 3) #&gt; [1] FALSE TRUE TRUE TRUE TRUE distinct df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) distinct(df, x) distinct(df, x, .keep_all = TRUE) distinct(df, diff = abs(x - y)) "],["dplyr-groupby-manipulation.html", "2.5 分组操作", " 2.5 分组操作 详情: https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html group_by()最重要的分组动词,需要一个数据框和一个或多个变量进行分组： 2.5.1 添加分组 by_species &lt;- starwars %&gt;% group_by(species) by_sex_gender &lt;- starwars %&gt;% group_by(sex, gender) 除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在mutate()之后执行group_by: bmi_breaks &lt;- c(0, 18.5, 25, 30, Inf) starwars %&gt;% group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %&gt;% tally() #&gt; # A tibble: 5 x 2 #&gt; bmi_cat n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 (0,18.5] 10 #&gt; 2 (18.5,25] 24 #&gt; 3 (25,30] 13 #&gt; 4 (30,Inf] 12 #&gt; 5 &lt;NA&gt; 28 2.5.2 删除分组变量 要删除所有分组变量，使用ungroup(): by_species %&gt;% ungroup() %&gt;% tally() #&gt; # A tibble: 1 x 1 #&gt; n #&gt; &lt;int&gt; #&gt; 1 87 2.5.3 动词 summarise() 计算每个组的汇总，表示从group_keys开始右侧添加汇总变量 by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE) ) #&gt; # A tibble: 38 x 3 #&gt; species n height #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Aleena 1 79 #&gt; 2 Besalisk 1 198 #&gt; 3 Cerean 1 198 #&gt; 4 Chagrian 1 196 #&gt; 5 Clawdite 1 168 #&gt; 6 Droid 6 131. #&gt; # ... with 32 more rows 该.groups=参数控制输出的分组结构。删除右侧分组变量的历史行为对应于.groups = “drop_last”没有消息或.groups = NULL有消息（默认值）。 从1.0.0版开始，分组信息可以保留(.groups = \"keep\")或删除 (.groups = 'drop) a &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;drop&#39;) %&gt;% group_vars() b &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;keep&#39;) %&gt;% group_vars() object.size(a) #&gt; 48 bytes object.size(b) #&gt; 112 bytes 在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。 "],["dplyr-column-manipulation.html", "2.6 列操作", " 2.6 列操作 函数across()通过与summarise()和mutate()结合，很容易将某函数运用到多列上。函数across()取代了summarise_all(),summarise_at(),summarise_if()函数。 在多列上执行相同的函数是常用的操作，但是通过复制和粘贴代码，麻烦并且容易错,如下所示: df %&gt;% group_by(g1, g2) %&gt;% summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d)) 通过across()函数可以更简洁地重写上面代码： df %&gt;% group_by(g1, g2) %&gt;% summarise(across(a:d, mean)) 假设我们要将表格中多列向上取整? dt &lt;- tibble(a= rnorm(100,mean = 1),b=rnorm(100,mean = 1),d=rnorm(100,mean = 1)) dt %&gt;% mutate(across(a:d,ceiling)) #&gt; # A tibble: 100 x 3 #&gt; a b d #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 2 #&gt; 2 1 2 2 #&gt; 3 2 1 1 #&gt; 4 1 1 1 #&gt; 5 1 1 1 #&gt; 6 2 3 1 #&gt; # ... with 94 more rows 2.6.1 基础用法 across() 有两个主要参数： 第一个参数，.cols选择要操作的列。它使用tidyr的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。 第二个参数，.fns是要应用于每一列的一个函数或函数列表。 也可以是purrr样式的公式（或公式列表），例如~ .x / 2。 starwars %&gt;% summarise(across(where(is.character), ~ length(unique(.x)))) #&gt; # A tibble: 1 x 8 #&gt; name hair_color skin_color eye_color sex gender homeworld species #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 87 13 31 15 5 3 49 38 starwars %&gt;% group_by(species) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(c(sex, gender, homeworld), ~ length(unique(.x)))) #&gt; # A tibble: 9 x 4 #&gt; species sex gender homeworld #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Droid 1 2 3 #&gt; 2 Gungan 1 1 1 #&gt; 3 Human 2 2 16 #&gt; 4 Kaminoan 2 2 1 #&gt; 5 Mirialan 1 1 1 #&gt; 6 Twi&#39;lek 2 2 1 #&gt; # ... with 3 more rows starwars %&gt;% group_by(homeworld) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) #&gt; # A tibble: 10 x 4 #&gt; homeworld height mass birth_year #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 176. 64 43 #&gt; 2 Corellia 175 78.5 25 #&gt; 3 Coruscant 174. 50 91 #&gt; 4 Kamino 208. 83.1 31.5 #&gt; 5 Kashyyyk 231 124 200 #&gt; 6 Mirial 168 53.1 49 #&gt; # ... with 4 more rows ~ .x / 2是purr包提供的函数式编程风格，等效于 function(x) (x/2) across() 不会选择分组变量： df &lt;- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9)) df %&gt;% group_by(g) %&gt;% summarise(across(where(is.numeric), sum)) #&gt; # A tibble: 2 x 3 #&gt; g x y #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 -5 #&gt; 2 2 3 -9 2.6.2 多种函数功能 通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量： min_max &lt;- list( min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE) ) starwars %&gt;% summarise(across(where(is.numeric), min_max)) #&gt; # A tibble: 1 x 6 #&gt; height_min height_max mass_min mass_max birth_year_min birth_year_max #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 通过.names参数控制名称： NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时 以下是官方案例，但是报错(目前已修复)： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{.fn}.{.col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; min.height max.height min.mass max.mass min.birth_year max.birth_year #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 修改后正常运行： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}.{col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; min.height max.height min.mass max.mass min.birth_year max.birth_year #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 896 区别主要是.names参数的使用方式问题，.加不加的问题。 starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}——{col}&quot;)) #&gt; # A tibble: 1 x 6 #&gt; `min——height` `max——height` `min——mass` `max——mass` `min——birth_year` #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 66 264 15 1358 8 #&gt; # ... with 1 more variable: max——birth_year &lt;dbl&gt; 2.6.3 当前列 如果需要，可以通过调用访问内部的“当前”列的名称cur_column(),仅在across()使用。和Excel中power pivot的“上下文”概念类似。 该函数不是特别容易理解，需要多尝试使用加深认识。 df &lt;- tibble(x = 1:3, y = 3:5, z = 5:7) mult &lt;- list(x = 1, y = 10, z = 100) df %&gt;% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]])) #&gt; # A tibble: 3 x 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 30 500 #&gt; 2 2 40 600 #&gt; 3 3 50 700 代码解释：代码实现的是数据框df中列和mult中同名元素相乘得到新列。mult[[cur_column()]]依次返回mult[[“x”]],mult[[“y”]],mult[[“z”]]。 以上部分是关于列操作的内容，详情查看vignette(\"colwise\")。 "],["dplyr-row-manipulation.html", "2.7 行操作", " 2.7 行操作 行操作指不同字段间的计算，如Excle的列与列之间计算,Excle中的函数对行列不敏感，没有明显区别，但是R中tidyverse里列计算简单，行间计算依赖rowwise()函数实现。 Excel-sum df &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() #&gt; # A tibble: 2 x 3 #&gt; # Rowwise: #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 #&gt; 2 2 4 6 df %&gt;% rowwise() %&gt;% mutate(total = sum(c(x, y, z))) #返回结果与Excel一致 #&gt; # A tibble: 2 x 4 #&gt; # Rowwise: #&gt; x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 9 #&gt; 2 2 4 6 12 df %&gt;% mutate(total = sum(c(x, y, z))) # 返回结果不符合预期 #&gt; # A tibble: 2 x 4 #&gt; x y z total #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 3 5 21 #&gt; 2 2 4 6 21 2.7.1 比较差异 像group_by(),rowwise()并没有做任何事情，它的作用是改变其他动词的工作方式。 注意以下代码返回结果不同: df %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3.5 #&gt; 2 2 4 6 3.5 df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 2 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 3 5 3 #&gt; 2 2 4 6 4 df %&gt;% mutate(m = mean(c(x, y, z)))返回的结果是x,y,z散列全部数据的均值；df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))通过rowwise改变了mean的作为范围，返回的某行x,y,z列3个数字的均值。两种动词的作用的范围因为rowwise完全改变。 可以选择在调用中提供“标识符”变量rowwise()。这些变量在您调用时被保留summarise()，因此它们的行为与传递给的分组变量有些相似group_by()： df &lt;- tibble(name = c(&quot;Mara&quot;, &quot;Hadley&quot;), x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has ungrouped output. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 1 #&gt; m #&gt; &lt;dbl&gt; #&gt; 1 3 #&gt; 2 4 df %&gt;% rowwise(name) %&gt;% summarise(m = mean(c(x, y, z))) #&gt; `summarise()` has grouped output by &#39;name&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 2 x 2 #&gt; # Groups: name [2] #&gt; name m #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Mara 3 #&gt; 2 Hadley 4 2.7.2 常用案例 df &lt;- tibble(x = runif(6), y = runif(6), z = runif(6)) # Compute the mean of x, y, z in each row df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) #&gt; # A tibble: 6 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.652 0.153 0.751 0.518 #&gt; 2 0.341 0.905 0.645 0.630 #&gt; 3 0.996 0.216 0.806 0.673 #&gt; 4 0.546 0.644 0.338 0.509 #&gt; 5 0.629 0.921 0.377 0.642 #&gt; 6 0.545 0.791 0.428 0.588 # Compute the minimum of x and y in each row df %&gt;% rowwise() %&gt;% mutate(m = min(c(x, y, z))) #&gt; # A tibble: 6 x 4 #&gt; # Rowwise: #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.652 0.153 0.751 0.153 #&gt; 2 0.341 0.905 0.645 0.341 #&gt; 3 0.996 0.216 0.806 0.216 #&gt; 4 0.546 0.644 0.338 0.338 #&gt; 5 0.629 0.921 0.377 0.377 #&gt; 6 0.545 0.791 0.428 0.428 # In this case you can use an existing vectorised function: df %&gt;% mutate(m = pmin(x, y, z)) #&gt; # A tibble: 6 x 4 #&gt; x y z m #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.652 0.153 0.751 0.153 #&gt; 2 0.341 0.905 0.645 0.341 #&gt; 3 0.996 0.216 0.806 0.216 #&gt; 4 0.546 0.644 0.338 0.338 #&gt; 5 0.629 0.921 0.377 0.377 #&gt; 6 0.545 0.791 0.428 0.428 键入每个变量名称很繁琐，通过c_across()使更简单。 详情可见vignette(“rowwise”)。 rf %&gt;% mutate(total = sum(c_across(w:z))) rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) rf %&gt;% mutate(total = sum(c_across(w:z))) %&gt;% ungroup() %&gt;% mutate(across(w:z, ~ . / total)) "],["dplyr-programming.html", "2.8 dplyr编程", " 2.8 dplyr编程 Programming with dplyr 本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。虽然复杂,但是比较实用，尤其是当我们需要定义一些通用功能函数时。 以下是对原文引用 两种情况： When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like filter(df, {{ var }}). The following function uses embracing to create a wrapper around summarise() that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised: var_summary &lt;- function(data, var) { data %&gt;% summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])). The following example uses .data to count the number of unique values in each variable of mtcars: for (var in names(mtcars)) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with .data$x or indirectly with .data[[var]]. Don’t expect other functions to work with it. 2.8.1 案例 当我们不知道接下来会用哪个变量汇总时： my_summarise &lt;- function(data, group_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean(mass)) } 如果在多个位置使用： my_summarise2 &lt;- function(data, expr) { data %&gt;% summarise( mean = mean({{ expr }}), sum = sum({{ expr }}), n = n() ) } 当多个表达式时： my_summarise3 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } 如果要输出变量名时： my_summarise4 &lt;- function(data, expr) { data %&gt;% summarise( &quot;mean_{{expr}}&quot; := mean({{ expr }}), &quot;sum_{{expr}}&quot; := sum({{ expr }}), &quot;n_{{expr}}&quot; := n() ) } my_summarise5 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise( &quot;mean_{{mean_var}}&quot; := mean({{ mean_var }}), &quot;sd_{{sd_var}}&quot; := mean({{ sd_var }}) ) } 任意个表达式： 这种使用场景更多 my_summarise &lt;- function(.data, ...) { .data %&gt;% group_by(...) %&gt;% summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE)) } starwars %&gt;% my_summarise(homeworld) #&gt; # A tibble: 49 x 3 #&gt; homeworld mass height #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alderaan 64 176. #&gt; 2 Aleen Minor 15 79 #&gt; 3 Bespin 79 175 #&gt; 4 Bestine IV 110 180 #&gt; 5 Cato Neimoidia 90 191 #&gt; 6 Cerea 82 198 #&gt; # ... with 43 more rows starwars %&gt;% my_summarise(sex, gender) #&gt; `summarise()` has grouped output by &#39;sex&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 6 x 4 #&gt; # Groups: sex [5] #&gt; sex gender mass height #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 female feminine 54.7 169. #&gt; 2 hermaphroditic masculine 1358 175 #&gt; 3 male masculine 81.0 179. #&gt; 4 none feminine NaN 96 #&gt; 5 none masculine 69.8 140 #&gt; 6 &lt;NA&gt; &lt;NA&gt; 48 181. "],["dplyr-reference-material.html", "2.9 参考资料", " 2.9 参考资料 1.programming https://dplyr.tidyverse.org/dev/articles/programming.html 2.https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html "],["Data-tidyr-package.html", "3 tidyr", " 3 tidyr 在实际工作中，我们数据分析工作者80%的时间可能贡献在数据准备和数据清晰上。另外发现新问题时，可能又要重复数据准备、数据清晰的过程。如果采用不能完全复现的方式做数据准备清洗的工作，那将是一场灾难。 数据工作者最常用的工具可能是Excel,但是Excel并不具备很强的数据清洗能力，即使Excel有POwer query 、Dax等两大利器。工作中，实际面临原始的数据是脏乱无须的，业务系统仅仅只是记录了历史过程数据。当我们需要分析某一现象时，需要按照自己的需求重新采集数据，清洗为“标准”的数据格式。 标准数据：达到工作需求的数据，可以直接用Excel,power bi ，tableau等BI工具直接使用的程度。 R中的tidyverse系列构建了一种一致的数据结构，当我们用tidyverse软件包提供的“数据整洁工具”整洁数据时，我们将花费更少的时间将数据从一种形式迁移到另外一种形式。从而，我们拥有更多的时间专注在具体的业务问题上。 "],["tidyr-install.html", "3.1 安装", " 3.1 安装 本章节，我们重点关注tidyr包，这个软件包提供了许多的功能函数整理混乱的数据。tidyr是tidyverse的核心成员包 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;tidyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/tidyr&quot;) # CTEST CODE "],["tidyr-useage.html", "3.2 主要功能", " 3.2 主要功能 整洁的数据表现为： 每个变量是单独的一列 每一个观察的值都在自己的行 每一个值都是独立的单元格 大部分的数据集都是用行和列构成的data.frame。用Excel的单元格来表示，即每列代表不同意义的字段，每行是某个情形下的一系列字段；单元格则是独立的值,属于某个变量的观察值，这样构建的二维数据结构则是“整洁数据”。 library(tidyr) tidyr包中的函数可以分为5个主要大类 pivot_longer() 和 pivot_wider() 宽转长以及长转宽 unnest_longer() 和 unnest_wider(),hoist() 将列表嵌套转化为整洁数据 nest() 数据嵌套 separate(),extract()拆分列,提取新列 replace_na() 缺失值处理 3.2.1 宽转长 详情查看vignette(\"pivot\"),以下是照搬该图册中的内容 3.2.1.1 基础 长数据与宽数据之间的转换，类似我们常用的EXcel中的透视表功能。接下来用tidyr包自带的插图案例记录相关函数用法 在Excel中有时候方便我们肉眼观察，可能一个数据集会有很多列,如下所示： col1 col2 col3 col4 col5 col6 col7 v1 v2 v3 v4 v5 v6 v7 vb1 vb2 vb3 vb4 vb5 vb6 vb7 方便观察，但是不方便统计分析，这是我们需要把数据做处理，从“宽数据变成长数据”即宽转长。 library(tidyr) library(dplyr) library(readr) relig_income %&gt;% pivot_longer(cols = !religion,names_to = &#39;income&#39;,values_to = &quot;count&quot;) #&gt; # A tibble: 180 x 3 #&gt; religion income count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Agnostic &lt;$10k 27 #&gt; 2 Agnostic $10-20k 34 #&gt; 3 Agnostic $20-30k 60 #&gt; 4 Agnostic $30-40k 81 #&gt; 5 Agnostic $40-50k 76 #&gt; 6 Agnostic $50-75k 137 #&gt; # ... with 174 more rows 第一个参数是数据集 第二个参数是那些列需要重塑，在该例中除了religion的其他全部列 names_to这个参数是新增的列名 values_to是新增的存储之前数据集中数据的列名 3.2.1.2 列名带数字 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE ) #&gt; # A tibble: 5,307 x 5 #&gt; artist track date.entered week rank #&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 #&gt; 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 #&gt; 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 #&gt; 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 #&gt; 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 #&gt; 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk6 94 #&gt; # ... with 5,301 more rows names_prefix 调整内容前缀，配合names_transform参数使用 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, names_transform = list(week = as.integer), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) #&gt; # A tibble: 5,307 x 5 #&gt; artist track date.entered week rank #&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 1 87 #&gt; 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 2 82 #&gt; 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 3 72 #&gt; 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 4 77 #&gt; 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 5 87 #&gt; 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 6 94 #&gt; # ... with 5,301 more rows 经过以上转换week列属性变成了整数，当然达到以上效果有其他的途径，如下： library(tidyverse,warn.conflicts = TRUE) # method 1 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_transform = list(week = readr::parse_number), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) # method 2 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE, ) %&gt;% mutate(week = str_remove(week, &quot;wk&quot;) %&gt;% as.integer()) 3.2.1.3 多变量列名 该案列设计比较复杂的正则表达式,new_?(.*)_(.)(.*)需要一定正则表达式基础。 new_?表示匹配new或new_，(.*)匹配任意0次或多次任意字符。 正则表达式介绍 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, values_to = &quot;count&quot; ) #&gt; # A tibble: 405,440 x 8 #&gt; country iso2 iso3 year diagnosis gender age count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1980 sp m 014 NA #&gt; 2 Afghanistan AF AFG 1980 sp m 1524 NA #&gt; 3 Afghanistan AF AFG 1980 sp m 2534 NA #&gt; 4 Afghanistan AF AFG 1980 sp m 3544 NA #&gt; 5 Afghanistan AF AFG 1980 sp m 4554 NA #&gt; 6 Afghanistan AF AFG 1980 sp m 5564 NA #&gt; # ... with 405,434 more rows 进一步处理列gender，age 。 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, names_transform = list( gender = ~ readr::parse_factor(.x, levels = c(&quot;f&quot;, &quot;m&quot;)), age = ~ readr::parse_factor( .x, levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), ordered = TRUE ) ), values_to = &quot;count&quot;, ) #&gt; # A tibble: 405,440 x 8 #&gt; country iso2 iso3 year diagnosis gender age count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;fct&gt; &lt;ord&gt; &lt;int&gt; #&gt; 1 Afghanistan AF AFG 1980 sp m 014 NA #&gt; 2 Afghanistan AF AFG 1980 sp m 1524 NA #&gt; 3 Afghanistan AF AFG 1980 sp m 2534 NA #&gt; 4 Afghanistan AF AFG 1980 sp m 3544 NA #&gt; 5 Afghanistan AF AFG 1980 sp m 4554 NA #&gt; 6 Afghanistan AF AFG 1980 sp m 5564 NA #&gt; # ... with 405,434 more rows 3.2.1.4 一行多观测值 family &lt;- tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, &quot;1998-11-26&quot;, &quot;2000-01-29&quot;, 1L, 2L, 2L, &quot;1996-06-22&quot;, NA, 2L, NA, 3L, &quot;2002-07-11&quot;, &quot;2004-04-05&quot;, 2L, 2L, 4L, &quot;2004-10-10&quot;, &quot;2009-08-27&quot;, 1L, 1L, 5L, &quot;2000-12-05&quot;, &quot;2005-02-28&quot;, 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with(&quot;dob&quot;)), parse_date) family #&gt; # A tibble: 5 x 5 #&gt; family dob_child1 dob_child2 gender_child1 gender_child2 #&gt; &lt;int&gt; &lt;date&gt; &lt;date&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1998-11-26 2000-01-29 1 2 #&gt; 2 2 1996-06-22 NA 2 NA #&gt; 3 3 2002-07-11 2004-04-05 2 2 #&gt; 4 4 2004-10-10 2009-08-27 1 1 #&gt; 5 5 2000-12-05 2005-02-28 2 1 family %&gt;% pivot_longer( !family, names_to = c(&quot;.value&quot;, &quot;child&quot;), names_sep = &quot;_&quot;, values_drop_na = TRUE ) #&gt; # A tibble: 9 x 4 #&gt; family child dob gender #&gt; &lt;int&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; #&gt; 1 1 child1 1998-11-26 1 #&gt; 2 1 child2 2000-01-29 2 #&gt; 3 2 child1 1996-06-22 2 #&gt; 4 3 child1 2002-07-11 2 #&gt; 5 3 child2 2004-04-05 2 #&gt; 6 4 child1 2004-10-10 1 #&gt; # ... with 3 more rows anscombe %&gt;% pivot_longer(everything(), names_to = c(&quot;.value&quot;, &quot;set&quot;), names_pattern = &quot;(.)(.)&quot; ) %&gt;% arrange(set) #&gt; # A tibble: 44 x 3 #&gt; set x y #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 8.04 #&gt; 2 1 8 6.95 #&gt; 3 1 13 7.58 #&gt; 4 1 9 8.81 #&gt; 5 1 11 8.33 #&gt; 6 1 14 9.96 #&gt; # ... with 38 more rows pnl &lt;- tibble( x = 1:4, a = c(1, 1,0, 0), b = c(0, 1, 1, 1), y1 = rnorm(4), y2 = rnorm(4), z1 = rep(3, 4), z2 = rep(-2, 4), ) pnl %&gt;% pivot_longer( !c(x, a, b), names_to = c(&quot;.value&quot;, &quot;time&quot;), names_pattern = &quot;(.)(.)&quot; ) #&gt; # A tibble: 8 x 6 #&gt; x a b time y z #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 1 -1.40 3 #&gt; 2 1 1 0 2 0.622 -2 #&gt; 3 2 1 1 1 0.255 3 #&gt; 4 2 1 1 2 1.15 -2 #&gt; 5 3 0 1 1 -2.44 3 #&gt; 6 3 0 1 2 -1.82 -2 #&gt; # ... with 2 more rows 3.2.1.5 重复列名 df &lt;- tibble(id = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = &quot;minimal&quot;) df %&gt;% pivot_longer(!id, names_to = &quot;name&quot;, values_to = &quot;value&quot;) #&gt; # A tibble: 9 x 3 #&gt; id name value #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1 y 4 #&gt; 2 1 y 5 #&gt; 3 1 y 7 #&gt; 4 2 y 5 #&gt; 5 2 y 6 #&gt; 6 2 y 8 #&gt; # ... with 3 more rows 3.2.2 长转宽 pivot_wider()功能与pivot_longer()相反。通过增加列数减少行数使数据集变得更宽，通常我们在汇总时候使用，达到类似Excel透视表结果。 3.2.2.1 基础 fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) #&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 NA NA NA NA NA NA #&gt; 5 4847 1 1 1 NA NA NA NA NA NA NA NA #&gt; 6 4848 1 1 1 1 NA NA NA NA NA NA NA #&gt; # ... with 13 more rows 缺失值填充 fish_encounters %&gt;% pivot_wider( names_from = station, values_from = seen, values_fill = 0 ) #&gt; # A tibble: 19 x 12 #&gt; fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 4842 1 1 1 1 1 1 1 1 1 1 1 #&gt; 2 4843 1 1 1 1 1 1 1 1 1 1 1 #&gt; 3 4844 1 1 1 1 1 1 1 1 1 1 1 #&gt; 4 4845 1 1 1 1 1 0 0 0 0 0 0 #&gt; 5 4847 1 1 1 0 0 0 0 0 0 0 0 #&gt; 6 4848 1 1 1 1 0 0 0 0 0 0 0 #&gt; # ... with 13 more rows 3.2.2.2 聚合 warpbreaks &lt;- warpbreaks %&gt;% as_tibble() warpbreaks %&gt;% count(wool, tension) #&gt; # A tibble: 6 x 3 #&gt; wool tension n #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 A L 9 #&gt; 2 A M 9 #&gt; 3 A H 9 #&gt; 4 B L 9 #&gt; 5 B M 9 #&gt; 6 B H 9 需要通过values_fn指定聚合方式 warpbreaks %&gt;% pivot_wider(names_from = wool, values_from = breaks,values_fn= list(breaks = sum)) #&gt; # A tibble: 3 x 3 #&gt; tension A B #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 L 401 254 #&gt; 2 M 216 259 #&gt; 3 H 221 169 3.2.2.3 从多个变量生成新列名 production &lt;- expand_grid( product = c(&quot;A&quot;, &quot;B&quot;), country = c(&quot;AI&quot;, &quot;EI&quot;), year = 2000:2014 ) %&gt;% filter((product == &quot;A&quot; &amp; country == &quot;AI&quot;) | product == &quot;B&quot;) %&gt;% mutate(production = rnorm(nrow(.))) production #&gt; # A tibble: 45 x 4 #&gt; product country year production #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A AI 2000 -0.244 #&gt; 2 A AI 2001 -0.283 #&gt; 3 A AI 2002 -0.554 #&gt; 4 A AI 2003 0.629 #&gt; 5 A AI 2004 2.07 #&gt; 6 A AI 2005 -1.63 #&gt; # ... with 39 more rows production %&gt;% pivot_wider( names_from = c(product, country), values_from = production ) #&gt; # A tibble: 15 x 4 #&gt; year A_AI B_AI B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -0.244 0.738 -0.313 #&gt; 2 2001 -0.283 1.89 1.07 #&gt; 3 2002 -0.554 -0.0974 0.0700 #&gt; 4 2003 0.629 -0.936 -0.639 #&gt; 5 2004 2.07 -0.0160 -0.0500 #&gt; 6 2005 -1.63 -0.827 -0.251 #&gt; # ... with 9 more rows 通过names_sep和names_prefix参数控制新的列名，或通过names_glue production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_sep = &quot;.&quot;, names_prefix = &quot;prod.&quot; ) #&gt; # A tibble: 15 x 4 #&gt; year prod.A.AI prod.B.AI prod.B.EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -0.244 0.738 -0.313 #&gt; 2 2001 -0.283 1.89 1.07 #&gt; 3 2002 -0.554 -0.0974 0.0700 #&gt; 4 2003 0.629 -0.936 -0.639 #&gt; 5 2004 2.07 -0.0160 -0.0500 #&gt; 6 2005 -1.63 -0.827 -0.251 #&gt; # ... with 9 more rows production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_glue = &quot;prod_{product}_{country}&quot; ) #&gt; # A tibble: 15 x 4 #&gt; year prod_A_AI prod_B_AI prod_B_EI #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2000 -0.244 0.738 -0.313 #&gt; 2 2001 -0.283 1.89 1.07 #&gt; 3 2002 -0.554 -0.0974 0.0700 #&gt; 4 2003 0.629 -0.936 -0.639 #&gt; 5 2004 2.07 -0.0160 -0.0500 #&gt; 6 2005 -1.63 -0.827 -0.251 #&gt; # ... with 9 more rows 3.2.2.4 多值变宽 us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) #&gt; # A tibble: 52 x 6 #&gt; GEOID NAME estimate_income estimate_rent moe_income moe_rent #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 01 Alabama 24476 747 136 3 #&gt; 2 02 Alaska 32940 1200 508 13 #&gt; 3 04 Arizona 27517 972 148 4 #&gt; 4 05 Arkansas 23789 709 165 5 #&gt; 5 06 California 29454 1358 109 3 #&gt; 6 08 Colorado 32401 1125 109 5 #&gt; # ... with 46 more rows 3.2.3 处理json,html的数据 实际工作中不是经常使用，需要使用的时候往往会用相关的包处理：jsonlite 可通过vignette(\"rectangle\")自行学习 library(tidyr) library(dplyr) library(repurrrsive) users &lt;- tibble(user = gh_users) users #&gt; # A tibble: 6 x 1 #&gt; user #&gt; &lt;list&gt; #&gt; 1 &lt;named list [30]&gt; #&gt; 2 &lt;named list [30]&gt; #&gt; 3 &lt;named list [30]&gt; #&gt; 4 &lt;named list [30]&gt; #&gt; 5 &lt;named list [30]&gt; #&gt; 6 &lt;named list [30]&gt; users %&gt;% unnest_wider(user) #&gt; # A tibble: 6 x 30 #&gt; login id avatar_url gravatar_id url html_url followers_url following_url #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 gabo~ 6.60e5 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; 2 jenn~ 5.99e5 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; 3 jtle~ 1.57e6 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; 4 juli~ 1.25e7 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; 5 leep~ 3.51e6 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; 6 masa~ 8.36e6 https://a~ &quot;&quot; http~ https:/~ https://api.~ https://api.~ #&gt; # ... with 22 more variables: gists_url &lt;chr&gt;, starred_url &lt;chr&gt;, #&gt; # subscriptions_url &lt;chr&gt;, organizations_url &lt;chr&gt;, repos_url &lt;chr&gt;, #&gt; # events_url &lt;chr&gt;, received_events_url &lt;chr&gt;, type &lt;chr&gt;, site_admin &lt;lgl&gt;, #&gt; # name &lt;chr&gt;, company &lt;chr&gt;, blog &lt;chr&gt;, location &lt;chr&gt;, email &lt;chr&gt;, #&gt; # public_repos &lt;int&gt;, public_gists &lt;int&gt;, followers &lt;int&gt;, following &lt;int&gt;, #&gt; # created_at &lt;chr&gt;, updated_at &lt;chr&gt;, bio &lt;chr&gt;, hireable &lt;lgl&gt; 3.2.4 嵌套数据 library(tidyr) library(dplyr) library(purrr) 3.2.4.1 基础 嵌套数据即：数据框中嵌套数据框，如下所示： df1 &lt;- tibble( g = c(1, 2, 3), data = list( tibble(x = 1, y = 2), tibble(x = 4:5, y = 6:7), tibble(x = 10) ) ) df1 #&gt; # A tibble: 3 x 2 #&gt; g data #&gt; &lt;dbl&gt; &lt;list&gt; #&gt; 1 1 &lt;tibble [1 x 2]&gt; #&gt; 2 2 &lt;tibble [2 x 2]&gt; #&gt; 3 3 &lt;tibble [1 x 1]&gt; 因为data.frame()的列特性【每列都是列表】【不确定理解对不对】：可以做如下操作： df2 &lt;- tribble( ~g, ~x, ~y, 1, 1, 2, 2, 4, 6, 2, 5, 7, 3, 10, NA ) df2 %&gt;% nest(data = c(x, y)) #&gt; # A tibble: 3 x 2 #&gt; g data #&gt; &lt;dbl&gt; &lt;list&gt; #&gt; 1 1 &lt;tibble [1 x 2]&gt; #&gt; 2 2 &lt;tibble [2 x 2]&gt; #&gt; 3 3 &lt;tibble [1 x 2]&gt; #sample above #df2 %&gt;% group_by(g) %&gt;% nest() nest的反面 unnest df1 %&gt;% unnest(data) #&gt; # A tibble: 4 x 3 #&gt; g x y #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 2 #&gt; 2 2 4 6 #&gt; 3 2 5 7 #&gt; 4 3 10 NA 3.2.5 嵌套数据和模型 mtcars_nested &lt;- mtcars %&gt;% group_by(cyl) %&gt;% nest() mtcars_nested #&gt; # A tibble: 3 x 2 #&gt; # Groups: cyl [3] #&gt; cyl data #&gt; &lt;int&gt; &lt;list&gt; #&gt; 1 6 &lt;tibble [7 x 10]&gt; #&gt; 2 4 &lt;tibble [11 x 10]&gt; #&gt; 3 8 &lt;tibble [14 x 10]&gt; mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(data, function(df) lm(mpg ~ wt, data = df))) mtcars_nested #&gt; # A tibble: 3 x 3 #&gt; # Groups: cyl [3] #&gt; cyl data model #&gt; &lt;int&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 6 &lt;tibble [7 x 10]&gt; &lt;lm&gt; #&gt; 2 4 &lt;tibble [11 x 10]&gt; &lt;lm&gt; #&gt; 3 8 &lt;tibble [14 x 10]&gt; &lt;lm&gt; mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(model, predict)) mtcars_nested #&gt; # A tibble: 3 x 3 #&gt; # Groups: cyl [3] #&gt; cyl data model #&gt; &lt;int&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 6 &lt;tibble [7 x 10]&gt; &lt;dbl [7]&gt; #&gt; 2 4 &lt;tibble [11 x 10]&gt; &lt;dbl [11]&gt; #&gt; 3 8 &lt;tibble [14 x 10]&gt; &lt;dbl [14]&gt; 3.2.6 拆分和合并 3.2.6.1 拆分 有时我们需要将一列拆分为多列： library(tidyr) df &lt;- data.frame(x = c(NA, &quot;a.b&quot;, &quot;a.d&quot;, &quot;b.c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;, &quot;B&quot;)) #&gt; A B #&gt; 1 &lt;NA&gt; &lt;NA&gt; #&gt; 2 a b #&gt; 3 a d #&gt; 4 b c 拆分数多列或少列时用NA补齐： df &lt;- data.frame(x = c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;, NA)) df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;)) #&gt; Warning: Expected 2 pieces. Additional pieces discarded in 1 rows [3]. #&gt; Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [1]. #&gt; a b #&gt; 1 a &lt;NA&gt; #&gt; 2 a b #&gt; 3 a b #&gt; 4 &lt;NA&gt; &lt;NA&gt; 多余的部分舍弃，缺失填充在左边还是右边： # The same behaviour as previous, but drops the c without warnings: df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;drop&quot;, fill = &quot;right&quot;) #&gt; a b #&gt; 1 a &lt;NA&gt; #&gt; 2 a b #&gt; 3 a b #&gt; 4 &lt;NA&gt; &lt;NA&gt; 多余部分合并，缺失填充在左边 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;merge&quot;, fill = &quot;left&quot;) #&gt; a b #&gt; 1 &lt;NA&gt; a #&gt; 2 a b #&gt; 3 a b c #&gt; 4 &lt;NA&gt; &lt;NA&gt; 或者全部保留 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; Warning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [1, 2]. #&gt; a b c #&gt; 1 a &lt;NA&gt; &lt;NA&gt; #&gt; 2 a b &lt;NA&gt; #&gt; 3 a b c #&gt; 4 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 指定分隔符 df %&gt;% separate(x, c(&quot;key&quot;, &quot;value&quot;), sep = &quot;: &quot;, extra = &quot;merge&quot;) #&gt; Warning: Expected 2 pieces. Missing pieces filled with `NA` in 3 rows [1, 2, 3]. #&gt; key value #&gt; 1 a &lt;NA&gt; #&gt; 2 a b &lt;NA&gt; #&gt; 3 a b c &lt;NA&gt; #&gt; 4 &lt;NA&gt; &lt;NA&gt; 使用正则表达式 # Use regular expressions to separate on multiple characters: df &lt;- data.frame(x = c(NA, &quot;a?b&quot;, &quot;a.d&quot;, &quot;b:c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;,&quot;B&quot;), sep = &quot;([.?:])&quot;) #&gt; A B #&gt; 1 &lt;NA&gt; &lt;NA&gt; #&gt; 2 a b #&gt; 3 a d #&gt; 4 b c 3.2.6.2 新列提取 df &lt;- data.frame(x = c(NA, &quot;a-b&quot;, &quot;a-d&quot;, &quot;b-c&quot;, &quot;d-e&quot;)) df %&gt;% extract(x, &quot;A&quot;) #&gt; A #&gt; 1 &lt;NA&gt; #&gt; 2 a #&gt; 3 a #&gt; 4 b #&gt; 5 d df %&gt;% extract(x, c(&quot;A&quot;, &quot;B&quot;), &quot;([[:alnum:]]+)-([[:alnum:]]+)&quot;) #&gt; A B #&gt; 1 &lt;NA&gt; &lt;NA&gt; #&gt; 2 a b #&gt; 3 a d #&gt; 4 b c #&gt; 5 d e # [:alnum:] 匹配字母和数字 以上本质是字符处理，正则表达式 3.2.6.3 合并 df &lt;- expand_grid(x = c(&quot;a&quot;, NA), y = c(&quot;b&quot;, NA)) df #&gt; # A tibble: 4 x 2 #&gt; x y #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b #&gt; 2 a &lt;NA&gt; #&gt; 3 &lt;NA&gt; b #&gt; 4 &lt;NA&gt; &lt;NA&gt; df %&gt;% unite(&quot;z&quot;, x:y, remove = FALSE) #&gt; # A tibble: 4 x 3 #&gt; z x y #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a_b a b #&gt; 2 a_NA a &lt;NA&gt; #&gt; 3 NA_b &lt;NA&gt; b #&gt; 4 NA_NA &lt;NA&gt; &lt;NA&gt; # expand_grid 类似笛卡尔积功能 移除缺失值 df %&gt;% unite(&quot;z&quot;, x:y, na.rm = TRUE, remove = FALSE) #&gt; # A tibble: 4 x 3 #&gt; z x y #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 &quot;a_b&quot; a b #&gt; 2 &quot;a&quot; a &lt;NA&gt; #&gt; 3 &quot;b&quot; &lt;NA&gt; b #&gt; 4 &quot;&quot; &lt;NA&gt; &lt;NA&gt; 合并后再拆分 df %&gt;% unite(&quot;xy&quot;, x:y) %&gt;% separate(xy, c(&quot;x&quot;, &quot;y&quot;)) #&gt; # A tibble: 4 x 2 #&gt; x y #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a b #&gt; 2 a NA #&gt; 3 NA b #&gt; 4 NA NA 3.2.7 缺失值处理 replace_na()用特定值替换缺失值。 df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;)) df %&gt;% replace_na(list(x = 0, y = &quot;unknown&quot;)) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 a #&gt; 2 2 unknown #&gt; 3 0 b df %&gt;% dplyr::mutate(x = replace_na(x, 0)) #&gt; # A tibble: 3 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 a #&gt; 2 2 &lt;NA&gt; #&gt; 3 0 b "],["character-handling.html", "4 字符处理", " 4 字符处理 实际数据分析工作中,经常需要处理字符串以便让数据整洁，符合分析需求。在我们常用的Excel或sql中也有处理字符串的经验，大部分时候截断、替换等基础实现就能满足我们的大部分字符处理需求。 Excel中自带的字符串函数5，如:left,len,mid,find,Proper,rept,trim,upper,substitute,concatenate,以及Excle2019新出的concat,TEXTJOIN等字符函数，TEXTJOIN函数我个人比较喜欢用。在学习R的字符处理时候可以自行尝试实现以上相对应功能。 但是Excel中字符处理功能存在一定局限性,没有直接可用的正则表达式6函数,在正则表达式本身就很困难的情况下，在VBA中实现较复杂的函数将会难上加难。 字符处理本人觉得本质上就是将字符定位后去实现不同的操作。所以觉得难点在于字符串中字符的定位，而实现这个功能就需要用到正则表达式，所以字符处理真正的难点在于正则表达式的编写，但是在我看来正则表达式想要掌握，难度过高，我们秉着随用随查的态度对待即可。 因为大部分的数据分析工作者并不会面临太多复杂的字符处理工作，对大部分常规商业数据分析工作者面对的数据而言，字符处理可能仅仅只是合并、剔除、删除空格、倒序等基础操作。面对舆情监控，购物评价等纯文本情感分析工作，个人觉得对普通数据分析岗位有点超纲，所以本章节的字符处理仅仅是常规的字符处理。 Excel中支持的[TEXT functions] (https://support.microsoft.com/zh-cn/office/%e6%96%87%e6%9c%ac%e5%87%bd%e6%95%b0%ef%bc%88%e5%8f%82%e8%80%83%ef%bc%89-cccd86ad-547d-4ea9-a065-7bb697c2a56e?ui=zh-CN&amp;rs=zh-CN&amp;ad=CN)↩︎ 正则表达式(regular expression)描述了一种字符串匹配的模式(pattern),查看帮助?regex。↩︎ "],["character-base-R.html", "4.1 base R", " 4.1 base R 本部分简述base R中关于字符处理的常用函数。 4.1.1 单双引号 R语言中字符串输入时，可以使用单引号，也可以使用双引号，详情请看?Quotes。 单双引号用法和意义没有差别 R中推荐使用双引号分隔符，打印、显示时都是用双引号 单引号字符串通常用在字符串内包含双引号时，如用R执行sql字符串代码时 R-4.0之后引入的R字符[newfeatures]，让单双引号基本没区别 R中的字符用单双引号都可创建，如下所示: x &lt;- &quot;R语言&quot; x #&gt; [1] &quot;R语言&quot; x &lt;- &#39;R语言&#39; x #&gt; [1] &quot;R语言&quot; 4.1.2 转义 要在字符串中包含单引号或双引号，需用 转义它，即遇到特殊符号时需要转义,如果不正确使用转义，可能会报错，如下所示： paste(&quot;&quot;&quot;,&quot;abc&quot;,sep=&quot;&quot;) #&gt; 错误: unexpected string constant in &quot;paste(&quot;&quot;&quot;,&quot;&quot; R语言中使用“\"把特定的字符转义为特殊字符，例如“是制表符，“”是换行符，或者是“”(系统差异)。想要正确显示“’”，需使用转义，如下所示： char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; char #&gt; [1] &quot;我是一名&#39;小学生&#39;&quot; 打印会显示转义符,主要是因为R语言内数据存储和打印是不一样的，运行结果为存储的数据形式，不是打印形式。 要查看字符串的原始内容,可使用writeLines()或cat() x &lt;- c(&quot;\\&quot;&quot;, &quot;\\\\&quot;) x #&gt; [1] &quot;\\&quot;&quot; &quot;\\\\&quot; writeLines(x) #&gt; &quot; #&gt; \\ writeLines(char) #&gt; 我是一名&#39;小学生&#39; cat(char) #&gt; 我是一名&#39;小学生&#39; 4.1.3 常用函数 字符数量 s &lt;- &#39;abcdefg&#39; nchar(s) #&gt; [1] 7 大小写 toupper(&#39;abc&#39;) #&gt; [1] &quot;ABC&quot; tolower(&#39;ABC&#39;) #&gt; [1] &quot;abc&quot; 拼接 函数paste()将不同的字符向量拼接组合起来，返回的数据类型是字符向量。其中分割参数sep默认值是\" \"(空格)。collapse参数是使用指定的字符把各元素拼接在一次成一个单独的字符串。 paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;) #&gt; [1] &quot;a b d&quot; paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,sep = &#39;&#39;) #&gt; [1] &quot;abd&quot; paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,sep = &#39;_&#39;) #&gt; [1] &quot;a_b_d&quot; paste(c(&#39;a&#39;,&#39;b&#39;),c(&#39;d&#39;,&#39;e&#39;),collapse = &#39;_&#39;) #&gt; [1] &quot;a d_b e&quot; 大家可以自行了解paste和paste0两个函数的差异。 截取 substr函数用于字符串截取子字符串,start,stop参数是整数。 # 空格占据一个长度 substr(&quot;R is free software&quot; ,start = 1,stop = 6) #&gt; [1] &quot;R is f&quot; 分割 函数strsplit按照指定的字符把字符分割成子字符。参数x被分割的字符，split是用于分割的字符标准，fixed是否完全匹配分隔符，默认是TRUE,完全匹配模式，当fixed参数为FALSE时，表名split参数是正则表达式，使用正则匹配。 strsplit(x,split,fixed,perl,useBytes) strsplit函数返回的结果是列表，大部分时候需要向量化后使用。 strsplit(&#39;广东省-深圳市-宝安区&#39;,split=&#39;-&#39;) #&gt; [[1]] #&gt; [1] &quot;广东省&quot; &quot;深圳市&quot; &quot;宝安区&quot; # 向量化 # unlist(strsplit(&#39;广东省-深圳市-宝安区&#39;,split=&#39;-&#39;)) 官方手册中提供一个字符倒叙的自定义编写的函数： strReverse &lt;- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;) strReverse(c(&quot;abc&quot;, &quot;Statistics&quot;)) #&gt; [1] &quot;cba&quot; &quot;scitsitatS&quot; 4.1.4 新特性 该特性让反斜杠或单引号和双引号书写变得容易。用法r“(…)”，括号中可以是任意字符，详情请看?Quotes。 # windows下路径 ,不用转义路径复制直接可用 char &lt;- r&quot;(C:\\Users\\zhongyf\\Desktop\\Rbook)&quot; char #&gt; [1] &quot;C:\\\\Users\\\\zhongyf\\\\Desktop\\\\Rbook&quot; char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; cat(char) #&gt; 我是一名&#39;小学生&#39; char &lt;- r&quot;(我是一名&#39;R语言&#39;学习者)&quot; cat(char) #&gt; 我是一名&#39;R语言&#39;学习者 注意该特性需要在R-4.0.0之后的版本中使用 "],["character-stringr-packages.html", "4.2 stringr", " 4.2 stringr 本小节介绍R包stringr，stringr处理字符相对简单，并且是tidyverse系列的一部分，是很成熟的R包，API功能稳定。stringr是基于stringi之上构建的,stringr包集合了常见字符功能函数，如果发现stringr缺少某些功能可以查看stringi包。 如上文所说，字符串处理的难点，个人觉得在于正则表达式的掌握程度。对大部分常规商业数据分析工作者的面对的表格数据而言，字符处理可能仅仅只是合并、剔除、删除空格、倒叙等基础操作，所以stringr包基本满足字符处理需求。 stringr项目地址:https://github.com/tidyverse/stringr/ 如果不熟悉R中的字符串，可以从R for Data Science的字符串部分开始学习， 本小节的部分案例照搬R for Data Science。 4.2.1 安装 # Install the released version from CRAN: install.packages(&quot;stringr&quot;) # Install the cutting edge development version from GitHub: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/stringr&quot;) 4.2.2 基本使用 stringr包中所有的函数都已str_开头，让字符做第一个参数。 字符串长度 library(stringr) char &lt;- &quot;我是R语言学习者&quot; str_length(char) #&gt; [1] 8 # 向量化 str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA)) #&gt; [1] 1 18 NA 连接字符串 R中字符串不像python中可以用加号连接字符串,如下所示: R 版本 #base R paste0(&#39;a&#39;,&#39;b&#39;) #&gt; [1] &quot;ab&quot; #stringr str_c(&quot;a&quot;,&quot;b&quot;) #&gt; [1] &quot;ab&quot; str_c(&quot;a&quot;, &quot;b&quot;, sep = &quot;, &quot;) #sep 参数控制分隔符 #&gt; [1] &quot;a, b&quot; Python 版本 &#39;a&#39; + &#39;b&#39; #&gt; &#39;ab&#39; 多个字符串合并为一个字符,stringr中的函数都是向量化的，合并一个和多个字符都是同样道理。 #base R paste0(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #&gt; [1] &quot;a,b,d,e&quot; #stringr str_c(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #collapse 参数控制 #&gt; [1] &quot;a,b,d,e&quot; 移除 在正则表达式中 有特殊含义,有时需要两个 ，多体会下面这段，代码实现移除“||”的功能。 library(stringr) str_remove(string = &#39;a||b&#39;,pattern = &quot;\\\\|\\\\|&quot;) #&gt; [1] &quot;ab&quot; 另外常见的\\n, \\t需要被转义处理,在字符清洗,如小说语义分析,网页爬虫后整理等数据清洗过程中经常用到. 4.2.3 常用函数 4.2.3.1 截取字符 与Excle中left,mid,right函数功能类似 str_sub() 函数 三个参数: string:需要被截取的字符串 start: 默认1L,即从最开始截取 end:默认-1L,即截取到最后 #注意end 3 和 -3的区别 str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = 3) #&gt; [1] &quot;是R&quot; str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = -3) #&gt; [1] &quot;是R语言学&quot; 4.2.3.2 匹配字符 查看函数帮助文档,str_match()按照指定pattern(正则表达式)查找字符。困难点在于正则表达式的编写。 ?str_match() ?str_match_all() ?str_extract() ?str_extract_all() str_extract()函数返回向量,str_match()函数返回矩阵. #原文来源烽火戏诸侯的&lt;剑来&gt; strings &lt;- c(&#39;陈平安放下新折的那根桃枝,吹灭蜡烛,走出屋子后,坐在台阶上,仰头望去,星空璀璨.&#39;) str_extract(strings,&#39;陈平安&#39;) #&gt; [1] &quot;陈平安&quot; str_match(strings,&#39;陈平安&#39;) #&gt; [,1] #&gt; [1,] &quot;陈平安&quot; 匹配中文 匹配中文的正则表达式\\[\\u4e00-\\u9fa5\\] str_extract_all(strings,&#39;[\\u4e00-\\u9fa5]&#39;) #返回list #&gt; [[1]] #&gt; [1] &quot;陈&quot; &quot;平&quot; &quot;安&quot; &quot;放&quot; &quot;下&quot; &quot;新&quot; &quot;折&quot; &quot;的&quot; &quot;那&quot; &quot;根&quot; &quot;桃&quot; &quot;枝&quot; &quot;吹&quot; &quot;灭&quot; &quot;蜡&quot; #&gt; [16] &quot;烛&quot; &quot;走&quot; &quot;出&quot; &quot;屋&quot; &quot;子&quot; &quot;后&quot; &quot;坐&quot; &quot;在&quot; &quot;台&quot; &quot;阶&quot; &quot;上&quot; &quot;仰&quot; &quot;头&quot; &quot;望&quot; &quot;去&quot; #&gt; [31] &quot;星&quot; &quot;空&quot; &quot;璀&quot; &quot;璨&quot; 匹配数字或英文 查找数字的正则表达式[0-9];查找英文的正则表达式:[a-zA-Z] strings &lt;- c(&#39;00123545&#39;,&#39;LOL league of legends&#39;) str_extract_all(strings,&#39;[0-9]&#39;) #&gt; [[1]] #&gt; [1] &quot;0&quot; &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;4&quot; &quot;5&quot; #&gt; #&gt; [[2]] #&gt; character(0) str_extract_all(strings,&#39;[a-zA-Z]&#39;) #&gt; [[1]] #&gt; character(0) #&gt; #&gt; [[2]] #&gt; [1] &quot;L&quot; &quot;O&quot; &quot;L&quot; &quot;l&quot; &quot;e&quot; &quot;a&quot; &quot;g&quot; &quot;u&quot; &quot;e&quot; &quot;o&quot; &quot;f&quot; &quot;l&quot; &quot;e&quot; &quot;g&quot; &quot;e&quot; &quot;n&quot; &quot;d&quot; &quot;s&quot; 4.2.3.3 添加字符 str_pad() 函数向字符串添加字符 像工作中处理月份的时候,1,2,3,4,5,6,7,8,9,10,11,12变成01,02,03,04,05,06,07,08,09,10,11,12.按照日期时间输出文件名称,如下所示: str_pad(string = 1:12,width = 2,side = &#39;left&#39;,pad = &#39;0&#39;) #&gt; [1] &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; &quot;05&quot; &quot;06&quot; &quot;07&quot; &quot;08&quot; &quot;09&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; 4.2.3.4 去除空格 与excel中trim函数功能类似，剔除字符中的空格，但是不可以剔除字符中的空格 # side 可选 both left right str_trim(&#39; ab af &#39;,side = &#39;both&#39;) #&gt; [1] &quot;ab af&quot; 4.2.3.5 分割字符 str_split()处理后的结果是列表 # 得到列表,需要向量化 str_split(&quot;a,b,d,e&quot;,pattern = &#39;,&#39;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;e&quot; str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% unlist() #&gt; [1] &quot;ab&quot; &quot;cd&quot; # same above #str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% purrr::as_vector() 当待处理的字符串是字符串向量时，得到的列表长度与向量长度一致 fruits &lt;- c( &quot;apples and oranges and pears and bananas&quot;, &quot;pineapples and mangos and guavas&quot; ) str_split(fruits, &quot; and &quot;) #&gt; [[1]] #&gt; [1] &quot;apples&quot; &quot;oranges&quot; &quot;pears&quot; &quot;bananas&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;pineapples&quot; &quot;mangos&quot; &quot;guavas&quot; 4.2.3.6 替换字符 str_replace()，str_replace_all()函数用来替换字符 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_replace(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) #&gt; [1] &quot;-ne apple&quot; &quot;tw- pears&quot; &quot;thr-e bananas&quot; str_replace_all(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) #&gt; [1] &quot;-n- -ppl-&quot; &quot;tw- p--rs&quot; &quot;thr-- b-n-n-s&quot; 4.2.3.7 移除字符 str_remove(),str_remove_all()移除字符。本人常用该函数剔除文本中的空格。 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_remove(fruits, &quot;[aeiou]&quot;) #&gt; [1] &quot;ne apple&quot; &quot;tw pears&quot; &quot;thre bananas&quot; str_remove_all(fruits, &quot;[aeiou]&quot;) #&gt; [1] &quot;n ppl&quot; &quot;tw prs&quot; &quot;thr bnns&quot; 移除文本中空格 str_replace_all(string = &#39; d a b &#39;,pattern = &#39; &#39;,replacement = &#39;&#39;) #&gt; [1] &quot;dab&quot; 4.2.3.8 字符排序 numeric参数决定是否按照数字排序。 str_order(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_sort(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_order(letters) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #&gt; [26] 26 str_sort(letters) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; numeric参数 x &lt;- c(&quot;100a10&quot;, &quot;100a5&quot;, &quot;2b&quot;, &quot;2a&quot;) str_sort(x) #&gt; [1] &quot;100a10&quot; &quot;100a5&quot; &quot;2a&quot; &quot;2b&quot; str_sort(x, numeric = TRUE) #&gt; [1] &quot;2a&quot; &quot;2b&quot; &quot;100a5&quot; &quot;100a10&quot; 4.2.3.9 提取单词 从句子中提取单词。 参数 word(string, start = 1L, end = start, sep = fixed(&quot; &quot;)) 案例 sentences &lt;- c(&quot;Jane saw a cat&quot;, &quot;Jane sat down&quot;) word(sentences, 2, -1) #&gt; [1] &quot;saw a cat&quot; &quot;sat down&quot; word(sentences[1], 1:3, -1) #&gt; [1] &quot;Jane saw a cat&quot; &quot;saw a cat&quot; &quot;a cat&quot; 指定分隔符 # Can define words by other separators str &lt;- &#39;abc.def..123.4568.999&#39; word(str, 1, sep = fixed(&#39;..&#39;)) #&gt; [1] &quot;abc.def&quot; word(str, 2, sep = fixed(&#39;..&#39;)) #&gt; [1] &quot;123.4568.999&quot; 4.2.3.10 其他函数 str_subset() str_which() 匹配字符串本身行筛选时候能用 fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_subset(fruit, &quot;a&quot;) #&gt; [1] &quot;apple&quot; &quot;banana&quot; &quot;pear&quot; &quot;pinapple&quot; str_which(fruit, &quot;a&quot;) # 匹配字符首次出现的位置 #&gt; [1] 1 2 3 4 #str_which 是which(str_detect(x,pattern))的包装 #str_which() #str_subset是对x[str_detect(x,pattern)]的包装 #str_subset() #筛选出字母行 set.seed(24) dt &lt;- data.table::data.table(col=sample(c(letters,1:10),100,replace = T)) head(dt[str_which(col,pattern = &#39;[a-z]&#39;)]) str_dup() 复制字符串 fruit &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_dup(fruit, 2) str_dup(fruit, 1:3) str_c(&quot;ba&quot;, str_dup(&quot;na&quot;, 0:5)) str_starts() str_ends() 从str_detect()包装得到. str_starts(&#39;abd&#39;,&#39;a&#39;) #&gt; [1] TRUE str_detect(&#39;abd&#39;,&#39;^a&#39;) #&gt; [1] TRUE str_ends(&#39;abd&#39;,&#39;d&#39;) #&gt; [1] TRUE str_detect(&#39;abd&#39;,&#39;a$&#39;) #&gt; [1] FALSE 大小写转换 dog &lt;- &quot;The quick brown dog&quot; str_to_upper(dog) #&gt; [1] &quot;THE QUICK BROWN DOG&quot; str_to_lower(dog) #&gt; [1] &quot;the quick brown dog&quot; str_to_title(dog) #&gt; [1] &quot;The Quick Brown Dog&quot; str_to_sentence(&quot;the quick brown dog&quot;) #&gt; [1] &quot;The quick brown dog&quot; "],["character-application.html", "4.3 综合运用", " 4.3 综合运用 4.3.1 实现excel函数 以下函数实现，仅仅只是从stringr包的函数上修改，并且没有完善，没有报错提示等的简陋版本，如果感兴趣的可以尝试利用Rcpp写出高性能版本的同功能函数。 left r_left &lt;- function(str,num){ str_sub(string = str,start = 1,end = num) } r_left(&#39;我是R语言学习者&#39;,3) #&gt; [1] &quot;我是R&quot; right r_right &lt;- function(str,num){ str_sub(string = str,start = str_length(str) - num + 1) } r_right(&#39;我是R语言学习者&#39;,3) #&gt; [1] &quot;学习者&quot; mid r_mid &lt;- function(str,start,num){ str_sub(string = str,start = start,end = start + num -1) } r_mid(&#39;我是R语言学习者&#39;,3,3) #&gt; [1] &quot;R语言&quot; 其余函数可以尝试自行实现。 4.3.2 使用案例 实际运用案例 合并 library(data.table) #&gt; #&gt; 载入程辑包：&#39;data.table&#39; #&gt; The following objects are masked from &#39;package:dplyr&#39;: #&gt; #&gt; between, first, last #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; transpose dt &lt;- data.table(col=rep(&#39;a&#39;,10),letters=letters[1:10]) dt[,newcol:=str_c(letters,collapse = &#39;|&#39;),by=.(col)][] #&gt; col letters newcol #&gt; 1: a a a|b|c|d|e|f|g|h|i|j #&gt; 2: a b a|b|c|d|e|f|g|h|i|j #&gt; 3: a c a|b|c|d|e|f|g|h|i|j #&gt; 4: a d a|b|c|d|e|f|g|h|i|j #&gt; 5: a e a|b|c|d|e|f|g|h|i|j #&gt; 6: a f a|b|c|d|e|f|g|h|i|j #&gt; 7: a g a|b|c|d|e|f|g|h|i|j #&gt; 8: a h a|b|c|d|e|f|g|h|i|j #&gt; 9: a i a|b|c|d|e|f|g|h|i|j #&gt; 10: a j a|b|c|d|e|f|g|h|i|j 拆解 #工作中路径需要拆解 类似商品品类路径 进口水果-热带水果-生鲜,用户行为路径等 dt &lt;- data.table(col=&#39;a&#39;,letters=str_c(letters[1:10],collapse = &#39;|&#39;)) my_str_split &lt;- function(x){ str_split(x,pattern = &quot;\\\\|&quot;) %&gt;% unlist() #str_split 拆解出来是列表 需要向量化 } dt[,list(newcol=my_str_split(letters)),by=.(col)] #&gt; col newcol #&gt; 1: a a #&gt; 2: a b #&gt; 3: a c #&gt; 4: a d #&gt; 5: a e #&gt; 6: a f #&gt; 7: a g #&gt; 8: a h #&gt; 9: a i #&gt; 10: a j "],["character-the-difference-stringr-and-base.html", "4.4 base和stringr", " 4.4 base和stringr 以下表格数据对比，主要是base R 和 stringr中的相应字符处理功能函数对比。 表格数据来源stringr and base differences。表格数据可用以下代码获取(注意网络): library(tidyverse) library(rvest) dt &lt;- read_html(&#39;https://stringr.tidyverse.org/articles/from-base.html&#39;) %&gt;% html_table() %&gt;% `[[`(1) base stringr gregexpr(pattern, x) str_locate_all(x, pattern) grep(pattern, x, value = TRUE) str_subset(x, pattern) grep(pattern, x) str_which(x, pattern) grepl(pattern, x) str_detect(x, pattern) gsub(pattern, replacement, x) str_replace_all(x, pattern, replacement) nchar(x) str_length(x) order(x) str_order(x) regexec(pattern, x) + regmatches() str_match(x, pattern) regexpr(pattern, x) + regmatches() str_extract(x, pattern) regexpr(pattern, x) str_locate(x, pattern) sort(x) str_sort(x) strrep(x, n) str_dup(x, n) strsplit(x, pattern) str_split(x, pattern) strwrap(x) str_wrap(x) sub(pattern, replacement, x) str_replace(x, pattern, replacement) substr(x, start, end) str_sub(x, start, end) tolower(x) str_to_lower(x) tools::toTitleCase(x) str_to_title(x) toupper(x) str_to_upper(x) trimws(x) str_trim(x) 通过以上对比，方便我们从Base R 切换到stringr包的使用。 "],["character-reference-material.html", "4.5 参考资料", " 4.5 参考资料 tidyverse-stringr:https://stringr.tidyverse.org/articles/from-base.html stringr vignettes:https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html R new feature:https://www.r-bloggers.com/4-for-4-0-0-four-useful-new-features-in-r-4-0-0/ R-4.0.0 NEW features:https://cran.r-project.org/doc/manuals/r-devel/NEWS.html "],["datetime.html", "5 时间处理", " 5 时间处理 时间处理看起来是一件简单的事情，因为我们每天都在使用，但事实上是一件复杂的事情。闰年导致每年的天数并不一致，每天也并不是24小时。可以自行搜索“夏令时”，“为什么一天是24小时”或“Why do we have 24 hours in a day”等问题了解关于时间的概念。 但是我们做数据分析，可能仅需要简单的计算时间，并不是必须了解“时间”。我们大部分时候能处理同环比，间隔天数等常规问题即可。 由于能力有限以及处理的日期数据类型有限，本章节仅就常规商业数据分析中时间处理提供一种解决办法。 本章主要分为三大部分： Base R中时间处理函数 lubridate包提供的日期时间处理方法 常规运用以及和Excel的时间系统对比 "],["datetime-base-R.html", "5.1 base R", " 5.1 base R R中内置Date,POSIXct和POSIXlt三个关于日期和时间的类7。 5.1.1 Date 如果我们的数据结构中只有日期，没有时间，我们仅需要使用Date类。 class(Sys.Date()) #&gt; [1] &quot;Date&quot; 1.创建日期 date1 &lt;- as.Date(&#39;2021-05-18&#39;) # as.Date(32768, origin = &quot;1900-01-01&quot;) # date1 &lt;- as.Date(&#39;2021-05-18&#39;,origin = &quot;1900-01-01&quot;) 当日期字符不规则时必须指定format参数 date2 &lt;- as.Date(&quot;5/14/2021&quot;,format=&quot;%m/%d/%Y&quot;) 想想如何才将将“2021年5月8日”转换成日期： as.Date(&quot;2021年5月18日&quot;,format=&quot;%Y年%m月%d日&quot;) #&gt; [1] &quot;2021-05-18&quot; 重点是时间的format，详情可以通过?strptime()查看。 2.日期计算 两日期之间间隔 date1 - date2 #&gt; Time difference of 4 days difftime(date1,date2,units = &#39;days&#39;) #&gt; Time difference of 4 days 日期加减天数 date1 - 4 #&gt; [1] &quot;2021-05-14&quot; date2 + 4 #&gt; [1] &quot;2021-05-18&quot; 向量化计算 three_date &lt;- as.Date(c(&#39;2021-05-01&#39;,&#39;2021-05-05&#39;,&#39;2021-05-10&#39;)) diff(three_date) #&gt; Time differences in days #&gt; [1] 4 5 在计算顾客购物间隔天数时比较有用。 3.创建日期向量 date3 &lt;- as.Date(&#39;2020-01-01&#39;) date4 &lt;- as.Date(&#39;2021-01-01&#39;) date_col &lt;- date3:date4 head(date_col) #&gt; [1] 18262 18263 18264 18265 18266 18267 以上方式创建日期向量会数字化，正确方式如下所示: # seq(date3,date4) seq(date3,date4,by=&quot;30 days&quot;) #&gt; [1] &quot;2020-01-01&quot; &quot;2020-01-31&quot; &quot;2020-03-01&quot; &quot;2020-03-31&quot; &quot;2020-04-30&quot; #&gt; [6] &quot;2020-05-30&quot; &quot;2020-06-29&quot; &quot;2020-07-29&quot; &quot;2020-08-28&quot; &quot;2020-09-27&quot; #&gt; [11] &quot;2020-10-27&quot; &quot;2020-11-26&quot; &quot;2020-12-26&quot; seq(date3,date4,by=&quot;8 weeks&quot;) #&gt; [1] &quot;2020-01-01&quot; &quot;2020-02-26&quot; &quot;2020-04-22&quot; &quot;2020-06-17&quot; &quot;2020-08-12&quot; #&gt; [6] &quot;2020-10-07&quot; &quot;2020-12-02&quot; 5.1.2 POSIXct 如果在数据中有时间，最好使用该类； Sys.time() #获取当前时间 #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; class(Sys.time()) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 1.创建POSIXct类 tm1 &lt;- as.POSIXct(&quot;2021-5-19 16:05:45&quot;) tm1 #&gt; [1] &quot;2021-05-19 16:05:45 CST&quot; tm2 &lt;- as.POSIXct(&quot;19052021 16:05:45&quot;,format = &quot;%d%m%Y %H:%M:%S&quot;) tm2 #&gt; [1] &quot;2021-05-19 16:05:45 CST&quot; # 比较是否相同 identical(tm1,tm2) #&gt; [1] TRUE 2.时区 时区如果不正确指定，将导致我们在做时间计算时可能出现错误，一般相差8小时,因为我们在东八区。 默认时区 Sys.timezone() #&gt; [1] &quot;Asia/Taipei&quot; as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) #不知道什么原因 CST需要变成CST6CDT不会报错 #&gt; [1] &quot;2021-05-19 16:05:45 CDT&quot; as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;GMT&#39;) - as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) #&gt; Time difference of -5 hours as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;UTC&#39;) - as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) #&gt; Time difference of -5 hours 3.计算 比较 tm1 &lt;- as.POSIXct(&quot;2021-5-19 16:05:45&quot;) tm2 &lt;- as.POSIXct(&quot;2021-5-19 16:15:45&quot;) tm2 &gt; tm1 #&gt; [1] TRUE 加减计算，默认单位秒 tm1 + 300 #&gt; [1] &quot;2021-05-19 16:10:45 CST&quot; tm2 - 300 #&gt; [1] &quot;2021-05-19 16:10:45 CST&quot; tm2 - tm1 #&gt; Time difference of 10 mins 5.1.3 POSIXlt 通过此类，我们可以很便捷提取时间中的特定成分。其中“ct”代表日历时间,“it”代表本地时间,该类对象是list(列表)。 创建时间 t1 &lt;- as.POSIXlt(&#39;2021-5-19 16:05:45&#39;) t1 #&gt; [1] &quot;2021-05-19 16:05:45 CST&quot; unclass(t1) #&gt; $sec #&gt; [1] 45 #&gt; #&gt; $min #&gt; [1] 5 #&gt; #&gt; $hour #&gt; [1] 16 #&gt; #&gt; $mday #&gt; [1] 19 #&gt; #&gt; $mon #&gt; [1] 4 #&gt; #&gt; $year #&gt; [1] 121 #&gt; #&gt; $wday #&gt; [1] 3 #&gt; #&gt; $yday #&gt; [1] 138 #&gt; #&gt; $isdst #&gt; [1] 0 #&gt; #&gt; $zone #&gt; [1] &quot;CST&quot; #&gt; #&gt; $gmtoff #&gt; [1] NA 提取 t1$mday #&gt; [1] 19 t1$wday #&gt; [1] 3 截断 trunc(t1,&#39;day&#39;) #&gt; [1] &quot;2021-05-19 CST&quot; trunc(t1,&#39;min&#39;) #&gt; [1] &quot;2021-05-19 16:05:00 CST&quot; 类是面向对象编程的一个术语，一个对象通常有0个1个或多个类。在R中用class()函数查看所属对象的类。↩︎ "],["lubridate.html", "5.2 lubridate", " 5.2 lubridate lubridate包是对Base R中POSIXct类的封装。所以无论从函数名还是功能等方面，lubridate包中的函数功能更加清晰明了。从获取当前日期、时间，解析时间日期中的年、月、日、星期，计算年月间隔天数等常用的时间日期功能，lubridate包中都有相对应的功能函数。 在处理日期时间数据时，我常用lubridate解决，本节将介绍包中部分函数用法。 5.2.1 安装包 install.packages(&quot;tidyverse&quot;) # 仅仅只安装lubridate install.packages(&#39;lubridate&#39;) # 开发版 devtools::install_github(&quot;tidyverse/lubridate&quot;) # 加载包 library(lubridate,warn.conflicts = FALSE) 5.2.2 当前时间日期 now函数 now()函数是当前时间，只有一个参数tzone,默认为系统的timezone。 now() #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; # now(tzone = &#39;Asia/Shanghai&#39;) # base R base::Sys.time() #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; today函数 时区同样默认为系统的timezone。 today(tzone = &#39;Asia/Shanghai&#39;) #&gt; [1] &quot;2021-05-29&quot; #base R base::Sys.Date() #&gt; [1] &quot;2021-05-29&quot; 5.2.3 构造日期时间 使用数值直接创建日期时间。 函数make_date()和make_datetime()函数默认时区8为“UTC”。 make_date(year = 2021, month = 5, day = 1, tz = &quot;Asia/Shanghai&quot;) make_datetime( year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L, sec = 0, tz = &quot;Asia/Shanghai&quot; ) make_datetime make_datetime( year = year(today()), month = month(today()), day = day(today()), hour = hour(now()), min = minute(now()), sec = second(now()), tz = &quot;asia/shanghai&quot; ) #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; as_datetime as_datetime(&#39;2020-01-09 09:15:40&#39;,tz=&#39;asia/shanghai&#39;) #&gt; [1] &quot;2020-01-09 09:15:40 CST&quot; as_date(&#39;2020-01-09&#39;) #ymd格式 #&gt; [1] &quot;2020-01-09&quot; # same above #as_date(&#39;2020/01/09&#39;) #as_date(&#39;20200109&#39;) 5.2.4 解析日期时间 数据源中日期列可能是各种的字符形式，需要转换为时间格式方便进行日期计算。商业环境中的数据是混乱的，生产库可能是不同的数据库系统，导致时间日期格式混乱，如果公司没有统一的用户层数据源，我们就需要自己清洗数据，将不同形式的日期格式转化为标准格式。 解析日期 # 整数和字符都可以 ymd(20200604) #&gt; [1] &quot;2020-06-04&quot; ymd(&#39;20200604&#39;) #&gt; [1] &quot;2020-06-04&quot; mdy(06042020) #&gt; [1] &quot;2020-06-04&quot; dmy(04062020) #&gt; [1] &quot;2020-06-04&quot; 解析时间 ymd_hm(&quot;20100201 07-01&quot;, &quot;20100201 07-1&quot;, &quot;20100201 7-01&quot;) #&gt; [1] &quot;2010-02-01 07:01:00 UTC&quot; &quot;2010-02-01 07:01:00 UTC&quot; #&gt; [3] &quot;2010-02-01 07:01:00 UTC&quot; ymd_hms(&quot;2013-01-24 19:39:07&quot;) #&gt; [1] &quot;2013-01-24 19:39:07 UTC&quot; 当需要处理unix时间戳时应.POSIXct()函数转化. unix在线转换 .POSIXct(1591709615) #&gt; [1] &quot;2020-06-09 21:33:35 CST&quot; ymd_hms(.POSIXct(1591709615)) #&gt; [1] &quot;2020-06-09 21:33:35 UTC&quot; 在使用unix时间戳转换时一定注意R环境和数据系统环境时区是否一直。 曾经我在使用阿里云的RDS数据库时没注意时区差异，导致我清洗出来的时间数据错误。 ymd_hms(.POSIXct(1591709615),tz = &#39;Asia/Shanghai&#39;) #&gt; [1] &quot;2020-06-09 21:33:35 CST&quot; 5.2.5 提取日期时间成分 #获取年 year(now()) #&gt; [1] 2021 #获取月 month(now()) #&gt; [1] 5 # 当前时间所在年份天数 yday(now()) #&gt; [1] 149 # 当前时间所在月天数 mday(now()) #&gt; [1] 29 # 周几 wday(now(),label = TRUE,week_start = 1) #&gt; [1] 周六 #&gt; Levels: 周一 &lt; 周二 &lt; 周三 &lt; 周四 &lt; 周五 &lt; 周六 &lt; 周日 # 所在时刻 hour(now()) #&gt; [1] 17 # 所在时刻 minute(now()) #&gt; [1] 16 # 所在时刻 second(now()) #&gt; [1] 0.475 5.2.6 处理时区 数据时区与本地R环境一致时，数据中的时区没必要处理，但是当数据是跨时区的或者不同生产系统的时区不一致，我们需要将数据时区处理一致。 1.时区查看 时区和所用系统设置相关 Sys.timezone() #&gt; [1] &quot;Asia/Taipei&quot; # windows 系统默认的时区 中国台北 # linux 上是&quot;Asia/Shanghai&quot; # mac 上是&quot;Asia/Shanghai&quot; 这里还有一个奇怪的点，Windows系统下时区设置为(UTC+08:00)北京,重庆,香港特别行政区,乌鲁木齐,但是R返回的时区是Asia/Taipei。 now() #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; now()输出结果中，CST是时区概念。 CST可以同时代表四个时间 Central Standard Time (USA) UT-6:00 Central Standard Time (Australia) UT+9:30 China Standard Time UT+8:00 Cuba Standard Time UT-4:00 2.时区调整 lubridate中用with_tz()，force_tz()处理时区问题 time &lt;- ymd_hms(&quot;2020-12-13 15:30:30&quot;) time #&gt; [1] &quot;2020-12-13 15:30:30 UTC&quot; # Changes printing with_tz(time, &quot;Asia/Shanghai&quot;) #&gt; [1] &quot;2020-12-13 23:30:30 CST&quot; # Changes time force_tz(time, &quot;Asia/Shanghai&quot;) #&gt; [1] &quot;2020-12-13 15:30:30 CST&quot; 时区差异 从下面三个时间观察时区，CST时间:中央标准时间;UTC时间:世界协调时间(UTC)是世界上不同国家用来调节时钟和时间的主要时间标准。 如:当UTC时间为0点时，中国CST时间为8点，因为零时区和中国北京时区相差8个时区. https://home.kpn.nl/vanadovv/time/TZworld.html#asi lubridate::now() # now函数调用系统默认时区 #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; as_datetime(now()) #as_datetime默认是UTC #&gt; [1] &quot;2021-05-29 09:16:00 UTC&quot; as_datetime(now(),tz = &#39;asia/shanghai&#39;) #&gt; [1] &quot;2021-05-29 17:16:00 CST&quot; 5.2.7 时间间隔 lubridate中将时间间隔保存为interveal类对象。 arrive &lt;- ymd_hms(&quot;2020-12-04 12:00:00&quot;, tz = &quot;asia/shanghai&quot;) arrive #&gt; [1] &quot;2020-12-04 12:00:00 CST&quot; leave &lt;- ymd_hms(&quot;2020-12-10 14:00:00&quot;, tz = &quot;asia/shanghai&quot;) leave #&gt; [1] &quot;2020-12-10 14:00:00 CST&quot; res &lt;- interval(arrive, leave) # same above res &lt;- arrive %--% leave 查看类 class(res) #&gt; [1] &quot;Interval&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;lubridate&quot; 两个时间间隔是否重复 jsm &lt;- interval(ymd(20201020, tz = &quot;asia/shanghai&quot;), ymd(20201231, tz = &quot;asia/shanghai&quot;)) jsm #&gt; [1] 2020-10-20 CST--2020-12-31 CST int_overlaps(jsm, res) #&gt; [1] TRUE 更多详细用法?interveal interval(start = NULL, end = NULL, tzone = tz(start)) start %--% end is.interval(x) int_start(int) int_start(int) &lt;- value int_end(int) int_end(int) &lt;- value int_length(int) int_flip(int) int_shift(int, by) int_overlaps(int1, int2) int_standardize(int) int_aligns(int1, int2) int_diff(times) 5.2.8 时间日期计算 时间日期计算以number line为依据计算。原文是Because the timeline is not as reliable as the number line，我没理解这句话。 minutes(2) #&gt; [1] &quot;2M 0S&quot; dminutes(2) #&gt; [1] &quot;120s (~2 minutes)&quot; dhours(2) #&gt; [1] &quot;7200s (~2 hours)&quot; 注意闰年时计算年份的差异 leap_year(2019) #&gt; [1] FALSE ymd(20190101) + dyears(1) #&gt; [1] &quot;2020-01-01 06:00:00 UTC&quot; ymd(20190101) + years(1) #&gt; [1] &quot;2020-01-01&quot; leap_year(2020) #&gt; [1] TRUE ymd(20200101) + dyears(1) # 注意查看闰年时的差异 #&gt; [1] &quot;2020-12-31 06:00:00 UTC&quot; ymd(20200101) + years(1) #&gt; [1] &quot;2021-01-01&quot; lubridate中的函数都已向量化 meeting &lt;- ymd_hms(&quot;2020-12-01 09:00:00&quot;, tz = &quot;asia/shanghai&quot;) meeting &lt;- meeting + weeks(0:5) meeting %within% jsm #&gt; [1] TRUE TRUE TRUE TRUE TRUE FALSE 除法计算 res / ddays(1) #&gt; [1] 6.08 res / dminutes(1) #&gt; [1] 8760 res %/% months(1) #&gt; [1] 0 res %% months(1) #&gt; [1] 2020-12-04 12:00:00 CST--2020-12-10 14:00:00 CST as.period用法 as.period(res %% months(1)) #&gt; [1] &quot;6d 2H 0M 0S&quot; 对于日期而言，因为月天数、年天数不一致，导致不能直接加减天数，如下： jan31 &lt;- ymd(&quot;2020-01-31&quot;) jan31 + months(0:11) #&gt; [1] &quot;2020-01-31&quot; NA &quot;2020-03-31&quot; NA &quot;2020-05-31&quot; #&gt; [6] NA &quot;2020-07-31&quot; &quot;2020-08-31&quot; NA &quot;2020-10-31&quot; #&gt; [11] NA &quot;2020-12-31&quot; lubridate中不存在的日期返回NA 解决方案是：%m+%或%m-% jan31 %m+% months(0:11) #&gt; [1] &quot;2020-01-31&quot; &quot;2020-02-29&quot; &quot;2020-03-31&quot; &quot;2020-04-30&quot; &quot;2020-05-31&quot; #&gt; [6] &quot;2020-06-30&quot; &quot;2020-07-31&quot; &quot;2020-08-31&quot; &quot;2020-09-30&quot; &quot;2020-10-31&quot; #&gt; [11] &quot;2020-11-30&quot; &quot;2020-12-31&quot; jan31 %m-% months(0:11) #&gt; [1] &quot;2020-01-31&quot; &quot;2019-12-31&quot; &quot;2019-11-30&quot; &quot;2019-10-31&quot; &quot;2019-09-30&quot; #&gt; [6] &quot;2019-08-31&quot; &quot;2019-07-31&quot; &quot;2019-06-30&quot; &quot;2019-05-31&quot; &quot;2019-04-30&quot; #&gt; [11] &quot;2019-03-31&quot; &quot;2019-02-28&quot; lubridate包中大部分函数默认时区为“UTC”，在涉及时间处理时需要注意时区。↩︎ "],["datetime-application.html", "5.3 综合运用", " 5.3 综合运用 5.3.1 日报同环比计算 零售行业基本都存在日报，作为数据分析师大概率是需要出日报的，但根据所在部门情况会有所不同。很多人都已经在sql或exel中实现了，本案例不完全实现日报，主要是教大家为了实现同环比，怎么利用R做日期范围筛选。 首先我们看看R里面怎么做日期的同环比计算： 常用函数 round_date()函数根据要求周期回滚日期 floor_date(today(),unit = &#39;year&#39;) #&gt; [1] &quot;2021-01-01&quot; floor_date(today(),unit = &#39;month&#39;) #&gt; [1] &quot;2021-05-01&quot; floor_date(today(),unit = &#39;week&#39;) #&gt; [1] &quot;2021-05-23&quot; 以上同系列函数从名字就能大概看出端倪，其中关键参数是unit，可选想如下: 1s,second,minute,5 mins,hour,dat,week,months,bimonth,quarter,season,halfyear,year。 round_date( x, unit = &quot;second&quot;, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) floor_date( x, unit = &quot;seconds&quot;, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) ceiling_date( x, unit = &quot;seconds&quot;, change_on_boundary = NULL, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) change_on_boundary参数 ceiling_date(ymd_hms(&#39;2021-01-1 00:00:00&#39;),&#39;month&#39;) #&gt; [1] &quot;2021-01-01 UTC&quot; ceiling_date(ymd_hms(&#39;2021-01-1 00:00:00&#39;),&#39;month&#39;,change_on_boundary = T) #&gt; [1] &quot;2021-02-01 UTC&quot; 计算年同比 n &lt;- 1 date &lt;- today() # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) current_start_date #&gt; [1] &quot;2021-01-01&quot; date #&gt; [1] &quot;2021-05-29&quot; # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_start_date #&gt; [1] &quot;2020-01-01&quot; last_end_date &lt;- date %m-% years(n) last_end_date #&gt; [1] &quot;2020-05-29&quot; 以上,n表示间隔年数，大部分时候都是1。但特殊时候，比如2021年同比2020年2-4月(新冠疫情)基本没有同比意义，所以在此设置为参数。 计算月同比 rollback()函数返回上个月的最后一天或当前月的第一天 rollback(today()) #&gt; [1] &quot;2021-04-30&quot; rollback(today(),roll_to_first = TRUE) #&gt; [1] &quot;2021-05-01&quot; 计算月环比 计算环比时，%m+%或%m-%可以很好解决月份天数不一的问题 as_date(&#39;2020-03-30&#39;) %m-% months(1) #&gt; [1] &quot;2020-02-29&quot; # 环比月截止日 today() #&gt; [1] &quot;2021-05-29&quot; today() %m-% months(1) #&gt; [1] &quot;2021-04-29&quot; 经过以上计算，得到一对对时间周期，然后在订单或者其它数据中筛选即可获得同环比维度数据。 模拟计算 # 构造数据 bill_date &lt;- as_date((as_date(&#39;2019-01-01&#39;):as_date(&#39;2020-12-01&#39;))) area &lt;- sample(c(&#39;华东&#39;,&#39;华西&#39;,&#39;华南&#39;,&#39;华北&#39;),size = length(bill_date),replace = TRUE) category &lt;- sample(c(&#39;品类A&#39;,&#39;品类B&#39;,&#39;品类C&#39;,&#39;品类D&#39;),size = length(bill_date),replace = TRUE) dt &lt;- tibble::tibble(bill_date = bill_date ,money = sample(80:150,size = length(bill_date),replace = TRUE),area = area,category = category) head(dt) #&gt; # A tibble: 6 x 4 #&gt; bill_date money area category #&gt; &lt;date&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2019-01-01 138 华东 品类C #&gt; 2 2019-01-02 80 华南 品类D #&gt; 3 2019-01-03 111 华北 品类B #&gt; 4 2019-01-04 97 华南 品类C #&gt; 5 2019-01-05 126 华东 品类D #&gt; 6 2019-01-06 149 华西 品类A 自定义函数 library(dplyr,warn.conflicts = FALSE) library(lubridate) y_to_y &lt;- function(.dt,date,n = 1,...){ date &lt;- ymd(date) if(is.na(date)){ stop(&#39;请输入正确日期格式，如20200101&#39;) } # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_end_date &lt;- date %m-% years(n) .dt %&gt;% mutate( 类型 = case_when(between(bill_date,current_start_date,date) ~ &quot;当前&quot;, between(bill_date,last_start_date,last_end_date) ~ &quot;同期&quot;, TRUE ~ &quot;其他&quot;)) %&gt;% filter(类型 != &quot;其他&quot;) %&gt;% group_by(...) %&gt;% summarise(金额 = sum(money,na.rm = TRUE)) %&gt;% ungroup() #%&gt;% pivot_wider(names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) } y_to_y(dt,date = &#39;20201001&#39;,n = 1,area,类型) %&gt;% tidyr::pivot_wider(id_cols = &#39;area&#39;,names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) %&gt;% mutate(增长率 = 当前 / 同期) #&gt; `summarise()` has grouped output by &#39;area&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 4 x 4 #&gt; area 当前 同期 增长率 #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 华北 7572 7674 0.987 #&gt; 2 华东 8713 8344 1.04 #&gt; 3 华南 6279 8150 0.770 #&gt; 4 华西 8805 7161 1.23 y_to_y(dt,date = &#39;20201001&#39;,n = 1,area,类型,category) %&gt;% tidyr::pivot_wider(id_cols = c(&#39;area&#39;,&#39;category&#39;),names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) %&gt;% mutate(增长率 = 当前 / 同期) #&gt; `summarise()` has grouped output by &#39;area&#39;, &#39;类型&#39;. You can override using the `.groups` argument. #&gt; # A tibble: 16 x 5 #&gt; area category 当前 同期 增长率 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 华北 品类A 1515 1268 1.19 #&gt; 2 华北 品类B 1807 2600 0.695 #&gt; 3 华北 品类C 1956 1837 1.06 #&gt; 4 华北 品类D 2294 1969 1.17 #&gt; 5 华东 品类A 1797 2400 0.749 #&gt; 6 华东 品类B 2507 2064 1.21 #&gt; # ... with 10 more rows 5.3.2 清洗不同类型日期格式 如将c('2001/2/13 10:33','1/24/13 11:16')转换为相同格式的日期格式; 通过一个简单自定义函数解决，本质是区分不同类型日期后采用不同函数去解析日期格式 library(lubridate) library(tidyverse) date1 &lt;- c(&#39;2001/2/13 10:33&#39;,&#39;1/24/13 11:16&#39;) myfun &lt;- function(x){ n_length &lt;- length(x) res &lt;- vector(length = n_length) for(i in 1:n_length){ n &lt;- strsplit(x[i],&#39;/&#39;) %&gt;% `[[`(1) %&gt;% `[[`(1) if(str_length(n)==4){ res[i] &lt;- ymd_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } else { res[i] &lt;- mdy_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } } as_datetime(res,tz = &#39;Asia/Shanghai&#39;) } myfun(date1) #&gt; [1] &quot;2001-02-13 10:33:00 CST&quot; &quot;2013-01-24 11:16:00 CST&quot; 5.3.3 扫码后中奖时间匹配 假定有两张表，一张是用户扫码表，一张是用户中奖表，如下所示： 数据源视图 由于中奖时间和扫码时间不完全一致，导致没办法直接通过客户ID以及时间关联匹配找到客户每次中奖时的积分码,现在要求找到客户每次中奖时对应的积分码？ 思路：通过观察数据，发现扫码后如果中奖，一般几秒钟内会有中奖记录，那我们就可以通过“每次中奖时间最近的一次扫码时间的积分码”就是该次中奖对应的积分码解决问题。这样我们通过简单编写自定义函数即可获取答案，即一个时间点从一串时间中找到离自己最近时间点。 testfun &lt;- function(x,y){ result &lt;- data.frame() #应采用列表存储结果向量化 n &lt;- length(x) for( i in 1:n){ res &lt;- x[i]-y res &lt;- abs(res) %&gt;% which.min() #本处不对，应该判断res大于0的部分中谁最小 kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result &lt;- rbind(kong,result) } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 改进代码 testfun &lt;- function(x,y){ n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 理论上不同用户可以在同一时间扫码且同时中奖，那上面的代码即不可以获取正确答案。但是我们只要通过按照用户ID切割数据框后稍微改造上面的自定义函数即可。 testfun &lt;- function(dt){ x &lt;- dt$中奖时间 y &lt;- dt$扫的时间 n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } result &lt;- dplyr::bind_rows(result) return(result) } dtlist &lt;- split(alldt,&#39;客户ID&#39;) purrr::map_dfr(dtlist,testfun) 虽然可以通过寻找最近一次的扫码记录判断积分码，但是因为网络延迟或中途接电话等各种原因导致扫码时间和中奖时间相差并不是几秒，导致情景复杂，那我们就应该在设计系统时就设计好锁定对应关系，从根本上解决问题。 "],["datetime-additional-information.html", "5.4 补充资料", " 5.4 补充资料 5.4.1 Excel and R Excel是我们天天打交道的工具，但是R与Excel都有自己的时间系统，而且还不统一，在计算时会给我们带来误解。 Excle日期系统 下面就Excel和R中的差异做简单阐述。 5.4.1.1 差异 R中日期起始时间是1970-01-01,Excel中起始日期9(Windows)是1900-01-01,转化成数字两者相差25568。如下所示： as.Date(&#39;1970-01-01&#39;) #&gt; [1] &quot;1970-01-01&quot; as.Date(25568,origin=&#39;1900-01-01&#39;) # 1970-01-02 #&gt; [1] &quot;1970-01-02&quot; as.Date(25568,origin=&#39;1899-12-31&#39;) # 1970-01-01 #&gt; [1] &quot;1970-01-01&quot; Excel中1900-01-01代表数字1，但是R中1970-01-01代表0。这也是比较怪异的点，毕竟R一般都是从1开始。 as.numeric(as.Date(&#39;1970-01-01&#39;)) #&gt; [1] 0 这样导致: R日期2021-05-29转化成数字是18776, Excel中日期2021-05-29转化成数字是44345,两者相差25569。 在用R读取Excel文件时，涉及到数字日期转化时需要注意其中差异。 5.4.1.2 Excel时间函数 在Excel的Power Pivot中有一组DAX智能函数，如： 基础函数 date,datediff,datevalue,edate,eomonth,quarter,TIMEVALUE等等 智能函数 dateadd,DATESBETWEEN,DATESMTD,TOTALMTD,TOTALQTD,TOTALYTD等等 Excel中因为有了以上时间智能函数，用度量值在透视表中计算同环比变得简单。 假如熟悉DAX时间智能函数，在R中设计相关功能或实现时可以借鉴参考DAX函数的思路。比如在R中写自动化报表时，涉及到同环比计算时就可以按照这个模式设计。 5.4.2 参考资料 lubridate https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html date and time https://www.stat.berkeley.edu/~s133/dates.html dax时间函数 https://docs.microsoft.com/en-us/dax/time-intelligence-functions-dax Excel日期系统 https://support.microsoft.com/zh-cn/office/excel-%e4%b8%ad%e7%9a%84%e6%97%a5%e6%9c%9f%e7%b3%bb%e7%bb%9f-e7fe7167-48a9-4b96-bb53-5612a800b487?ui=zh-CN&amp;rs=zh-CN&amp;ad=CN https://www.rdocumentation.org/packages/lubridate/versions/1.7.8 pdf 下载 https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf Excel中存在两套日期系统↩︎ "],["forcats.html", "6 因子介绍", " 6 因子介绍 我在实际工作中因子数据类型使用较少,forcats软件包用来处理因子,该软件包是tidyverse的一部分. 因子是用于对数据进行分类的R的一种数据类型. 它们可以存储字符串和整数.它们在具有有限数量的唯一值的列中很有用. 像“男性”，“女性”和True，False等。它们在统计建模的数据分析中很有用. 因子变量会占用更小空间,R4.0改变了字符默认为因子的方式.想了解更多请参考 https://r4ds.had.co.nz/factors.html object.size(rep(letters,100000)) #&gt; 20801504 bytes object.size(rep(forcats::as_factor(letters),100000)) #&gt; 10402096 bytes "],["创建因子.html", "6.1 创建因子", " 6.1 创建因子 实际工作中,可能各个事业部或部门之间没有实际顺序,但是在数据处理过程中需要指定顺序可以用因子. library(forcats) vec1 &lt;- c(&#39;部门a&#39;,&#39;部门b&#39;,&#39;部门d&#39;,&#39;部门f&#39;) sort(vec1) #&gt; [1] &quot;部门a&quot; &quot;部门b&quot; &quot;部门d&quot; &quot;部门f&quot; vec2 &lt;- as_factor(c(&#39;部门f&#39;,&#39;部门d&#39;,&#39;部门a&#39;,&#39;部门b&#39;)) sort(vec2) #&gt; [1] 部门f 部门d 部门a 部门b #&gt; Levels: 部门f 部门d 部门a 部门b 如上所示:实际工作中可以通过指定因子水平从而达到排序效果,在可视化中也可以运用,像指定X轴的顺序. "],["Data-Manipulation-datatable.html", "7 data.table", " 7 data.table data.table包是我数据处理最常用的R包，是我目前觉得最好用的数据处理包,大部分我需要用到的功能集成在包里，不需要很多的依赖包。我简单接触过python，julia两种语言，并没有深入比较，所以我这个好用的印象仅仅是个人感受。 data.table包是我用了较长一段时间tidyverse系列后发现的“数据处理包”。已经忘记最初是什么吸引了我，我猜测可能是“大数据处理利器”之类的标签吸引了我，因为我喜欢“快”。但是和大部分人可能不同的是，初次接触时，语法的“怪异”并没有给我带来多少麻烦，因为我本来就没有编程基础以及很深的R语言基础。 所以我死记硬背data.table里一些常用用法，尤其喜欢拿Excle的一些用法参照，去实现Excle上面的部分操作，从读取、增、改、删除、筛选、计算列等常规操作入手。慢慢熟悉data.table语法之后，将会享受data.table带来的便利，其简洁的语法以及高效的计算速度（相比tidyverse系列）。 另外，Python中也有该包，目前正在积极开发中，期待ing，毕竟python也是很好用，在不同需求下选择不同的语言实现功能。 官方关于data.table的基础介绍请参阅: https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html data.table 优势： 速度快 内存效率高 API生命周期管理好 语法简洁 本文会照搬很多官方关于data.table的demo "],["datatable-description.html", "7.1 基础介绍", " 7.1 基础介绍 本部分从data.table安装，内置的案例查看，到data.table的句式语法，实现基础行列筛选和聚合计算。 1.安装 安装详细信息请参考the Installation wiki，有关于不同系统安装首次以及相关说明。 install.packages(&quot;data.table&quot;) # latest development version: data.table::update.dev.pkg() 2.使用说明 通过以下代码查看内置的使用案例。 library(data.table) example(data.table) 7.1.1 读取数据 在我实际工作中接触的数据大部分以数据库,csv,Excel等形式存在，并且CSV格式数据较少。但是data.table包读取数据的fread函数仅接受CSV格式。如果是Excel格式文件，需要通过如readxl，openxlsx等包读入后转换为data.table格式数据。 fread 函数可以直接读取CSV格式文件,无论是本地文件或者在线文件,如下所示: 案例中使用的数据集是R包nycflights13带的flights数据集。 library(data.table) input &lt;- if (file.exists(&quot;./data/flights.csv&quot;)) { &quot;./data/flights.csv&quot; #本地文件 } else { &quot;https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights.csv&quot; #在线文件需翻墙 } flights &lt;- fread(input) #具体参数请参照文档 实际工作中可能会用到的encoding参数,编码 encoding=&#39;UTF-8&#39; head(flights) #&gt; year month day dep_delay arr_delay carrier origin dest air_time distance #&gt; 1: 2014 1 1 14 13 AA JFK LAX 359 2475 #&gt; 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 #&gt; 3: 2014 1 1 2 9 AA JFK LAX 351 2475 #&gt; 4: 2014 1 1 -8 -26 AA LGA PBI 157 1035 #&gt; 5: 2014 1 1 2 1 AA JFK LAX 350 2475 #&gt; 6: 2014 1 1 4 0 AA EWR LAX 339 2454 #&gt; hour #&gt; 1: 9 #&gt; 2: 11 #&gt; 3: 19 #&gt; 4: 7 #&gt; 5: 13 #&gt; 6: 18 本文读取本地文件,如果该数据集下载失败,可更改地址为(http://www.zhongyufei.com/datatable/data/flights.csv) flights &lt;- fread(&quot;http://www.zhongyufei.com/Rbook/data/flights.csv&quot;) 数据集记录的是 2014 年,纽约市3大机场(分别为:JFK 肯尼迪国际机场、 LGA 拉瓜迪亚机场,和 EWR 纽瓦克自由国际机场)起飞的航班信息。 具体的记录信息(特征列)，包括起飞时间、到达时间、延误时长、航空公司、始发机场、目的机场、飞行时长，和飞行距离等。 7.1.2 基本格式 DT[i, j, by]是data.table的基本样式，在不同位置上实现不同功能。 i-j-by DT[i, j, by] ## R: i j by ## SQL: where | order by select | update group by data.table个人理解主要有三大类参数,i参数做筛选,j参数做计算,by参数做分组. 拿Excel透视表类别,i位置参数当作『筛选』,by位置用来做汇总字段『行』,j位置当作『值』,如下所示: 透视表截图 1.代码实例 代码求2014年6月,从各始发机场到各目的机场的飞行距离求和. library(data.table) flights &lt;- fread(&quot;./data/flights.csv&quot;) flights[year==2014 &amp; month==6,.(求和项distance=sum(distance)),by=.(origin,dest)] #&gt; origin dest 求和项distance #&gt; 1: JFK LAX 2663100 #&gt; 2: JFK DFW 82069 #&gt; 3: JFK LAS 795792 #&gt; 4: JFK SFO 1967946 #&gt; 5: JFK SAN 349778 #&gt; --- #&gt; 191: EWR ANC 13480 #&gt; 192: EWR BZN 15056 #&gt; 193: LGA TVC 7205 #&gt; 194: LGA BZN 3788 #&gt; 195: JFK HYA 980 2.代码解释 i 的部分：条件year==2014 和 month==6 ; j 的部分：求和项distance=sum(distance)，写在.()中或者list()中； by 的部分.(origin,dest),重点是写在.()中,和Excel透视表一一对应。 至于为什么要用.()包裹起来，最开始默认为格式强制要求。就这个问题我想说：大部分人可能觉得是比较“怪异”的用法，并且不理解，从而可能留下data.table不好用，很古怪的印象，但是我觉得任何东西存在即合理，你学一个东西总得接受一些你可能不认可的东西，这样可能才是真正的学习，就像拿Python来做数据分析，我刚开始觉得pandas很难用，很反人类，但是后来知道python代码可以直接打包封装成exe后，觉得真香，说这么多主要是想表达我们学会挑选合适的工具用，适应它，用好它就可以了。 7.1.3 i j by 使用 使用data.table处理数据，接下来我们就用该函数读取数据演示i,j,by的简单使用。 7.1.3.1 i行筛选 行筛选是一种很常见的数据操作行为，类似我们Excel中的筛选，即按照一定条件筛选符合要求的数据。条件筛选一般分为单条件筛选、多条件筛选； 在筛选时涉及到条件判断，R语言中常用的条件判断分为逻辑运算、关系运算。常用的关系运算符 &gt;、 &lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。常用的逻辑运算符 &amp;、|、！等。 #单条件筛选 filghts[year == 2014] #筛选year==2014 #多条件筛选 用 &amp; 链接 flights[ year == 2014 &amp; month == 6] # | 相当于中文条件或 flights[ month == 5 | month == 6] # %in% 类似sql中in用法 flights[month %in% c(1,3,5,7,9)] # %between% 类似sql中between and 用法 flights[month %between% c(1,7)] 7.1.3.2 j列操作 数据集较大、字段较多时，由于无效信息较多可以做适当精选，这时需要我们筛选列。与sql中的select用法一致，即保留想要的字段。 .()或list()是data.table中的比较特殊的实现列筛选的用法。常规数字索引，字符向量索引同样有效。 #注意前面的. .() flights[,.(year,month,day,dep_delay,carrier,origin)] #&gt; year month day dep_delay carrier origin #&gt; 1: 2014 1 1 14 AA JFK #&gt; 2: 2014 1 1 -3 AA JFK #&gt; 3: 2014 1 1 2 AA JFK #&gt; 4: 2014 1 1 -8 AA LGA #&gt; 5: 2014 1 1 2 AA JFK #&gt; --- #&gt; 253312: 2014 10 31 1 UA LGA #&gt; 253313: 2014 10 31 -5 UA EWR #&gt; 253314: 2014 10 31 -8 MQ LGA #&gt; 253315: 2014 10 31 -4 MQ LGA #&gt; 253316: 2014 10 31 -5 MQ LGA # flights[,list(year,month,day,dep_delay,carrier,origin)] same above # not run # flights[,1:3] # not run # flights[,c(&#39;year&#39;,&#39;month&#39;,&#39;day&#39;)] setcolorder函数可以调整列的顺序，将常用的字段信息排在前面可以用过该函数实现。 # not run # setcolorder(x = flights,neworder = c( &quot;month&quot;,&quot;day&quot;,&quot;dep_delay&quot; ,&quot;arr_delay&quot;,&quot;carrier&quot; )) # 按照指定列顺序排序 其余字段保持不变,不是建立副本,是直接修改了flights 数据的列顺序 常规计算 根据最开始的Excel透视表截图，我们想要获得如截图一样的结果该怎么实现呢？代码如下： flights[year==2014 &amp; month==6,.(求和项distance=sum(distance),平均距离=mean(distance)),by=.(origin,dest)] 在i的位置做筛选，j的位置做计算，by指定分组字段。在j的位置可以做各种各样的计算，R中自带的函数，或者是自己定义的函数。 myfun &lt;- function(x){ x^2/2 } flights[year==2014 &amp; month==6,.(myfun(distance)),by=.(origin,dest)] #&gt; origin dest V1 #&gt; 1: JFK LAX 3062813 #&gt; 2: JFK LAX 3062813 #&gt; 3: JFK LAX 3062813 #&gt; 4: JFK LAX 3062813 #&gt; 5: JFK LAX 3062813 #&gt; --- #&gt; 26484: JFK HYA 19208 #&gt; 26485: JFK HYA 19208 #&gt; 26486: JFK HYA 19208 #&gt; 26487: JFK HYA 19208 #&gt; 26488: JFK HYA 19208 7.1.3.3 by 分组 分组是按照某种分组实现一定条件下某种聚合方式的计算。分组可以是单字段，多字段以及条件字段等。 1.按月分组 flights[,.(sum(distance)),by=.(month)] #&gt; month V1 #&gt; 1: 1 25112563 #&gt; 2: 2 22840391 #&gt; 3: 3 28716598 #&gt; 4: 4 27816797 #&gt; 5: 5 28030020 #&gt; 6: 6 29093557 #&gt; 7: 7 30059175 #&gt; 8: 8 30322047 #&gt; 9: 9 27615097 #&gt; 10: 10 28900834 2.多条件分组 dt &lt;- flights[,.(sum(distance)),by=.(carrier,origin)] head(dt) #&gt; carrier origin V1 #&gt; 1: AA JFK 20492213 #&gt; 2: AA LGA 12365282 #&gt; 3: AA EWR 3550217 #&gt; 4: AS EWR 1378748 #&gt; 5: B6 JFK 38117662 #&gt; 6: B6 EWR 4508574 #可直接重新命名 dt &lt;- flights[,.(sum(distance)),by=.(newcol1 = carrier,newcol2 = origin)] head(dt) #&gt; newcol1 newcol2 V1 #&gt; 1: AA JFK 20492213 #&gt; 2: AA LGA 12365282 #&gt; 3: AA EWR 3550217 #&gt; 4: AS EWR 1378748 #&gt; 5: B6 JFK 38117662 #&gt; 6: B6 EWR 4508574 3.按月份是否大于6分组 即得到是否大于6的两类分组 dt &lt;- flights[,.(sum(distance)),by=.(month&gt;6)] #by里面可以做计算 head(dt) #&gt; month V1 #&gt; 1: FALSE 161609926 #&gt; 2: TRUE 116897153 7.1.4 行列筛选总结 行筛选在 i 的位置上进行, 列筛选在 j 的位置上进行;data.table中j的位置比较灵活多变，但是i的位置大部分时候都是进行条件筛选。我们通过上述的行列筛选已经大概知道data.table中i,j的用法。也就是我们常规数据清洗过程中的数据筛选过程，筛选符合要求的数据记录。 dt &lt;- flights[ year == 2014 &amp; month == 6 &amp; day &gt;=15,.(year,month,day,dep_delay,carrier,origin)] head(dt) #&gt; year month day dep_delay carrier origin #&gt; 1: 2014 6 15 -4 AA JFK #&gt; 2: 2014 6 15 -8 AA JFK #&gt; 3: 2014 6 15 -12 AA JFK #&gt; 4: 2014 6 15 -4 AA LGA #&gt; 5: 2014 6 15 -3 AA JFK #&gt; 6: 2014 6 15 5 AA JFK "],["datatable-usage.html", "7.2 常规操作", " 7.2 常规操作 7.2.1 行筛选 上文已经大致讲过行筛选，但是行筛选使用有一定的技巧，涉及到运算的快慢。主要是逻辑条件的设置，交集并集之间的差异。除了上文中的关系运算筛选，逻辑运算筛选除外，data.table中还有几个常用的筛选函数。 数字向量筛选 %in%用法与 sql 中 in 用法类似。 # 筛选 %in% flights[ hour %in% seq(1,24,2) ] 字符向量筛选 %chin%用法与 %in% 类似，但仅仅针对字符。 # 字符筛选 flights[ origin %chin% c(&#39;JFK&#39;,&#39;LGA&#39;)] # not run 同上 %chin% 对字符速度筛选速度更快 #flights[ origin %in% c(&#39;JFK&#39;,&#39;LGA&#39;)] between 筛选 该函数的新特性矢量化挺实用。 #between 函数参数 #between(x, lower, upper, incbounds=TRUE, NAbounds=TRUE, check=FALSE) X &lt;- data.table(a=1:5, b=6:10, c=c(5:1)) X[b %between% c(7,9)] #&gt; a b c #&gt; 1: 2 7 4 #&gt; 2: 3 8 3 #&gt; 3: 4 9 2 X[between(b, 7, 9)] #效果同上 #&gt; a b c #&gt; 1: 2 7 4 #&gt; 2: 3 8 3 #&gt; 3: 4 9 2 X[c %between% list(a,b)] # 矢量化 #&gt; a b c #&gt; 1: 1 6 5 #&gt; 2: 2 7 4 #&gt; 3: 3 8 3 like 筛选 %like% 用法与SQL中 like 类似。 # %like% 用法与SQL中 like 类似 DT = data.table(Name=c(&quot;Mary&quot;,&quot;George&quot;,&quot;Martha&quot;), Salary=c(2,3,4)) DT[Name %like% &quot;^Mar&quot;] #&gt; Name Salary #&gt; 1: Mary 2 #&gt; 2: Martha 4 7.2.2 新增更新列 新增或删除或更新列是我们数据清洗过程中的常规操作，data.table中实现该类功能是通过:=符号实现。 选择列 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) dt[,.(col1,col2)] #&gt; col1 col2 #&gt; 1: 1 a #&gt; 2: 2 b #&gt; 3: 3 c #&gt; 4: 4 d #&gt; 5: 5 e #&gt; 6: 6 f #&gt; 7: 7 g #&gt; 8: 8 h #&gt; 9: 9 i #&gt; 10: 10 j # same above dt[,list(col1,col2)] #&gt; col1 col2 #&gt; 1: 1 a #&gt; 2: 2 b #&gt; 3: 3 c #&gt; 4: 4 d #&gt; 5: 5 e #&gt; 6: 6 f #&gt; 7: 7 g #&gt; 8: 8 h #&gt; 9: 9 i #&gt; 10: 10 j 新增列 如下所示:新增addcol列，最后的[]是为了显示新增列的数据框,可不增加。 #data.table()函数创建data.table数据框 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) # 新增列 := dt[,addcol:=rep(&#39;新列&#39;,10)][] #最后的[]是为了显示新增列的数据框,可不增加 #&gt; col1 col2 col3 col4 addcol #&gt; 1: 1 a A 1 新列 #&gt; 2: 2 b B 2 新列 #&gt; 3: 3 c C 3 新列 #&gt; 4: 4 d D 4 新列 #&gt; 5: 5 e E 5 新列 #&gt; 6: 6 f F 6 新列 #&gt; 7: 7 g G 7 新列 #&gt; 8: 8 h H 8 新列 #&gt; 9: 9 i I 9 新列 #&gt; 10: 10 j J 10 新列 #dt[,addcol:=rep(&#39;新列&#39;,10)] 不会显示返回结果,加上[]会显示返回 # 新增多列 dt[,`:=`(newcol1=rep(&#39;newcol1&#39;,10),newcol2=rep(&#39;newcol2&#39;,10))][] #&gt; col1 col2 col3 col4 addcol newcol1 newcol2 #&gt; 1: 1 a A 1 新列 newcol1 newcol2 #&gt; 2: 2 b B 2 新列 newcol1 newcol2 #&gt; 3: 3 c C 3 新列 newcol1 newcol2 #&gt; 4: 4 d D 4 新列 newcol1 newcol2 #&gt; 5: 5 e E 5 新列 newcol1 newcol2 #&gt; 6: 6 f F 6 新列 newcol1 newcol2 #&gt; 7: 7 g G 7 新列 newcol1 newcol2 #&gt; 8: 8 h H 8 新列 newcol1 newcol2 #&gt; 9: 9 i I 9 新列 newcol1 newcol2 #&gt; 10: 10 j J 10 新列 newcol1 newcol2 删除列 删除列即将列赋值NULL即可 # 删除列 dt[,col1:=NULL][] #&gt; col2 col3 col4 addcol newcol1 newcol2 #&gt; 1: a A 1 新列 newcol1 newcol2 #&gt; 2: b B 2 新列 newcol1 newcol2 #&gt; 3: c C 3 新列 newcol1 newcol2 #&gt; 4: d D 4 新列 newcol1 newcol2 #&gt; 5: e E 5 新列 newcol1 newcol2 #&gt; 6: f F 6 新列 newcol1 newcol2 #&gt; 7: g G 7 新列 newcol1 newcol2 #&gt; 8: h H 8 新列 newcol1 newcol2 #&gt; 9: i I 9 新列 newcol1 newcol2 #&gt; 10: j J 10 新列 newcol1 newcol2 # 删除多列 dt[,c(&#39;newcol1&#39;,&#39;newcol2&#39;):=NULL][] #&gt; col2 col3 col4 addcol #&gt; 1: a A 1 新列 #&gt; 2: b B 2 新列 #&gt; 3: c C 3 新列 #&gt; 4: d D 4 新列 #&gt; 5: e E 5 新列 #&gt; 6: f F 6 新列 #&gt; 7: g G 7 新列 #&gt; 8: h H 8 新列 #&gt; 9: i I 9 新列 #&gt; 10: j J 10 新列 更新 更新即重新赋值，将现有列参与计算等于是重新赋值，可以看成是更新列。 # 更新列 dt[,col1:=11:20][] #&gt; col2 col3 col4 addcol col1 #&gt; 1: a A 1 新列 11 #&gt; 2: b B 2 新列 12 #&gt; 3: c C 3 新列 13 #&gt; 4: d D 4 新列 14 #&gt; 5: e E 5 新列 15 #&gt; 6: f F 6 新列 16 #&gt; 7: g G 7 新列 17 #&gt; 8: h H 8 新列 18 #&gt; 9: i I 9 新列 19 #&gt; 10: j J 10 新列 20 # not run # 两列间计算 也可以理解为更新 dt[,newcol:=col1/col4] Note: DT[a &gt; 4, b := c] is different from DT[a &gt; 4][, b := c] 7.2.3 排序 当我们清洗数据时，我们需要将数据框排序，我们可以使用setorder或setorderv函数实现排序。函数是data.table包的函数，比base R 中的order函数要节省内存。 注意：按照函数文档说法：Note that queries like x[order(.)] are optimised internally to use data.table’s fast order。即x[order(.)]这样的用法会被优化为data.table的排序方法。 set.seed(45L) DT = data.table(A=sample(3, 10, TRUE), B=sample(letters[1:3], 10, TRUE), C=sample(10)) setorder(DT, A, -B) #将DT按照A、B排序 A 升序,-B降序 # 和上面同样的效果 但是函数变成 setorderv setorderv(DT, c(&quot;A&quot;, &quot;B&quot;), c(1, -1)) "],["datatable-function.html", "7.3 常用函数", " 7.3 常用函数 常用函数指我们常用功能的函数，如排名、排序、非重复计数、判断、表连接、长宽转换等功能。 7.3.1 特殊符号 .SD,.BY,.N,.I,.NGRP和.GRP,.SDcols等,只能用在 j 的位置,.N 可以用在 i 的位置。 如果想要记住用法需要自己多尝试练习，对于我来说.N使用较多。 DT = data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT #&gt; x v y a b #&gt; 1: b 1 1 1 9 #&gt; 2: b 1 3 2 8 #&gt; 3: b 1 6 3 7 #&gt; 4: a 2 1 4 6 #&gt; 5: a 2 3 5 5 #&gt; 6: a 1 6 6 4 #&gt; 7: c 1 1 7 3 #&gt; 8: c 2 3 8 2 #&gt; 9: c 2 6 9 1 X = data.table(x=c(&quot;c&quot;,&quot;b&quot;), v=8:7, foo=c(4,2)) X #&gt; x v foo #&gt; 1: c 8 4 #&gt; 2: b 7 2 # 用在i的位置 DT[.N] #取DT最后一行,.N 计数函数 #&gt; x v y a b #&gt; 1: c 2 6 9 1 DT[,.N] #DT 共有多少行记录 返回一个整数 #&gt; [1] 9 DT[, .N, by=x] #分组计数 #&gt; x N #&gt; 1: b 3 #&gt; 2: a 3 #&gt; 3: c 3 DT[, .SD, .SDcols=x:y] # 选择x 到y 列 #&gt; x v y #&gt; 1: b 1 1 #&gt; 2: b 1 3 #&gt; 3: b 1 6 #&gt; 4: a 2 1 #&gt; 5: a 2 3 #&gt; 6: a 1 6 #&gt; 7: c 1 1 #&gt; 8: c 2 3 #&gt; 9: c 2 6 #DT[, .SD, .SDcols=c(&quot;x&quot;,&quot;y&quot;)] 与上面不一样 DT[, .SD[1]] #取第一行 #&gt; x v y a b #&gt; 1: b 1 1 1 9 DT[, .SD[1], by=x] #按x列分组后 #&gt; x v y a b #&gt; 1: b 1 1 1 9 #&gt; 2: a 2 1 4 6 #&gt; 3: c 1 1 7 3 DT[, c(.N, lapply(.SD, sum)), by=x] #按照x分组后 行数计数和每列求和 #&gt; x N v y a b #&gt; 1: b 3 3 10 6 24 #&gt; 2: a 3 5 10 15 15 #&gt; 3: c 3 5 10 24 6 7.3.2 排序函数 frank和frankv函数参数如下： frank(x, ..., na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) frankv(x, cols=seq_along(x), order=1L, na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) 官方案例,如下所示: # on vectors x = c(4, 1, 4, NA, 1, NA, 4) # NAs are considered identical (unlike base R) # default is average frankv(x) # na.last=TRUE #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(x, na.last=FALSE) #&gt; [1] 6.0 3.5 6.0 1.5 3.5 1.5 6.0 # on data.table DT = data.table(x, y=c(1, 1, 1, 0, NA, 0, 2)) frankv(DT, cols=&quot;x&quot;) # same as frankv(x) from before #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(DT, cols=&quot;x&quot;, na.last=&quot;keep&quot;) #&gt; [1] 4.0 1.5 4.0 NA 1.5 NA 4.0 frankv(DT, cols=&quot;x&quot;, ties.method=&quot;dense&quot;, na.last=NA) #&gt; [1] 2 1 2 1 2 frank(DT, x, ties.method=&quot;dense&quot;, na.last=NA) # equivalent of above using frank #&gt; [1] 2 1 2 1 2 frankv在排序时,NA被认为是一样的,基础base R 中认为不一样. x &lt;- c(4, 1, 4, NA, 1, NA, 4) frankv(x) #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 rank(x) #&gt; [1] 4.0 1.5 4.0 6.0 1.5 7.0 4.0 升序降序选择 order参数只能为1或者-1.默认为1代表升序 frankv(x,order = 1L) #&gt; [1] 4.0 1.5 4.0 6.5 1.5 6.5 4.0 frankv(x,order = -1L) #&gt; [1] 2.0 4.5 2.0 6.5 4.5 6.5 2.0 排序方式选择 默认 average,还有dense,random,first,last,max,min等方式。其中dense是紧凑排名，random是随机让相同的随机排列后排名 x &lt;- c(1,1,1,2,3) frankv(x) #大小相同 排名相同,下一位排名除以2 frankv(x,ties.method = &#39;min&#39;) #大小相同 排名相同,取最小排名 frankv(x,ties.method = &#39;max&#39;) #大小相同 排名相同,取最大排名 frankv(x,ties.method = &#39;first&#39;) #相同大小排名以后往后递增 根据实际情况决定 frankv(x,ties.method = &#39;dense&#39;) frankv(x,ties.method = &#39;random&#39;) NA处理 默认是将NA排在最后,NAs是相同的，与base R 不一样。 na.last参数等于TRUE时，缺失值被排最后；如果等于FALSE,放在前面；如果等于NA，将被移除；如果等于“keep,”将会保留NA. frankv(c(NA,NA,1,2,3), na.last = TRUE,ties.method = &#39;first&#39;) #&gt; [1] 4 5 1 2 3 frankv(c(NA,NA,1,2,3), na.last = FALSE,ties.method = &#39;first&#39;) #&gt; [1] 1 2 3 4 5 frankv(c(NA,NA,1,2,3), na.last = NA,ties.method = &#39;first&#39;) #&gt; [1] 1 2 3 frankv(c(NA,NA,1,2,3), na.last = &#39;keep&#39;,ties.method = &#39;first&#39;) #&gt; [1] NA NA 1 2 3 7.3.3 非重复计数 uniqueN相当于length(unique(x)),但是计算更快，内存效率更高。 x &lt;-sample(1:10,50,replace = TRUE) uniqueN(x) #&gt; [1] 10 DT &lt;- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3), C = rep(1:2, 6), key = &quot;A,B&quot;) uniqueN(DT, by = key(DT)) #&gt; [1] 6 uniqueN(DT) #&gt; [1] 10 7.3.4 判断函数 fifelse fifelse()类似dplyr::if_else()函数,相比base::ifelse() 更快。 x &lt;- c(1:4, 3:2, 1:4,5) fifelse(x &gt; 2L, x, x - 1L) #&gt; [1] 0 1 3 4 3 1 0 1 3 4 5 fifelse(x &gt; 2L,fifelse(x &gt;= 4L,x + 1L,x),x-1L) #&gt; [1] 0 1 3 5 3 1 0 1 3 5 6 fcase 与sql中的case when，与dplyr中的case_when()函数用法相似。相比fifelse相比，嵌套更加方便。 x = 1:10 fcase( x &lt; 5L, 1L, x &gt; 5L, 3L ) #&gt; [1] 1 1 1 1 NA 3 3 3 3 3 # not run 两种函数实现方式 fifelse(x &gt; 5,fifelse(x &gt;8,2,1),0) #&gt; [1] 0 0 0 0 0 1 1 1 2 2 fcase( x &gt; 8,2, x &gt; 5,1, default = 0 ) #&gt; [1] 0 0 0 0 0 1 1 1 2 2 7.3.5 交集 差集 合并 相当于base R 中 union(),intersect(),setdiff() 和setequal() 功能.all参数控制如何处理重复的行,和SQL中不同的是,data.table将保留行顺序. fintersect(x, y, all = FALSE) fsetdiff(x, y, all = FALSE) funion(x, y, all = FALSE) fsetequal(x, y, all = TRUE) x &lt;- data.table(c(1,2,2,2,3,4,4)) x2 &lt;- data.table(c(1,2,3,4)) # same set of rows as x y &lt;- data.table(c(2,3,4,4,4,5)) fintersect(x, y) # intersect fintersect(x, y, all=TRUE) # intersect all fsetdiff(x, y) # except fsetdiff(x, y, all=TRUE) # except all funion(x, y) # union funion(x, y, all=TRUE) # union all fsetequal(x, x2, all=FALSE) # setequal fsetequal(x, x2) # setequal all 7.3.6 长宽转换 主要是两个函数dcast以及melt实现长宽转换，实现Excel中部分透视表功能。具体的函数参数请自行查阅文档。 dcast函数能实现长转宽 参数如下：fun.aggregate函数指定聚合函数，value.var参数指定参与聚合的字段。formula指定聚合维度，格式用x+y~z，其中x,y在行的位置，z在列的位置。 dcast(data, formula, fun.aggregate = NULL, sep = &quot;_&quot;, ..., margins = NULL, subset = NULL, fill = NULL, drop = TRUE, value.var = guess(data), verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下： dt &lt;- data.table(分公司=rep(c(&#39;华东&#39;,&#39;华南&#39;,&#39;华西&#39;,&#39;华北&#39;),1000), 季度=rep(c(&#39;一季度&#39;,&#39;二季度&#39;,&#39;三季度&#39;,&#39;四季度&#39;),1000), 销售额=sample(100:200,4000,replace = TRUE)) dcast(dt,分公司~季度,value.var = &quot;销售额&quot;,fun.aggregate = sum) #&gt; 分公司 一季度 三季度 二季度 四季度 #&gt; 1: 华东 149470 0 0 0 #&gt; 2: 华北 0 0 0 149343 #&gt; 3: 华南 0 0 150489 0 #&gt; 4: 华西 0 150698 0 0 从版本V1.9.6起可以同时对多个值实现不同聚合后的长转宽。 fun参数即 fun.aggregate的简写，可以是自定义的函数。 dt &lt;- data.table(x=sample(5,20,TRUE), y=sample(2,20,TRUE), z=sample(letters[1:2], 20,TRUE), d1 = runif(20), d2=1L) dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=c(&quot;d1&quot;,&quot;d2&quot;)) #&gt; x y d1_sum_a d1_sum_b d2_sum_a d2_sum_b d1_mean_a d1_mean_b d2_mean_a #&gt; 1: 1 1 0.8454 0.3717 1 2 0.8454 0.1858 1 #&gt; 2: 1 2 0.3769 0.0000 1 0 0.3769 NaN 1 #&gt; 3: 2 1 1.3419 0.4810 2 1 0.6709 0.4810 1 #&gt; 4: 2 2 0.0000 0.6666 0 1 NaN 0.6666 NaN #&gt; 5: 3 1 0.8703 0.1866 1 1 0.8703 0.1866 1 #&gt; 6: 3 2 0.0000 0.9074 0 2 NaN 0.4537 NaN #&gt; 7: 4 1 0.0957 0.0000 1 0 0.0957 NaN 1 #&gt; 8: 4 2 0.1103 0.1867 1 1 0.1103 0.1867 1 #&gt; 9: 5 1 1.1344 0.0000 2 0 0.5672 NaN 1 #&gt; 10: 5 2 1.0839 0.0707 2 1 0.5419 0.0707 1 #&gt; d2_mean_b #&gt; 1: 1 #&gt; 2: NaN #&gt; 3: 1 #&gt; 4: 1 #&gt; 5: 1 #&gt; 6: 1 #&gt; 7: NaN #&gt; 8: 1 #&gt; 9: NaN #&gt; 10: 1 dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=list(&quot;d1&quot;,&quot;d2&quot;)) #注意value.var是向量和列表时的区别 #&gt; x y d1_sum_a d1_sum_b d2_mean_a d2_mean_b #&gt; 1: 1 1 0.8454 0.3717 1 1 #&gt; 2: 1 2 0.3769 0.0000 1 NaN #&gt; 3: 2 1 1.3419 0.4810 1 1 #&gt; 4: 2 2 0.0000 0.6666 NaN 1 #&gt; 5: 3 1 0.8703 0.1866 1 1 #&gt; 6: 3 2 0.0000 0.9074 NaN 1 #&gt; 7: 4 1 0.0957 0.0000 1 NaN #&gt; 8: 4 2 0.1103 0.1867 1 1 #&gt; 9: 5 1 1.1344 0.0000 1 NaN #&gt; 10: 5 2 1.0839 0.0707 1 1 melt函数实现宽转长 melt(data, id.vars, measure.vars, variable.name = &quot;variable&quot;, value.name = &quot;value&quot;, ..., na.rm = FALSE, variable.factor = TRUE, value.factor = FALSE, verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下: ChickWeight = as.data.table(ChickWeight) setnames(ChickWeight, tolower(names(ChickWeight))) DT &lt;- melt(as.data.table(ChickWeight), id=2:4) # calls melt.data.table DT #&gt; time chick diet variable value #&gt; 1: 0 1 1 weight 42 #&gt; 2: 2 1 1 weight 51 #&gt; 3: 4 1 1 weight 59 #&gt; 4: 6 1 1 weight 64 #&gt; 5: 8 1 1 weight 76 #&gt; --- #&gt; 574: 14 50 4 weight 175 #&gt; 575: 16 50 4 weight 205 #&gt; 576: 18 50 4 weight 234 #&gt; 577: 20 50 4 weight 264 #&gt; 578: 21 50 4 weight 264 7.3.7 表连接 两个数据框之间左连,右连等操作,类似数据库中的left_join right_join,inner_join 等函数. 键入?merge()查看函数帮助,data.table 包中和base R 中都有merge 函数,当第一个数据框是data.table格式时启用data.table::merge(). ?merge() merge(x, y, by = NULL, by.x = NULL, by.y = NULL, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(&quot;.x&quot;, &quot;.y&quot;), no.dups = TRUE, allow.cartesian=getOption(&quot;datatable.allow.cartesian&quot;), # default FALSE ...) x.y为连个数据框,当两个数据框连接字段相同时,用by=c(’‘,’’)连接,不同时采用,by.x=,by.y= ,all,all.x,all.y等参数决定连接方式,sort 默认为排序,当不需要排序时更改参数,allow.cartesian=是否允许笛卡尔,默认不允许,当需要时设置为TURE. "],["datatable-advanced-functions.html", "7.4 高级函数", " 7.4 高级函数 高级函数并不是指使用难度，而是使用频率可能不高，但在实现某些功能时特别便利的函数。 如分组聚合的groupingsets,前后移动的shift等函数。 7.4.1 groupingsets 产生多个层次的合计数据，与sql中的grouping set功能相似。 用法 rollup(x, j, by, .SDcols, id = FALSE, ...) groupingsets(x, j, by, sets, .SDcols, id = FALSE, jj, ...) # rollup rollup(DT, j = lapply(.SD, sum), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE, .SDcols=&quot;value&quot;) rollup(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 如果要达到像Excel中透视表一样的效果，如下所示: Excel groupingsets透视表 rollup library(magrittr) #&gt; #&gt; 载入程辑包：&#39;magrittr&#39; #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; set_names #&gt; The following object is masked from &#39;package:tidyr&#39;: #&gt; #&gt; extract DT &lt;- fread(&#39;./data/data-table-groupingsets.csv&#39;,encoding = &#39;UTF-8&#39;) (rollup(DT,j =list(以下项目的总和 =sum(value)),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) %&gt;% setorderv(cols=c(&#39;area&#39;,&#39;grouping&#39;),na.last = TRUE)) #&gt; grouping area store_type 以下项目的总和 #&gt; 1: 0 华东 不可比 9 #&gt; 2: 0 华东 可比 309 #&gt; 3: 1 华东 &lt;NA&gt; 318 #&gt; 4: 0 华北 不可比 72 #&gt; 5: 0 华北 可比 173 #&gt; 6: 1 华北 &lt;NA&gt; 245 #&gt; 7: 0 华南 可比 86 #&gt; 8: 0 华南 不可比 79 #&gt; 9: 1 华南 &lt;NA&gt; 165 #&gt; 10: 0 华西 可比 2 #&gt; 11: 0 华西 不可比 198 #&gt; 12: 1 华西 &lt;NA&gt; 200 #&gt; 13: 3 &lt;NA&gt; &lt;NA&gt; 928 通过上述计算,发现计算结果与Excel透视表一样。 cube 观察cube()计算结果与rollup()差异，发现cube()聚合层次更多。 cube(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 0 华东 不可比 9 #&gt; 2: 0 华东 可比 309 #&gt; 3: 0 华西 可比 2 #&gt; 4: 0 华西 不可比 198 #&gt; 5: 0 华南 可比 86 #&gt; 6: 0 华北 不可比 72 #&gt; 7: 0 华南 不可比 79 #&gt; 8: 0 华北 可比 173 #&gt; 9: 1 华东 &lt;NA&gt; 318 #&gt; 10: 1 华西 &lt;NA&gt; 200 #&gt; 11: 1 华南 &lt;NA&gt; 165 #&gt; 12: 1 华北 &lt;NA&gt; 245 #&gt; 13: 2 &lt;NA&gt; 不可比 358 #&gt; 14: 2 &lt;NA&gt; 可比 570 #&gt; 15: 3 &lt;NA&gt; &lt;NA&gt; 928 groupingsets 根据需要指定指定聚合的层次。 # 与本例中rollup 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;), character()),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 1 华东 &lt;NA&gt; 318 #&gt; 2: 1 华西 &lt;NA&gt; 200 #&gt; 3: 1 华南 &lt;NA&gt; 165 #&gt; 4: 1 华北 &lt;NA&gt; 245 #&gt; 5: 0 华东 不可比 9 #&gt; 6: 0 华东 可比 309 #&gt; 7: 0 华西 可比 2 #&gt; 8: 0 华西 不可比 198 #&gt; 9: 0 华南 可比 86 #&gt; 10: 0 华北 不可比 72 #&gt; 11: 0 华南 不可比 79 #&gt; 12: 0 华北 可比 173 #&gt; 13: 3 &lt;NA&gt; &lt;NA&gt; 928 # 与本例中cube 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;),&quot;store_type&quot;, character()),id = TRUE) #&gt; grouping area store_type V1 #&gt; 1: 1 华东 &lt;NA&gt; 318 #&gt; 2: 1 华西 &lt;NA&gt; 200 #&gt; 3: 1 华南 &lt;NA&gt; 165 #&gt; 4: 1 华北 &lt;NA&gt; 245 #&gt; 5: 0 华东 不可比 9 #&gt; 6: 0 华东 可比 309 #&gt; 7: 0 华西 可比 2 #&gt; 8: 0 华西 不可比 198 #&gt; 9: 0 华南 可比 86 #&gt; 10: 0 华北 不可比 72 #&gt; 11: 0 华南 不可比 79 #&gt; 12: 0 华北 可比 173 #&gt; 13: 2 &lt;NA&gt; 不可比 358 #&gt; 14: 2 &lt;NA&gt; 可比 570 #&gt; 15: 3 &lt;NA&gt; &lt;NA&gt; 928 groupingsets: sets参数,用list()包裹想要聚合的字段组合,最后character(),加上该部分相当于不区分层级全部聚合,用法类似sql中“().” SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ()); 7.4.2 rleid 该函数根据分组生成长度列。 即将0011001110111101类似这种分组成1 1 2 2 3 3 4 4 4 5 6 6 6 6 7 8。在特定时候是很便捷的一个函数。如在计算股票连续上涨或下跌天数时。 rleid(c(0,0,1,1,0,0,1,1,1,0,1,1,1,1,0,1)) #&gt; [1] 1 1 2 2 3 3 4 4 4 5 6 6 6 6 7 8 用法： rleid(..., prefix=NULL) rleidv(x, cols=seq_along(x), prefix=NULL) DT = data.table(grp=rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;), c(2,2,3,1,2)), value=1:10) rleid(DT$grp) # get run-length ids #&gt; [1] 1 1 2 2 3 3 3 4 5 5 rleidv(DT, &quot;grp&quot;) # same as above #&gt; [1] 1 1 2 2 3 3 3 4 5 5 rleid(DT$grp, prefix=&quot;grp&quot;) # prefix with &#39;grp&#39; #&gt; [1] &quot;grp1&quot; &quot;grp1&quot; &quot;grp2&quot; &quot;grp2&quot; &quot;grp3&quot; &quot;grp3&quot; &quot;grp3&quot; &quot;grp4&quot; &quot;grp5&quot; &quot;grp5&quot; 7.4.3 shift 向前或向后功能,通俗来说就是向前或向后移动位置。 示例如下： x = 1:5 # lag with n=1 and pad with NA (returns vector) shift(x, n=1, fill=NA, type=&quot;lag&quot;) #&gt; [1] NA 1 2 3 4 其中参数n控制偏移量，n正负数和type的参数相对应。, n=-1 and type=‘lead’ 与 n=1 and type=’lag’效果相同。 在data.table上使用： DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5]) cols = c(&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;) anscols = paste(&quot;lead&quot;, cols, sep=&quot;_&quot;) DT[, (anscols) := shift(.SD, 1, 0, &quot;lead&quot;), .SDcols=cols] 例如求某人连续消费时间间隔天数时： DT = data.table(dates =lubridate::ymd(c(20210105,20210115,20210124,20210218,20210424))) DT[,newdate:=shift(dates)] DT #&gt; dates newdate #&gt; 1: 2021-01-05 &lt;NA&gt; #&gt; 2: 2021-01-15 2021-01-05 #&gt; 3: 2021-01-24 2021-01-15 #&gt; 4: 2021-02-18 2021-01-24 #&gt; 5: 2021-04-24 2021-02-18 通过构造新列newdate，然后将两列相减dates-newdate即可得到每次购物间隔天数。 7.4.4 J J 是.(),list()等的别名。SJ是排序连接，CJ是交叉连接。 用法： # DT[J(...)] # J() only for use inside DT[...] # DT[.(...)] # .() only for use inside DT[...] # DT[list(...)] # same; .(), list() and J() are identical SJ(...) # DT[SJ(...)] CJ(..., sorted=TRUE, unique=FALSE) # DT[CJ(...)] CJ 我喜欢用CJ()函数创建笛卡尔积表。例如在商品运营中，时常需要将门店和商品形成笛卡尔积表，相比起dplyr::full_join() ,data.table::merge.data.table(allow.cartesian = TRUE ),CJ更加方便快捷。 # CJ usage examples CJ(c(5, NA, 1), c(1, 3, 2)) # sorted and keyed data.table #&gt; V1 V2 #&gt; 1: NA 1 #&gt; 2: NA 2 #&gt; 3: NA 3 #&gt; 4: 1 1 #&gt; 5: 1 2 #&gt; 6: 1 3 #&gt; 7: 5 1 #&gt; 8: 5 2 #&gt; 9: 5 3 # do.call(CJ, list(c(5, NA, 1), c(1, 3, 2))) # same as above # CJ(c(5, NA, 1), c(1, 3, 2), sorted=FALSE) # same order as input, unkeyed SJ SJ : Sorted Join. The same value as J() but additionally setkey() is called on all columns in the order they were passed to SJ. For efficiency, to invoke a binary merge rather than a repeated binary full search for each row of i. "],["datatable-tips.html", "7.5 小技巧", " 7.5 小技巧 7.5.1 用{}抑制中间过程输出 默认只返回未命名花括号中定义的最后一个对象。 dt &lt;- data.table(mtcars) dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2)}, by=cyl] #&gt; cyl V1 #&gt; 1: 6 1.19 #&gt; 2: 4 3.83 #&gt; 3: 8 1.79 在我不知道上述技巧之前，我可能的操作是 dt &lt;- data.table(mtcars) res &lt;- dt[,tmp1:=mean(mpg), by=cyl][,.(tmp2=mean(abs(mpg-tmp1))), by=.(cyl)] res[,.(round(tmp2,2)),by=.(cyl)][] #&gt; cyl V1 #&gt; 1: 6 1.19 #&gt; 2: 4 3.83 #&gt; 3: 8 1.79 保留中间变量 dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2); list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] #&gt; cyl tmp2 tmp3 #&gt; 1: 6 1.19 1.19 #&gt; 2: 4 3.83 3.83 #&gt; 3: 8 1.79 1.79 不写分号的方式 dt[,{tmp1=mean(mpg) tmp2=mean(abs(mpg-tmp1)) tmp3=round(tmp2, 2) list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] #&gt; cyl tmp2 tmp3 #&gt; 1: 6 1.19 1.19 #&gt; 2: 4 3.83 3.83 #&gt; 3: 8 1.79 1.79 7.5.2 使用[]打印data.table 在测试代码查看结果时很有用。 df &lt;- head(mtcars) # doesn&#39;t print (df &lt;- head(mtcars)) # does print #&gt; # A tibble: 6 x 11 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # data.table way of printing after an assignment dt &lt;- data.table(head(mtcars)) # doesn&#39;t print dt[,hp2wt:=hp/wt][] # does print #&gt; mpg cyl disp hp drat wt qsec vs am gear carb hp2wt #&gt; 1: 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 42.0 #&gt; 2: 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 38.3 #&gt; 3: 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 40.1 #&gt; 4: 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 34.2 #&gt; 5: 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 50.9 #&gt; 6: 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 30.3 "],["datatable-application.html", "7.6 运用", " 7.6 运用 7.6.1 自定义函数计算 1.自定义函数处理列 按照自定义函数计算修改单列或多列 # 测试函数 fun &lt;- function(x){ x &lt;- x^2+1 } DT &lt;- data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT[,.(newcol=fun(y)),by=.(x)] #&gt; x newcol #&gt; 1: b 2 #&gt; 2: b 10 #&gt; 3: b 37 #&gt; 4: a 2 #&gt; 5: a 10 #&gt; 6: a 37 #&gt; 7: c 2 #&gt; 8: c 10 #&gt; 9: c 37 #Not run #DT[,lapply(.SD,fun),.SDcols=c(&#39;y&#39;,&#39;a&#39;),by=.(x)] #多列参与计算 # 批量修改列 #Not run # myfun &lt;- function(x){ # return(x) # } # # dt &lt;- dt[,colnames(dt):=lapply(.SD[,1:ncol(dt)],myfun)] #很重要的用法 7.6.2 带汇总的聚合运算 按照by的字段级别汇总. rollup 分组聚合后设置id=TRUE将各个级别的汇总显示清晰,当by字段只有一个是和正常聚合计算没有区别.以下是官方案例. #Usage #rollup(x, j, by, .SDcols, id = FALSE, ...) n = 24L set.seed(25) DT &lt;- data.table( color = sample(c(&quot;green&quot;,&quot;yellow&quot;,&quot;red&quot;), n, TRUE), year = as.Date(sample(paste0(2011:2015,&quot;-01-01&quot;), n, TRUE)), status = as.factor(sample(c(&quot;removed&quot;,&quot;active&quot;,&quot;inactive&quot;,&quot;archived&quot;), n, TRUE)), amount = sample(1:5, n, TRUE), value = sample(c(3, 3.5, 2.5, 2), n, TRUE) ) rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;)) # default id=FALSE #&gt; color year status V1 #&gt; 1: red 2015-01-01 active 3.5 #&gt; 2: green 2015-01-01 inactive 5.5 #&gt; 3: green 2014-01-01 archived 3.5 #&gt; 4: green 2015-01-01 archived 2.0 #&gt; 5: yellow 2014-01-01 active 4.5 #&gt; 6: red 2013-01-01 inactive 2.0 #&gt; 7: green 2011-01-01 active 6.0 #&gt; 8: red 2014-01-01 inactive 2.5 #&gt; 9: green 2011-01-01 archived 2.5 #&gt; 10: yellow 2015-01-01 active 2.0 #&gt; 11: red 2012-01-01 archived 2.0 #&gt; 12: red 2011-01-01 removed 3.5 #&gt; 13: green 2014-01-01 inactive 8.0 #&gt; 14: green 2011-01-01 removed 2.0 #&gt; 15: yellow 2012-01-01 archived 2.5 #&gt; 16: red 2013-01-01 removed 3.5 #&gt; 17: green 2013-01-01 active 3.0 #&gt; 18: green 2014-01-01 removed 2.5 #&gt; 19: red 2011-01-01 archived 3.0 #&gt; 20: red 2015-01-01 &lt;NA&gt; 3.5 #&gt; 21: green 2015-01-01 &lt;NA&gt; 7.5 #&gt; 22: green 2014-01-01 &lt;NA&gt; 14.0 #&gt; 23: yellow 2014-01-01 &lt;NA&gt; 4.5 #&gt; 24: red 2013-01-01 &lt;NA&gt; 5.5 #&gt; 25: green 2011-01-01 &lt;NA&gt; 10.5 #&gt; 26: red 2014-01-01 &lt;NA&gt; 2.5 #&gt; 27: yellow 2015-01-01 &lt;NA&gt; 2.0 #&gt; 28: red 2012-01-01 &lt;NA&gt; 2.0 #&gt; 29: red 2011-01-01 &lt;NA&gt; 6.5 #&gt; 30: yellow 2012-01-01 &lt;NA&gt; 2.5 #&gt; 31: green 2013-01-01 &lt;NA&gt; 3.0 #&gt; 32: red &lt;NA&gt; &lt;NA&gt; 20.0 #&gt; 33: green &lt;NA&gt; &lt;NA&gt; 35.0 #&gt; 34: yellow &lt;NA&gt; &lt;NA&gt; 9.0 #&gt; 35: &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 64.0 #&gt; color year status V1 #rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 个人运用,实际工作中常常需要汇总项,汇总项在Excel透视表中很简单,在R中我之前是构造重复的数据源聚合汇总出现汇总项,极大浪费内存,运算速度减慢. 新方法 rollup set.seed(25) N &lt;- 1000 dt &lt;- data.table(col1=sample(LETTERS[1:5],N,replace = T),col2=sample(letters[1:5],N,replace = T),num=1:N) rollup(dt,j=c(list(sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #&gt; col1 col2 V1 #&gt; 1: E a 19926 #&gt; 2: D a 20966 #&gt; 3: A d 12927 #&gt; 4: A b 20862 #&gt; 5: A c 15331 #&gt; 6: B d 15414 #&gt; 7: C e 20794 #&gt; 8: D e 16110 #&gt; 9: C d 22152 #&gt; 10: A a 18378 #&gt; 11: C c 19474 #&gt; 12: E d 18831 #&gt; 13: B b 19941 #&gt; 14: C a 19652 #&gt; 15: E c 16734 #&gt; 16: E e 24137 #&gt; 17: E b 21988 #&gt; 18: D b 16607 #&gt; 19: B c 25720 #&gt; 20: B a 22109 #&gt; 21: A e 18724 #&gt; 22: C b 24323 #&gt; 23: D d 20508 #&gt; 24: D c 19668 #&gt; 25: B e 29224 #&gt; 26: E &lt;NA&gt; 101616 #&gt; 27: D &lt;NA&gt; 93859 #&gt; 28: A &lt;NA&gt; 86222 #&gt; 29: B &lt;NA&gt; 112408 #&gt; 30: C &lt;NA&gt; 106395 #&gt; 31: &lt;NA&gt; &lt;NA&gt; 500500 #&gt; col1 col2 V1 #同上 添加汇总项名称 total #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #添加id=TRUE参数,多出的grouping 列显示聚合级别 #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;),id=TRUE) 2.groupingsets 按照指定字段聚合.包作者说相同与SQL中的 GROUPING SETS 操作.详情参照postgresql res &lt;- groupingsets(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), sets = list(&quot;color&quot;, c(&quot;year&quot;,&quot;status&quot;), character()), id=TRUE) head(res) #&gt; grouping color year status count amount value #&gt; 1: 3 red &lt;NA&gt; &lt;NA&gt; 7 19 20.0 #&gt; 2: 3 green &lt;NA&gt; &lt;NA&gt; 13 43 35.0 #&gt; 3: 3 yellow &lt;NA&gt; &lt;NA&gt; 4 10 9.0 #&gt; 4: 4 &lt;NA&gt; 2015-01-01 active 2 8 5.5 #&gt; 5: 4 &lt;NA&gt; 2015-01-01 inactive 2 5 5.5 #&gt; 6: 4 &lt;NA&gt; 2014-01-01 archived 1 3 3.5 注意groupingsets函数中sets参数,用list()包裹想要聚合的字段组合,最后还有一个character(),加上该部分相当于全部聚合.当by只有一个字段时,相当于汇总.用法类似sql中“().” 上述语句结果等同于下面sql. select color ,year, status,count(*) count,sum(amount) amount,sum(value) value FROM dbo.DT GROUP BY GROUPING SETS( (color), (year,status), () ---- 类似 character() ) 最后还有cube()函数,可?cube查看用法 7.6.3 行列转变 一列变多行 用tstrsplit()函数实现 n &lt;- 10 dt &lt;- data.table(name=LETTERS[1:n],char=rep(&#39;我-爱-R-语-言&#39;),n) res &lt;- dt[,.(newcol=tstrsplit(char,&#39;-&#39;)),by=.(name)] head(res) #&gt; name newcol #&gt; 1: A 我 #&gt; 2: A 爱 #&gt; 3: A R #&gt; 4: A 语 #&gt; 5: A 言 #&gt; 6: B 我 多行变一列 res[,.(char=paste0(newcol,collapse = &#39;-&#39;)),by=.(name)] #&gt; name char #&gt; 1: A 我-爱-R-语-言 #&gt; 2: B 我-爱-R-语-言 #&gt; 3: C 我-爱-R-语-言 #&gt; 4: D 我-爱-R-语-言 #&gt; 5: E 我-爱-R-语-言 #&gt; 6: F 我-爱-R-语-言 #&gt; 7: G 我-爱-R-语-言 #&gt; 8: H 我-爱-R-语-言 #&gt; 9: I 我-爱-R-语-言 #&gt; 10: J 我-爱-R-语-言 # 同上 # res[,.(char=stringr::str_c(newcol,collapse = &#39;-&#39;)),by=.(name)] "],["database.html", "8 database", " 8 database 我们作为数据分析师有必要和数据库打交道吗？实际工作中，数据量达到一定的程度，当你开始需要使用 Excel PowerPivot 做数据透视表10时，你就必须开始和数据库打交道，因为这时数据源超过Excel上限了，已经没办法承接。 现实中的数据大部分都是脏数据，我们需要从数据库获取数据并清洗，再使用R、 Excel 、Power BI、tebleau等工具连接使用。那我们使用什么工具完成ETL11呢？经过实践发现，使用R语言完成该过程对我们个人用户来说足够使用。 即使你暂时没有接触使用数据库，也建议你未来用数据库存储数据，尤其是当有一定数据量时;在我最开始接触数据时，数据一般保存在Excel中,那时候数据量大概在50万行左右，当表格中sumifs等公式较多时，Excel表格将会很卡顿，甚至发送崩溃。当需要大批量vlookup时，在Excel中操作也是一件很痛苦的事情。 目前工作中打交道数据库主要是MSSQL,Oracle,MySQL等，R中与数据库交互的包主要有odbc,DBI,RODBC,RMySQL,ROracle等包。本文主要从以上数据库介绍记录“R与数据库的连接交互”，主要分为： 安装 SQL Server 数据库 odbc 包介绍 DBI 包介绍 其它R包介绍 与数据库交互常见问题 dbplyr 包介绍 参考资料 DBI库在查询或上传工作中效率比RODBC高,特别数据量较大时,上传效率差异巨大,具体差异请点击查看详情。所以建议采用DBI包，但是RODBC对中文支持友好，在练习阶段可以尝试使用，加深印象。 RSQLite是练习使用R中的数据库的最简单方法，因为程序包本身包含SQLite，无需任何外部软件。 PowerPivot 是一种数据建模技术，用于创建数据模型，建立关系，以及创建计算。 可使用 PowerPivot 处理大型数据集，构建广泛的关系，以及创建复杂（或简单）的计算，这些操作全部在高性能环境中和所你熟悉的 Excel 内执行。↩︎ Extract-Transform-Load,将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。↩︎ "],["database-install.html", "8.1 安装数据库", " 8.1 安装数据库 如果暂时没有数据库使用经验，如果是使用Windows系统，直接去微软官网下载安装数据库即可。如果决定用R做数据分析相关工作，尤其时商业环境下，使用数据库有较强的必要性。安装数据库后，利用数据库做数据分析的练习测试也是不错的体验,另外也可以积累ETL相关经验。 仅简单介绍 MS SQL Server 安装 Win环境下安装 MS下载，选择开发版或精简版(Developer、Express)其中一个版本下载即可。 数据库下载 成功下载后，按照提示一步步确认即可安装成功。另外使用SSMS工具，微软配套的MS SQL SERVER数据库链接工具连接数据库。至于详细的数据库配置尤其是远程连接、账户等信息请自行查阅相关资料。 Linux环境下安装 官网安装指南 以下用于 SQL Server 2019 的命令指向 Ubuntu 20.04 存储库。 如果使用的是 Ubuntu 18.04 或 16.04，请将以下路径更改为 /ubuntu/18.04/ 或 /ubuntu/16.04/，而不是 /ubuntu/20.04/。 # 导入公共存储库的密钥 wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - # 为 SQL Server 2019 注册 Microsoft SQL Server Ubuntu 存储库 sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/20.04/mssql-server-2019.list)&quot; # sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/18.04/mssql-server-2019.list)&quot; # 安装 SQL Server sudo apt-get update sudo apt-get install -y mssql-server # 验证服务是否运行 systemctl status mssql-server --no-pager 至于其他安装如sql server 命令行工具请查阅官网安装。 接下来我们就R语言与数据库的交互包展开介绍。 "],["database-odbc-package.html", "8.2 odbc包", " 8.2 odbc包 官方说明:The goal of the odbc package is to provide a DBI-compliant interface to Open Database Connectivity (ODBC) drivers. This allows for an efficient, easy to setup connection to any database with ODBC drivers available, including SQL Server, Oracle, MySQL, PostgreSQL, SQLite and others. The implementation builds on the nanodbc C++ library。 odbc可以运用于包括(SQL Server, Oracle, MySQL,PostgreSQL,SQLite)等odbc驱动程序于DBI兼容的接口，相比起来DBI包适用范围更广。 odbc项目地址 8.2.1 安装包 Windows Windows与ODBC库捆绑在一起，但是每个数据库的驱动程序需要单独安装。windows系统上可以通过以下命令直接安装。 #安装包 install.packages(&#39;odbc&#39;) 其它系统 其它系统在安装前需要安装依赖环境，如下所示: # Macos brew install unixodbc # Debian /Ubuntu apt-get install unixodbc unixodbc-dev 8.2.2 驱动安装 由于Win系统绑定ODBC库，不需要安装依赖环境即可正常安装使用R包odbc，其它系统经过上面依赖环境安装，现在系统已经能正常安装odbc包。 最后通过odbc::odbcListDrivers()查看系统上是否存在可用驱动程序。 查看可用系统可用驱动： head(odbc::odbcListDrivers()) #&gt; name attribute value #&gt; 1 SQL Server APILevel 2 #&gt; 2 SQL Server ConnectFunctions YYY #&gt; 3 SQL Server CPTimeout 60 #&gt; 4 SQL Server DriverODBCVer 03.50 #&gt; 5 SQL Server FileUsage 0 #&gt; 6 SQL Server SQLLevel 1 1.Windows 默认情况下，win系统即使不安装也可使用驱动“SQL Server,”如下所示： win-drivers 如果想要安装最新的SQL Server驱动，该如何安装呢?具体安装教程请查看微软安装说明 win系统最新的SQL Server驱动ODBC Driver 17 for SQL Server下载地址 其它系统上如果安装sql server驱动请参照安装说明 2.Macos Macos安装驱动 brew install unixodbc # Microsoft SQL Server ODBC Drivers (Recommended) brew tap microsoft/mssql-release https://github.com/Microsoft/homebrew-mssql-release brew update brew install msodbcsql17 mssql-tools 成功安装后如下所示: mac-odbcdriver 8.2.3 连接数据库 连接数据库需要注意时区、编码，尤其是涉及到时间时区时如果设置有误，可能导致时间数据错误。当你在Win系统上连接Sql Server时，如果你使用的数据库是中文环境时，设置encoding参数中文将不会乱码。如果是linux上通过odbc连接SqlServer,一般情况下可以不用设置编码，另外设置encoding为gbk会报错。 数据库连接有几种方式，详情请参照数据库连接字符串,我们以SQL Server2019数据库，驱动ODBC Driver 17 for SQL Server举例。 1.标准模式 连接字符串 Driver={ODBC Driver 17 for SQL Server};Server=myServerAddress;Database=myDataBase;UID=myUsername;PWD=myPassword; 参数形式: con &lt;- odbc::dbConnect(drv=odbc(),driver=&quot;ODBC Driver 17 for SQL Server&quot;,server=&#39;172.16.88.2&#39;,database=&#39;spb&#39;,uid=&#39;zhongyf&#39;,pwd=&#39;Zyf123456&#39;,encoding=&#39;UTF-8&#39;,timezone=&quot;Asia/Shanghai&quot;) 字符串形式： con &lt;- odbc::dbConnect(drv = odbc(),.connection_string=&#39;Driver={ODBC Driver 17 for SQL Server};Server=172.16.88.2;Database=spb;UID=zhongyf;PWD=Zyf123456;&#39;,encoding=&#39;UTF-8&#39;,timezone=&quot;Asia/Shanghai&quot;) 2.信任连接 通过windows身份认证连接，通过数据库管理员配置相关账户权限即可。 Driver={ODBC Driver 17 for SQL Server};Server=myServerAddress;Database=myDataBase;Trusted_Connection=yes; library(odbc) con &lt;- odbc::dbConnect(odbc(), Driver = &quot;SQL Server&quot;, Server = &quot;Vega&quot;, Database = &quot;ghzy&quot;, Trusted_Connection = &quot;True&quot; ) 3.连接SQL Server实例12 Driver={ODBC Driver 17 for SQL Server};Server=serverName\\instanceName; Database=myDataBase;Trusted_Connection=yes; 4.非标准端口 SQL Server数据库的默认端口是1433，连接非标端口字符串如下所示： Driver={ODBC Driver 17 for SQL Server};Server=myServerName,myPortNumber;Database=myDataBase;UID=myUsername;PWD=myPassword; 通过配置DSN也可连接数据库，但是这样写的脚本在同事间分享不方便，故不推荐。 win10开始–&gt;运行 打开ODBC数据源(64) 配置。 odbc-dsn con &lt;- dbConnect(odbc::odbc(), dsn=&quot;ghzy&quot;) dbGetInfo(con) #查看连接信息 $dbname [1] &quot;spb&quot; $dbms.name [1] &quot;Microsoft SQL Server&quot; $db.version [1] &quot;12.00.5203&quot; $username [1] &quot;dbo&quot; $host [1] &quot;&quot; $port [1] &quot;&quot; $sourcename [1] &quot;ghzy&quot; $servername [1] &quot;personalSQL&quot; $drivername [1] &quot;msodbcsql17.dll&quot; $odbc.version [1] &quot;03.80.0000&quot; $driver.version [1] &quot;17.05.0002&quot; $odbcdriver.version [1] &quot;03.80&quot; $supports.transactions [1] TRUE $getdata.extensions.any_column [1] FALSE $getdata.extensions.any_order [1] FALSE attr(,&quot;class&quot;) [1] &quot;Microsoft SQL Server&quot; &quot;driver_info&quot; &quot;list&quot; 8.2.4 读写数据库 1.查询 odbc::dbGetQuery()函数执行sql语句并返回数据 dt &lt;- odbc::dbGetQuery(con,&#39;select * from DT&#39;) head(dt) 2.写入数据库 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,overwrite = T ) # 是否覆盖 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,append = T ) # 是否追加 由于odbc包的函数都是DBI中一些函数的实现，我们将其它的一些函数放在接下来的DBI包中讲解。 综上，我们使用odbc包主要是作为连接开放式数据库(odbc)中介使用。 在一台计算机上可以安装多个SQL Server,每个SQL Server就是一个实例，实例分为默认实例和命令实例。↩︎ "],["database-DBI-package.html", "8.3 DBI包", " 8.3 DBI包 R包DBI将与DBMS13的连接分为“前端”和“后端”，DBI定义了一个由DBI后端实现的接口,接口定义了一些类和方法,支持以下一些操作： 连接/断开与DBMS的连接 在DBMS中创建和执行语句 从语句中提取结果 通过DBI可以连接大部分主流关系型数据库，如:PostgreSQL,SQL Server,Oralce,MySQL,SQLite。 DBI介绍 8.3.1 安装 从CRAN安装发行的DBI版本： install.packages(&#39;DBI&#39;) 从Github安装开发的DBI版本： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-dbi/DBI&quot;) 8.3.2 连接数据库 连接MS SQL SERVER 通过以下代码即可连接微软的sql server,服务器172.16.88.2(即IP地址)的数据库，成功连接后即可与数据库交互。 library(DBI) con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) 查询数据库编码方式,从而选择连接数据库时相应的编码方式。 con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;ODBC Driver 17 for SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) #查看编码是否是936 代表中文简体 sql &lt;- &quot;SELECT COLLATIONPROPERTY( &#39;chinese_prc_ci_as&#39;, &#39;codepage&#39; )&quot; dbGetQuery(con,sql) # same above # dbExecute(con,sql) # 关闭数据库连接 DBI::dbDisconnect(con) 连接mysql MySQL()函数来源RMySQL包，用来创建&lt;MySQLDriver&gt;驱动，以下代码可连接到阿里云的MySQL数据库。 library(RMySQL) con &lt;- dbConnect(MySQL(), dbname = &quot;test&quot;, user = &quot;test_admin&quot;, password = &quot;30HL1234M7#￥lD6gxjB&quot;, host = &quot;prd-public-mypersonal.mysql.test.zhangjiabei.rds.aliyuncs.com&quot; ) 或者通过本地已安装驱动连接数据库 con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;MySQL ODBC 8.0 Unicode Driver&quot;, Server = &quot;localhost&quot;, UID = &quot;root&quot;, PWD = &quot;123456&quot;, Database = &quot;mysql&quot;, Port = 3306 ) mysql数据库默认端口是3306,访问不通时记得检查3306端口是否开放。 连接oracle 由ROracle包构造驱动。 library(ROracle) drv &lt;-dbDriver(&quot;Oracle&quot;) connect.string &lt;- &#39;(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.16.88.129)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = bidev) ))&#39; #连接字符串 con &lt;- dbConnect(drv,username = &quot;query&quot;, password = &quot;query&quot;,dbname = connect.string) 8.3.3 读写数据库 dbGetQuery()函数查询数据并直接返回,dbExecute()执行sql语句，是dbSendStatement()的封装。 # dbGetQuery 直接查询 res_table &lt;- dbGetQuery(con,&#39;select * from table&#39;) #直接获取sql查询结果 #dbReadTable直接读取 dbReadTable(con,&#39;tbl_name&#39;) #直接读取数据库中某表 # dbSendQuery 执行一个查询任务 res &lt;- dbSendQuery(conn = con,statement = &#39;select * FROM tab&#39;) dbFetch(res) dbClearResult(res) # dbExecute dbExecute(con,&#39;delete from table where num &lt;=1000&#39;) # 执行sql语句 # dbWriteTable() # 上传数据,指定表名,需上传的数据框df,overwrite是否覆盖,append是否可追加 dbWriteTable(conn = con,name = &#39;表名&#39;,value = df,overwrite=TURE,append=FALSE) 参数化查询 library(DBI) con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;iris&quot;, iris) iris_result &lt;- dbSendQuery(con, &quot;SELECT * FROM iris WHERE [Petal.Width] &gt; ?&quot;) dbBind(iris_result, list(2.3)) dbFetch(iris_result) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 6.3 3.3 6.0 2.5 virginica #&gt; 2 7.2 3.6 6.1 2.5 virginica #&gt; 3 5.8 2.8 5.1 2.4 virginica #&gt; 4 6.3 3.4 5.6 2.4 virginica #&gt; 5 6.7 3.1 5.6 2.4 virginica #&gt; 6 6.7 3.3 5.7 2.5 virginica dbBind(iris_result, list(3)) dbFetch(iris_result) #&gt; [1] Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;0 行&gt; (或0-长度的row.names) dbClearResult(iris_result) dbDisconnect(con) 实际运用中，我们从数据库(SQL Server)查询不同订单周期时的销售数据： con &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2;database=test;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10) result &lt;- dbSendQuery(con, &quot;SELECT * FROM sales_order WHERE [单据日期] between ? and ? &quot;) # ?在本处是占位符 dbBind(result,params = list(&#39;2021-01-01&#39;,&#39;2021-01-05&#39;)) dbFetch(result) dbBind(result,params = list(&#39;2021-05-01&#39;,&#39;2021-05-05&#39;)) dbFetch(result) dbClearResult(result) 以上方式可以实现参数化查询，减少代码量，但是由于查询速度相比dbGetQuery()较慢，我一般不采用。 关于sql语句中?的用法请自行查阅?dbBind()。DBI当前未指定占位符格式,将来可能会支持统一的占位符语法 8.3.4 其它函数介绍 查看数据库信息,查看表名,删除表，关闭连接等常用操作. 查看数据库信息 dbGetInfo(con) #&gt; $db.version #&gt; [1] &quot;3.35.5&quot; #&gt; #&gt; $dbname #&gt; [1] &quot;:memory:&quot; #&gt; #&gt; $username #&gt; [1] NA #&gt; #&gt; $host #&gt; [1] NA #&gt; #&gt; $port #&gt; [1] NA 数据库读写权限 返回连接账户是否只有只读权限。 dbIsReadOnly(con) #&gt; [1] FALSE 查看全部表名 win下SQL Server中文表名会乱码 dbListTables(con) #&gt; [1] &quot;flights&quot; &quot;测试表&quot; 读取表 dt &lt;- dbReadTable(con,&#39;测试表&#39;) head(dt) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa 查询 rs &lt;- dbSendQuery(con, &quot;SELECT * from flights limit 100 &quot;) dt &lt;- dbFetch(rs) head(dt) #&gt; year month day dep_delay arr_delay carrier origin dest air_time distance hour #&gt; 1 2014 1 1 14 13 AA JFK LAX 359 2475 9 #&gt; 2 2014 1 1 -3 13 AA JFK LAX 363 2475 11 #&gt; 3 2014 1 1 2 9 AA JFK LAX 351 2475 19 #&gt; 4 2014 1 1 -8 -26 AA LGA PBI 157 1035 7 #&gt; 5 2014 1 1 2 1 AA JFK LAX 350 2475 13 #&gt; 6 2014 1 1 4 0 AA EWR LAX 339 2454 18 dbClearResult(rs) # 记得清除结果 是否存在表 dbExistsTable(con,&#39;测试表&#39;) #&gt; [1] TRUE 创建表 con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbCreateTable(con, &quot;iris&quot;, iris) dbAppendTable(con, &quot;iris&quot;, iris) dbReadTable(con, &quot;iris&quot;) dbDisconnect(con) 删除表 dbRemoveTable(con,&#39;测试表&#39;) # same above # dbExecute(con,&#39;delete from 测试表&#39;) 是否有效 dbIsValid(con) rs &lt;- dbSendQuery(con, &quot;SELECT * from flights&quot;) dbIsValid(rs) dbClearResult(rs) dbIsValid(rs) 执行任务 执行语句,返回受影响的行数。 dbExecute(conn, statement, ...) dbExecute(con,&#39;delete from 测试表&#39;) 关闭连接 在完成连接后，最后关闭连接。 dbDisconnect(con) 通过学习odbc,DBI包，我们已经对R与数据库交互有一定了解。连接数据库并返回我们查询的结果，最后上传数据到数据库中，以上三步能正确使用即可满足我们数据分析师绝大部分需求。但是我们可能会对odbc与DBI的关系感到困惑,由于我并不太了解数据库，仅谈谈自己的理解，不一定正确。 以上三步，配合R的定时任务，可以完成ETL(Extract-Transform-Load). odbc提供了与odbc类数据库的连接方式，odbc基于DBI包，我们在安装odbc包时会自动安装DBI包。odbc负责连接odbc类数据库，DBI提供后端服务，换句话说odbc连接数据库，其它的交互通过DBI包完成。通过比较以下连接方式来理解： # 方式一 odbc con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;MySQL ODBC 8.0 Unicode Driver&quot;, Server = &quot;localhost&quot;, UID = &quot;root&quot;, PWD = &quot;123456&quot;, Database = &quot;test&quot;, Port = 3306 ) # 方式二 RMySQL library(RMySQL) con &lt;- dbConnect(MySQL(), dbname = &quot;test&quot;, user = &quot;root&quot;, password = &quot;123456&quot;, host = &quot;localhost&quot; ) 方式二与方式一都可以成功连接本地的mysql数据库，方式二是通过RMySQLB包的MySQL()功能提供的驱动程序。 但是不同的连接方式可能导致读写效率有明显的差异，详见oracle连接差异。 library(ROracle) # 方式一 # use ROracle packages connect databse drv &lt;-dbDriver(&quot;Oracle&quot;) connect.string &lt;- &#39;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.88.131)(PORT = 1521))(CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = ghbi) ))&#39; con_oracle &lt;- dbConnect(drv,username = &quot;pub_query&quot;, password = &quot;pub_query&quot;,dbname = connect.string,encoding=&#39;utf8&#39;) # 方式二 # use odbc packages connect databse con_odbc &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;Driver={Oracle in OraClient11g_home1};DBQ=172.16.88.131:1521/ghbi;UID=pub_query;PWD=pub_query;&quot;, timeout = 10) # Oracle in OraClient11g_home1 根据实际驱动更改 # 通过odbc::odbcListDrivers() 查看 Database Management System,即数据库管理系统↩︎ "],["database-else-package.html", "8.4 其他R包", " 8.4 其他R包 通过前文了解，以下R包(RODBC除外)的作用仅仅是提供驱动即可，再通过DBI包与数据库交互。 8.4.1 RODBC包 RODBC包是R语言对ODBC数据库接口的封装,可连接所有的ODBC数据库，但是读写效率较低。 1.安装包 install.packages(&#39;RODBC&#39;) 2.SQL SERVER 数据库举例 library(RODBC) con &lt;- odbcDriverConnect(&quot;driver={SQL Server};server=192.168.2.62;database=dbname;uid=zhongyf;pwd=Zyf123456&quot;) con RODBC::sqlQuery(con,&#39;select * from test&#39;) ` 怎样安装驱动 请参照驱动安装 ODBC for sql server driver 下载地址地址 3.数据库字符串 请参照数据库连接字符串 #ODBC Driver 17 for SQL Server cn &lt;- odbcDriverConnect(&quot;Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=name;UID=username;PWD=123456;&quot;) #server 数据库 UID 数据库账户 PWD 数据库账户密码 sql server 请参照sql server连接字符串 8.4.2 ROracle包 在第一次安装这个包时遇到了很多困难，首先需要安装oracle客户端，其次配置好环境变量，最后安装包。R与Oracle的连接需要安装Oracle Instant Client， 安装客户端 安装oracle客户端，根据电脑的位数选择相应的32位或64位，根据要连接数据库版本，可以去官网自行下载，本机需要下载的客户端地址 配置环境变量 根据自己所使用的系统，配置环境变量 OCI_INC=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\oci\\include&#39; OCI_LIB64=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\BIN&#39; 安装包 安装Roracle包需要配置相应版本的Rtools并添加到环境变量，另外配置两个oracle的环境变量。代码中有注释,按照自己安装版本路径修改。 由于ROracle依赖于Oracle Instant Client,安装之前一定要先安装好客户端。 install.packages(&#39;ROracle&#39;) 连接数据库 Roracle可以通过DBI包链接，除了驱动和连接字符串有差异，其他部分一样。 library(ROracle) drv &lt;-dbDriver(&quot;Oracle&quot;) connect.string &lt;- &#39;(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.16.88.129)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = bidev) ))&#39; #连接字符串 con &lt;- dbConnect(drv,username = &quot;query&quot;, password = &quot;query&quot;,dbname = connect.string) 乱码问题 如果连接oracle数据库，中文乱码设置以下环境变量即可，或者在启动文件配置该环境变量。 linux下可以在文件Renviron中添加，记得引号，路径为[/opt/R/4.0.2/lib/R/etc/Renviron] # 查询数据库编码 select userenv(&#39;language&#39;) from dual Sys.setenv(NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;) 由于ROracle包的安装存在一定难度，具体安装说明可以参考微信公众号-宇飞的世界R包ROracle安装 8.4.3 RMySQL包 RMySQL包的主要作用可以提供驱动与mysql数据库进行连接，在本机未安装mysql的驱动的情况下.该包正在逐渐被淘汰，可以使用RMariaDB包替换。 1.安装 Win系统下直接安装即可，其它平台下需提前安装依赖环境。 #On recent Debian or Ubuntu install libmariadbclient-dev sudo apt-get install -y libmariadbclient-dev #On Fedora, CentOS or RHEL we need mariadb-devel: sudo yum install mariadb-devel #On OS-X use mariadb-connector-c from Homebrew: brew install mariadb-connector-c install.packages(&#39;RMySQL&#39;) 2.连接使用 上述连接方式一致，仅仅是指驱动差异 library(RMySQL) con &lt;- RMySQL::dbConnect(drv = RMySQL::MySQL(),host=&#39;localhost&#39;,dbname=&quot;mysql&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) RMariaDB包与RMySQL包用法基本一致，在连接时注意驱动的选择即可。 install.packages(&#39;RMariaDB&#39;) library(RMariaDB) con &lt;- RMySQL::dbConnect(drv = RMariaDB::MariaDB() ,host=&#39;localhost&#39;,dbname=&quot;dbtest&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) 8.4.4 RSQLite RSQLite是练习使用R中的数据库的最简单方法，因为程序包本身包含SQLite，无需任何外部软件。 项目地址 1.安装 install.packages(&quot;RSQLite&quot;) 2.基础用法 library(DBI) # 在内存中创建一个临时数据库 con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbListTables(con) #&gt; character(0) dbWriteTable(con, &quot;mtcars&quot;, mtcars) dbListTables(con) #&gt; [1] &quot;mtcars&quot; df &lt;- dbReadTable(con, &quot;mtcars&quot;) head(df) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; 2 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 res &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) df &lt;- dbFetch(res) dbClearResult(res) head(df) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; 3 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; 4 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; 5 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; 6 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 dbDisconnect(con) 基础用法与DBI功能一致。 "],["database-big-data.html", "8.5 大数据相关R包", " 8.5 大数据相关R包 sparklyr https://spark.rstudio.com/ RClickhouse https://github.com/hannesmuehleisen/clickhouse-r 其它R包，如bigrquery。 8.5.1 sparklyr sparkly包可以连接[spark]14(http://spark.apache.org/)，并且支持dplyr包方法。详情情况sparklyr介绍 spark 依赖java环境，需要系统上安装java方可使用。 1.R 包安装 # cran 版 install.packages(&quot;sparklyr&quot;) # 开发版 devtools::install_github(&quot;rstudio/sparklyr&quot;) 2.连接到 spark 连接之前需要安装 java 环境以及通过sparklyr::spark_install()安装 spark。 java下载，下载安装后配置java环境变量。 # Win10 JAVA_HOME = C:\\Program Files\\Java\\jre1.8.0_291 检查环境变量，在R中执行 Sys.getenv(&#39;JAVA_HOME&#39;) &gt;&gt; &quot;C:\\\\Program Files\\\\Java\\\\jre1.8.0_291&quot; library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;) 3.使用 dplyr library(dplyr) iris_tbl &lt;- copy_to(sc, iris) flights_tbl &lt;- copy_to(sc, nycflights13::flights, &quot;flights&quot;) batting_tbl &lt;- copy_to(sc, Lahman::Batting, &quot;batting&quot;) dplyr::src_tbls(sc) filter实列: flights_tbl %&gt;% filter(dep_delay == 2) sparkrly同样兼容DBI，支持SQL语句查询，更多详情请官网查阅。 8.5.2 RClickhouse ClickHouse 是面向列的数据库管理系统(DBMS),用于对查询进行连接分析处理(OLAP)。 按照官网安装教程安装。 1.R 包安装 install.packages(&quot;RClickhouse&quot;) 2.配置远程连接 参考资料 3.安装驱动 安装ODBC驱动是为了和Power BI，tableau，Excel等工具连接。 驱动下载 4.连接 library(RClickhouse) library(DBI) # 本地默认连接 con_local &lt;- dbConnect(RClickhouse::clickhouse(), host=&quot;localhost&quot;, port=9000L, user=&quot;default&quot;, password=&quot;&quot;) dbExecute(con_local,&quot;CREATE DATABASE IF NOT EXISTS tutorial&quot;) # 指定库远程连接 con_remote &lt;- dbConnect(RClickhouse::clickhouse(), host=&quot;192.168.2.237&quot;, port=9000L, user=&quot;default&quot;, password=&quot;&quot;,dbname=&#39;tutorial&#39;) win系统上配置odbc时，注意ODBC版本，clickhouse-odbc下载。最初我使用的odbc版本太旧，Excel无法成功连接clickhouse数据库。 我用tableau实时连接clickhouse数据库，测试速度完爆 MS SQL Server，测试的数据量大概在2000万行，6G左右。 我用Excel通过odbc驱动连接，数据据提取速度特别慢(相比MS SQL Server)。不知道是不是因为 Exce l 和MS SQL Server 都是微软自家产品。另外表中的时间字段和 MS SQL Server 不一样，不能直接上传。 整体测试下来，建议持续保持观望，有机会就测试先试用着。毕竟在OLAP方面确实有一定优势，并且数据库支持中文，但是表头目前还未支持中文。 Apache Spark 是用于大规模数据处理的统一分析引擎。↩︎ "],["database-FAQ.html", "8.6 常见问题", " 8.6 常见问题 在使用R包连接数据库时有些常见的问题，整理如下。 8.6.1 乱码问题 R中中文乱码问题一直都很麻烦，并且常常遇见，尤其是使用win系统时。 MS SQL SERVER 乱码 修改encoding参数，在win系统下，可以考虑使用RODBC包连接查询数据库，因为该包将自动转换编码，不会存在乱码问题。但是上传效率奇慢，为了减少包依赖保持代码一致性使用odbc连接数据库时遇到乱码，在连接数据库时设定encoding即可。 # win con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;gbk&quot; ) # linux con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;utf8&quot; ) MySQL乱码 1.代码修改 #执行查询语句前执行 dbSendQuery(con,&#39;SET NAMES gbk&#39;) 2.ODBC配置 如果是通过ODBC数据源连接,可通过配置需改,如下所示： ODBC配置截图 oracle乱码 linux上通过ROracle连接oracle数据库，中文乱码。可以通过设置环境变量或配置.Renviron文件修改oracle语言环境。 Sys.setenv(NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;) 8.6.2 无法连接问题 SQL Servver无法连接 如果是自己安装配置的数据库，无法通过IP地址连接，可能是没有开启远程连接。 mysql无法连接 首先需要装mysql的驱动,确保RMySQL成功安装 如果是测试自己安装的mysql,可以先用Navicat连接,如果出现Authentication plugin ‘caching_sha2_password’ cannot be loaded的错误。 可能是由于 mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password,通过修改加密规则可解决无法连接问题。 --cmd 登录本地数据 mysql -u root -p --输入密码 password: --执行命令 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 ---ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; 看账号权限注意与上面的区别 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 8.6.3 远程连接 当你需要远程连接时，需要确保数据库的远程连接已经开启。在数据库中开启某账户远程连接权限,在公司的话，数据库连接问题咨询公司的IT人员。自己个人电脑上安装的MS SQL SERVER数据库需要自行开启远程连接。 另外如果是云服务器上搭建的数据库,需要开启数据库端口，如Mysql默认端口3306;如果是阿里云的Rds数据库,找DBA管理员要数据库地址以及端口信息。 8.6.4 跳板机连接 有些数据库是无法外网访问的，需要通过跳板机跳转后后才有权限访问，或者给某公网IP配置权限后才能访问。 R解决方案 在本地使用Putty或通过R包ssh解决。 library(ssh) session &lt;- ssh_connect(host = &#39;user@ip:port&#39;,passwd = &#39;password&#39;) ssh_tunnel(session = session,port = 3306,target = &#39;ip:port&#39;) python解决方案 import mysql.connector import sshtunnel with sshtunnel.SSHTunnelForwarder( (_host, _ssh_port), ssh_username=_username, ssh_password=_password, remote_bind_address=(_remote_bind_address, _remote_mysql_port), local_bind_address=(_local_bind_address, _local_mysql_port) ) as tunnel: connection = mysql.connector.connect( user=_db_user, password=_db_password, host=_local_bind_address, database=_db_name, port=_local_mysql_port) ... 关于数据库无法连接的问题，请咨询公司DBA管理人员。 "],["database-dbplyr-package.html", "8.7 dbplyr", " 8.7 dbplyr dbplyr将dplyr包的函数转化为SQL语句去服务器获取数据；在数据量较大、计算较多时，可以将远程连接数据库中的表当作内存中的数据框使用，当本机内存不够大时，这样做的好处不言而喻。 至于为什么使用dbplyr而不是直接编写SQL,因为： dbplyr写起来简洁高效，基本跟用dplyr没有差别 能利用数据库所在服务器的算力，配合上并行计算，在处理大量数据时，大大加快速度。 不同数据库的语法存在差异，当源数据存在不同数据库时，用R的dbplyr包清洗数据时能加快效率 通过dplyr动词方便实现复杂的逻辑，当过程越多越复杂时dbplyr的优势越明显，不用一层层嵌套语句。 dbplyr项目介绍 8.7.1 安装 dbplyr包是tidyverse系列核心包之一，可以通过安装tidyverse或仅安装dbplyr。 install.packages(&quot;tidyverse&quot;) # 从CRAN安装发行版 install.packages(&quot;dbplyr&quot;) # 开发版 library(devtools) devtools::install_github(&quot;tidyverse/dbplyr&quot;) 8.7.2 基础用法 library(dplyr) library(dbplyr) mf &lt;- memdb_frame(x = 1, y = 2) mf %&gt;% mutate( a = y * x, b = a ^ 2, ) %&gt;% show_query() library(dplyr) #connect database con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = &quot;:memory:&quot;) # 上传数据 copy_to(con, nycflights13::flights, &quot;flights&quot;, temporary = FALSE, indexes = list( c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), &quot;carrier&quot;, &quot;tailnum&quot;, &quot;dest&quot; ) ) # 查看库中全部表名 #dbListTables(con) #tbl()引用表flights flights_db &lt;- tbl(con, &quot;flights&quot;) flights_db # 开始查询 flights_db %&gt;% select(year:day, dep_delay, arr_delay) flights_db %&gt;% filter(dep_delay &gt; 240) flights_db %&gt;% group_by(dest) %&gt;% summarise(delay = mean(dep_time)) 部分简单不复杂的sql语句可以用dplyr的语法代替. tailnum_delay_db &lt;- flights_db %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay,na.rm = T), n = n() ) %&gt;% arrange(desc(delay)) %&gt;% filter(n &gt; 100) tailnum_delay_db tailnum_delay_db %&gt;% show_query() tailnum_delay &lt;- tailnum_delay_db %&gt;% collect() #把数据从数据库加载到R内存中 8.7.3 无法正确转化 在使用过程中发现无法识别lubridate包的函数，但是dbplyr对于不认识的函数都将保留。利用这个特性，可以使用数据库中原生的相关函数：如下所示，在Oracle中to_date函数。 以下的自定义函数可以实现按照想要group_by的字段汇总金额、数量、吊牌额、折扣率等,其中关于时间周期的筛选就利用了该特性。 date #个人写的针对目前公司数仓写的包中获取销售数据的一段代码 get_sales_data &lt;- function(con,...,start_date,end_date,brand_name,channel_type = NULL ,area_name = NULL,boss_name = NULL,category_name = NULL,shop_no = NULL){ store_table &lt;- store(con,brand_name = brand_name,channel_type = channel_type ,area_name = area_name,boss_name = boss_name,shop_no = shop_no) #门店信息 sku_table &lt;- sku(con,category_name = category_name ) #商品信息 tbl(con, in_schema(&quot;DW&quot;, &quot;DW_SALE_SHOP_F&quot;)) %&gt;% #DW层 select(BILL_DATE1, SKU_NO, SHOP_NO, BILL_QTY, BILL_MONEY2, PRICE) %&gt;% filter(between( BILL_DATE1, to_date(start_date, &quot;yyyy-mm-dd&quot;), to_date(end_date, &quot;yyyy-mm-dd&quot;) )) %&gt;% mutate(年 = year(BILL_DATE1), 月 = month(BILL_DATE1)) %&gt;% inner_join(store_table) %&gt;% inner_join(sku_table) %&gt;% group_by(...) %&gt;% summarise( 金额 = sum(BILL_MONEY2, na.rm = TRUE), 数量 = sum(BILL_QTY, na.rm = TRUE), 吊牌金额 = sum(BILL_QTY * PRICE, na.rm = TRUE)) %&gt;% collect() %&gt;% mutate(折扣率:= 金额 / 吊牌金额) %&gt;% arrange(...) # return(res) } like mf %&gt;% filter(x %LIKE% &quot;%foo%&quot;) %&gt;% show_query() 特殊用法 特殊情况可以使用sql()函数 mf %&gt;% transmute(factorial = sql(&quot;x!&quot;)) %&gt;% show_query() "],["database-reference-material.html", "8.8 参考资料", " 8.8 参考资料 1.DBI包资料 https://dbi.r-dbi.org/reference/ 2.dbplyr包资料 https://dbplyr.tidyverse.org/ 3.rstudio关于数据库介绍 https://db.rstudio.com/databases 4.数据库连接字符串介绍 https://www.connectionstrings.com/ 5.驱动安装 https://github.com/r-dbi/odbc#installation 6.关于Roracle的安装介绍 https://mp.weixin.qq.com/s/QLwedZ5mTybqSXdHMTGRIw 7.DBI消息 https://www.r-consortium.org/blog/2017/05/15/improving-dbi-a-retrospect "],["R-loop-structure.html", "9 循环结构", " 9 循环结构 所有现代编程语言都提供允许重复指令或指令快的特殊构造。在R中当需要重复做某动作时,可运用循环结构。比如1+2+3,我们可以直接写表达式，但是1+2+3+…+100，我们不可能直接写表达式，这时就可以借用循环重复计算。 1+2+3 #&gt; [1] 6 loop-structure "],["R-loop-description.html", "9.1 R循环介绍", " 9.1 R循环介绍 通过命令?Control可以查看R中的循环结构。循环结构中关键词for，while,repeat，以及break,next。 我们终极目是:清晰了解循环结构后，用向量化或purrr包提供的功能摆脱循环。 9.1.1 简单示例 利用循环实现1到100连续相加求和 total &lt;- 0 for(i in 1:100){ total &lt;- total+i } print(paste0(&#39;1到100连续相加求和等于:&#39;,total)) #&gt; [1] &quot;1到100连续相加求和等于:5050&quot; # loop structure # for (var in seq) {expr} 9.1.2 循环结构 R中有三种循环结构： for for循环是大家使用最多的循环结构，for循环的迭代次数是固定的，并且事先知道。如最开始的示例中，1连续相加到100,共计加法次数是100次。 for循环示例如下： library(tidyverse) df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) output &lt;- vector(&quot;double&quot;, ncol(df)) # 1. output for (i in seq_along(df)) { # 2. sequence output[[i]] &lt;- median(df[[i]]) # 3. body } output #&gt; [1] -0.2458 -0.2873 -0.0567 0.1443 代码解释： 上面代码中 vector函数创建一个空向量带指定长度，有两个参数，第一个时向量类型(‘逻辑,’‘整数,’‘双精度,’’字符’等)，第二个是向量长度 vector(length=5),类型默认是逻辑型。 seq_along可以?seq查看用法. hadely 解释如下: You might not have seen seq_along() before. It’s a safe version of the familiar 1:length(l), with an important difference: if you have a zero-length vector, seq_along() does the right thing: #wrong seq_along(c()) #&gt; integer(0) 1:length(c()) #&gt; [1] 1 0 # generates the integer sequence 1, 2, ..., length(along.with). (along.with is usually abbreviated to along, and seq_along is much faster.) 循环中尽可能利用R中的向量化,比如指定output的长度,当数据量大的时候效率提升将比较明显,养成向量化的意识对提高代码效率有显著效果. while 当我们不知道要循环迭代的次数时，可以考虑使用while循环结构。 示例如下： readinteger &lt;- function(){ n &lt;- readline(prompt=&quot;Please, enter your ANSWER: &quot;) } response &lt;- as.integer(readinteger()) while (response!=42) { print(&quot;Sorry, the answer to whatever the question MUST be 42&quot;); response &lt;- as.integer(readinteger()); } Repeat repeat循环与while循环类似。如下所示，直到满足if条件后才会跳出循环结构。 i &lt;- 1 total &lt;- 0 repeat{ total &lt;- total+i i &lt;- i+1 if(i &gt; 100){ print(paste0(&#39;连续相加求和等于:&#39;,total)) break } } #&gt; [1] &quot;连续相加求和等于:5050&quot; 9.1.3 循环控制 R中如何中断或退出循环呢？除了自然结束的for循环，while,repeat是如何结束的呢，在R中，我们可以通过break以及next控制循环，上一示例中我们已经看到break是如何跳出循环的。 next 用法 for(i in letters[1:6] ){ if(i == &quot;d&quot;){ next } print(i) } #&gt; [1] &quot;a&quot; #&gt; [1] &quot;b&quot; #&gt; [1] &quot;c&quot; #&gt; [1] &quot;e&quot; #&gt; [1] &quot;f&quot; break 用法 当条件满足时，跳出循环。 m=10 n=10 ctr=0 mymat = matrix(0,m,n) for(i in 1:m) { for(j in 1:n) { if(i==j) { break; } else { # you assign the values only when i&lt;&gt;j mymat[i,j] = i*j ctr=ctr+1 } } print(i*j) } #&gt; [1] 1 #&gt; [1] 4 #&gt; [1] 9 #&gt; [1] 16 #&gt; [1] 25 #&gt; [1] 36 #&gt; [1] 49 #&gt; [1] 64 #&gt; [1] 81 #&gt; [1] 100 # 共赋值多少次 print(ctr) #&gt; [1] 45 9.1.4 嵌套循环 嵌套循环即在循环体中再循环。 # not run v &lt;- vector(length = 100) for(i in 1:10){ for(j in 1:10){ v[i*j] = i * j } } "],["loop-changes.html", "9.2 循环变化", " 9.2 循环变化 9.2.1 修改已有对象 res &lt;- 1:100 for(i in seq_along(res)){ res[i] &lt;- res[i] * i } str(res) #&gt; int [1:100] 1 4 9 16 25 36 49 64 81 100 ... 9.2.2 循环模式 共有三种遍历向量的方法,之前展示的都是遍历数字索引for (i in seq_along(xs)),并使用提取值x[[i]]。除此之外，还有两种方式: 循环遍历元素 for(i in xs),例如我们需要保存文件时,可以利用这种循环模式 遍历名称 for (nm in names(xs)),我们可以使用x[[nm]] 该名称访问.当我们要在文件名中使用名称时会比较方便. results &lt;- vector(&quot;list&quot;, length(x)) names(results) &lt;- names(x) 数字索引的循环模式最常用,因为可以根据位置提取名称和值. for (i in seq_along(x)) { name &lt;- names(x)[[i]] value &lt;- x[[i]] } 9.2.3 未知长度输出 有时候我们的循环我们不确定输出的长度是多少.这样会逐步增加向量的长度,如下所示： means &lt;- c(0, 1, 2) output &lt;- double() for (i in seq_along(means)) { n &lt;- sample(100, 1) output &lt;- c(output, rnorm(n, means[[i]])) } str(output) #&gt; num [1:69] 0.255 -0.553 1.405 -0.795 -1.567 ... 但是这种方式浪费时间，当数据量大时候效率会很低下。因为时间复杂度为(\\(O(n^2)\\))，解决方案是将结果保存在列表中,然后在完成循环后合并为单个向量: out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)) { n &lt;- sample(100, 1) out[[i]] &lt;- rnorm(n, means[[i]]) } str(out) #&gt; List of 3 #&gt; $ : num [1:89] -1.399 0.259 -0.442 0.569 2.127 ... #&gt; $ : num [1:81] 2.36 0.929 0.728 -1.447 1.065 ... #&gt; $ : num [1:35] 0.0381 2.946 2.549 1.4225 0.7717 ... str(unlist(out)) #unlist将列表向量化 #&gt; num [1:205] -1.399 0.259 -0.442 0.569 2.127 ... "],["purrr-Iteration.html", "10 循环迭代purrr介绍", " 10 循环迭代purrr介绍 常常需要重复操作同样的功能函数，这时可以用迭代来实现。purrr包提供了一套完整的函数来处理循环迭代，可以有效减少重复性工作和代码。 purrr项目介绍 "],["purrr-basic-usage.html", "10.1 简单用法", " 10.1 简单用法 map 用map循环迭代,map函数始终返回list对象。 library(tidyverse) # define function addTen &lt;- function(.x) { return(.x + 10) } map(.x = c(1, 4, 7), .f = addTen) #&gt; [[1]] #&gt; [1] 11 #&gt; #&gt; [[2]] #&gt; [1] 14 #&gt; #&gt; [[3]] #&gt; [1] 17 # not run # map(c(1, 4, 7), addTen) # same above map_dbl 用map_dbl循环迭代，map_dbl函数返回vector。 #library(purrr) add1 &lt;- function(x) { (x+1)*x } result1 &lt;- map_dbl(1:1000,add1) # maP_dbl 输出结果为向量 #for版本 result2 &lt;- vector(length = 1000) for(i in 1:1000){ result2[i] &lt;- (i+1) * i } # test #not run #table(result1 == result2) # all equal identical(result1,result2) #&gt; [1] TRUE "],["purrr-map.html", "10.2 map系列常用函数", " 10.2 map系列常用函数 map_chr map_chr(.x, .f) ,map_chr 返回对象为字符串 map_dbl map_dbl(.x, .f) ,map_dbl 返回数字向量(双精度) map_df map_df(.x, .f),map_df 返回对象为数据框,类似函数 map_dfr(.x,.f),map_dfc(.x,.f) map_gl map_lgl(.x, .f) 返回逻辑向量 map_int map_int(.x, .f, ...) 返回整数 map_df()函数示例 # 采用匿名函数 map_df(c(1, 4, 7), function(.x) { return(data.frame(old_number = .x, new_number = addTen(.x))) }) #&gt; old_number new_number #&gt; 1 1 11 #&gt; 2 4 14 #&gt; 3 7 17 #同上 #step1 定义函数 make_dataframe &lt;- function(x){ data.frame(old_number = x,new_number = addTen(x)) } #step2 计算 map_df(c(1,4,7),make_dataframe) #&gt; old_number new_number #&gt; 1 1 11 #&gt; 2 4 14 #&gt; 3 7 17 "],["purrr-reduce.html", "10.3 归约累计函数", " 10.3 归约累计函数 reduce、accumulate()函数用法介绍. reduce 在实际工作中,我长用reduce函数实现merge()功能。示例如下： reduce(1:100,`+`) #&gt; [1] 5050 reduce(100:1,`-`) #&gt; [1] -4850 将函数功能不断运用到list上得到最后结果。 n &lt;- 10 dt1 &lt;- data.frame(a=letters[n],b1=rnorm(n)) dt2 &lt;- data.frame(a=letters[n],b2=rnorm(n)) dt3 &lt;- data.frame(a=letters[n],b3=rnorm(n)) dt4 &lt;- data.frame(a=letters[n],b4=rnorm(n)) reduce(list(dt1,dt2,dt3,dt4),merge) # not run # reduce(list(dt1,dt2,dt3,dt4),merge,by=&#39;a&#39;) same above accumulate 1:5 %&gt;% accumulate(`+`) #&gt; [1] 1 3 6 10 15 accumulate(letters[1:5], paste, sep = &quot;.&quot;) #&gt; [1] &quot;a&quot; &quot;a.b&quot; &quot;a.b.c&quot; &quot;a.b.c.d&quot; &quot;a.b.c.d.e&quot; "],["purrr-safely-functions.html", "10.4 安全函数", " 10.4 安全函数 possibly() 和 safely(),当循环时候遇到错误报错导致整个程序停止,这不是我们想要的。 l &lt;- list(1,2,3,4,&#39;5&#39;) map(l,function(.x) .x+1) 以上程序将会报错,不能正确得到结果。 l &lt;- list(1,2,3,4,&#39;5&#39;) test_fun &lt;- safely(function(.x) .x+1) map(l,test_fun) #&gt; [[1]] #&gt; [[1]]$result #&gt; [1] 2 #&gt; #&gt; [[1]]$error #&gt; NULL #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$result #&gt; [1] 3 #&gt; #&gt; [[2]]$error #&gt; NULL #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$result #&gt; [1] 4 #&gt; #&gt; [[3]]$error #&gt; NULL #&gt; #&gt; #&gt; [[4]] #&gt; [[4]]$result #&gt; [1] 5 #&gt; #&gt; [[4]]$error #&gt; NULL #&gt; #&gt; #&gt; [[5]] #&gt; [[5]]$result #&gt; NULL #&gt; #&gt; [[5]]$error #&gt; &lt;simpleError in .x + 1: 二进列运算符中有非数值参数&gt; 用safely()函数将原始function包裹起来,即使执行过程中遇到错误也可以完成整个任务,不会因为中途报错停止,在大型循环过程中,如爬虫过程中比较实用。 "],["purrr-multi-parameter.html", "10.5 映射多个参数", " 10.5 映射多个参数 map2 和 pmap 函数可以映射两个及以上参数。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) map2(li1,li2,`+`) #&gt; [[1]] #&gt; [1] 3 #&gt; #&gt; [[2]] #&gt; [1] 7 #&gt; #&gt; [[3]] #&gt; [1] 11 类似函数 map2_dbl,map2_chr,map2_dfr等等。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) li3 &lt;- list(2,4,6) li1 &lt;- c(1,3,5) li2 &lt;- c(2,4,6) li3 &lt;- c(2,3,4) li &lt;- list(li1,li2,li3) pmap(li,sum) #&gt; [[1]] #&gt; [1] 5 #&gt; #&gt; [[2]] #&gt; [1] 10 #&gt; #&gt; [[3]] #&gt; [1] 15 同上有pmap_int,pmap_dbl,pmap_dfr等函数。 "],["purrr-else-functions.html", "10.6 其他函数介绍", " 10.6 其他函数介绍 flatten flatten()系列函数可以将列表输出为稳定类型。purrr package 自带Examples。 x &lt;- rerun(2, sample(4)) x x %&gt;% flatten() x %&gt;% flatten_int() # You can use flatten in conjunction with map x %&gt;% map(1L) %&gt;% flatten_int() # But it&#39;s more efficient to use the typed map instead. x %&gt;% map_int(1L) imap imap()系列函数官方描述： imap_xxx(x, …), an indexed map, is short hand for map2(x, names(x), …) if x has names, or map2(x, seq_along(x), …) if it does not. This is useful if you need to compute on both the value and the position of an element. imap,当x有names(x)或者seq_along(x)属性,imap是map2的另一种表达方式。 使用公式快捷方式时,第一个参数是值(.x),第二个参数是位置/名称(.y)。 详情请查看:?imap 示例1： imap_chr(sample(10), ~ paste0(.y, &quot;: &quot;, .x)) #&gt; [1] &quot;1: 7&quot; &quot;2: 5&quot; &quot;3: 6&quot; &quot;4: 10&quot; &quot;5: 4&quot; &quot;6: 1&quot; &quot;7: 9&quot; &quot;8: 8&quot; &quot;9: 3&quot; #&gt; [10] &quot;10: 2&quot; sample(10),没有names(),只有长度信息。转化成map2表达如下: #same above map2_chr(sample(10),1:10,~paste0(.y,&quot;: &quot;,.x)) # 第二个list 为位置信息. #&gt; [1] &quot;1: 2&quot; &quot;2: 7&quot; &quot;3: 3&quot; &quot;4: 6&quot; &quot;5: 8&quot; &quot;6: 5&quot; &quot;7: 1&quot; &quot;8: 4&quot; &quot;9: 10&quot; #&gt; [10] &quot;10: 9&quot; "],["self-define-function.html", "11 自定义函数", " 11 自定义函数 函数功能使我们尽可能避免复制粘贴代码,而且需要更改的时候不需要大面积修改代码仅需要调整函数参数,使代码整体更加模块化. 假设有工作任务需要给商品SKU排名,在代码中需要重复以下代码5次,当区间需要修改的时候就是灾难. 原始代码示例如下: library(tidyverse) num &lt;- sample(1:1000,1000) res1 &lt;- if_else(num &lt;= 50,&quot;1-50&quot;, if_else(num &lt;= 100,&quot;51-100&quot;, if_else(num &lt;= 150,&quot;101-150&quot;, if_else(num &lt;= 200 ,&quot;151-200&quot;, if_else(num &gt;200,&quot;200以上&quot;,&#39;其他&#39;))))) # same above # case_when(num &lt;= 50 ~ &#39;1-50&#39;, # num &lt;= 100 ~ &#39;51-100&#39;, # num &lt;= 150 ~ &#39;101-150&#39;, # num &lt;= 200 ~ &#39;151-200&#39;, # num &gt; 100 ~ &#39;200以上&#39; # ) # 个人倾向data.table # data.table::fifelse() # data.table::fcase() 是sql中case when的实现 函数化后代码示例如下: 当需要修改区间时候仅仅只需要调整参数,而不必大量修改代码,当在脚本中需要调用多次时,能简洁代码. cut_function &lt;- function(vecto,x,n){ vec &lt;- c(0) for(i in 1:n){ kong &lt;- i*x vec &lt;- c(vec,kong) } vec &lt;- c(vec,Inf) labels &lt;- c() j &lt;- 1 while (j&lt;=n) { labels[j] &lt;- str_c(vec[j]+1,&quot;-&quot;,vec[j+1]) j &lt;- j+1 } labels &lt;- c(labels,paste0(vec[j],&#39;以上&#39;)) res &lt;- cut(x = vecto,breaks = vec,labels = labels) %&gt;% as.character() } res2 &lt;- cut_function(num,50,4) identical(res1,res2) #&gt; [1] TRUE 当然以上的函数本质是用base R中cut(): cut(1:201,breaks = c(0,50,100,150,200,Inf)) #&gt; [1] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [8] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [15] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [22] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [29] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [36] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [43] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] (0,50] #&gt; [50] (0,50] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [57] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [64] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [71] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [78] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [85] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [92] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] (50,100] #&gt; [99] (50,100] (50,100] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [106] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [113] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [120] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [127] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [134] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [141] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] (100,150] #&gt; [148] (100,150] (100,150] (100,150] (150,200] (150,200] (150,200] (150,200] #&gt; [155] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [162] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [169] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [176] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [183] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [190] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] (150,200] #&gt; [197] (150,200] (150,200] (150,200] (150,200] (200,Inf] #&gt; Levels: (0,50] (50,100] (100,150] (150,200] (200,Inf] 参考资料 "],["define-function-example.html", "11.1 简单示例", " 11.1 简单示例 给函数取一个合适名字是很难的事情,需尽可能从函数名称看出你实现的功能. add_ten &lt;- function(x){ res &lt;- x+10 return(res) #可以不用显示返回 } add_ten(1) #&gt; [1] 11 写函数时需要考虑函数使用情况,尽可能考虑容错情况,当输入不符合预期时能友好提示错误. add_ten &lt;- function(x){ if(is.numeric(x)==TRUE){ x+10 } else { print(&#39;Error,请输入数字&#39;) } } "],["define-function-conditional-execution.html", "11.2 条件执行", " 11.2 条件执行 has_name &lt;- function(x) { nms &lt;- names(x) if (is.null(nms)) { rep(FALSE, length(x)) } else { !is.na(nms) &amp; nms != &quot;&quot; } } 11.2.1 多条件执行 if (this) { # do that } else if (that) { # do something else } else { # } 当需要很多if时可考虑用switch()功能 function(x, y, op) { switch(op, plus = x + y, minus = x - y, times = x * y, divide = x / y, stop(&quot;Unknown op!&quot;) ) } "],["define-function-parameter.html", "11.3 函数参数", " 11.3 函数参数 函数的参数通常分为两大类,一组是提供要计算的参数,另外一组提供计算时的细节参数. mean_ci &lt;- function(x, conf = 0.95) { se &lt;- sd(x) / sqrt(length(x)) alpha &lt;- 1 - conf mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2)) } x &lt;- runif(100) mean_ci(x) #&gt; [1] 0.431 0.543 mean_ci(x, conf = 0.99) #&gt; [1] 0.414 0.560 11.3.1 参数名称 参数的名称很重要,方便我们理解参数含义,调用时不会混乱.以下时几个重要的参数名称 x, y, z: vectors. w: a vector of weights. df: a data frame. i, j: numeric indices (typically rows and columns). n: length, or number of rows. p: number of columns. 11.3.2 检查参数值 在写函数时,并不清楚最终函数的输出,在编写函数时进行约束是有必要的. wt_mean &lt;- function(x, w) { if (length(x) != length(w)) { stop(&quot;`x` and `w` must be the same length&quot;, call. = FALSE) } sum(w * x) / sum(w) } 11.3.3 …参数 R中的许多函数都能接受任意数量的输入： sum(1,2,3,4,5,6,7,8,9,10) #&gt; [1] 55 stringr::str_c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;) #&gt; [1] &quot;abdefgh&quot; 下面的例子中 commas &lt;- function(...) stringr::str_c(..., collapse = &quot;, &quot;) commas(letters[1:10]) #&gt; [1] &quot;a, b, c, d, e, f, g, h, i, j&quot; #&gt; [1] &quot;a, b, c, d, e, f, g, h, i, j&quot; rule &lt;- function(..., pad = &quot;-&quot;) { title &lt;- paste0(...) width &lt;- getOption(&quot;width&quot;) - nchar(title) - 5 cat(title, &quot; &quot;, stringr::str_dup(pad, width), &quot;\\n&quot;, sep = &quot;&quot;) } rule(&quot;Important output&quot;) #&gt; Important output ----------------------------------------------------------- "],["function-return.html", "11.4 返回值", " 11.4 返回值 11.4.1 显式返回 函数返回的通常是最后一句代码的计算结果,可以显式利用return()提前返回。但是R for Data Science 中作者说: ‘我认为最好不要使用return()来表示,您可以使用更简单的解决方案尽早返回’ A common reason to do this is because the inputs are empty: complicated_function &lt;- function(x, y, z) { if (length(x) == 0 || length(y) == 0) { return(0) } # Complicated code here } Another reason is because you have a if statement with one complex block and one simple block. For example, you might write an if statement like this: f &lt;- function() { if (x) { # Do # something # that # takes # many # lines # to # express } else { # return something short } } 11.4.2 编写管道函数 管道函数有两种基本类型: transformations and side-effects。使用transformations时，会将对象传递到函数的第一个参数，然后返回修改后的对象。使用side-effects时,不会对传递的对象进行转换。相反，该函数对对象执行操作，例如绘制图或保存文件。副作用函数应该“无形地”返回第一个参数，以便在不打印它们时仍可以在管道中使用它们。例如，以下简单函数在数据框中打印缺失值的数量： 以上从 R for Data Science 中翻译得来。 show_missings &lt;- function(df) { n &lt;- sum(is.na(df)) cat(&quot;Missing values: &quot;, n, &quot;\\n&quot;, sep = &quot;&quot;) invisible(df) } 以交互invisible()方式调用它,则意味着输入df不会被打印出来: show_missings(mtcars) #&gt; Missing values: 0 但是结果仍存在，默认情况下只是不打印显示出来: x &lt;- show_missings(mtcars) #&gt; Missing values: 0 class(x) #&gt; [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; dim(x) #&gt; [1] 32 11 在管道中继续使用 mtcars %&gt;% show_missings() %&gt;% mutate(mpg = ifelse(mpg &lt; 20, NA, mpg)) %&gt;% show_missings() #&gt; Missing values: 0 #&gt; Missing values: 18 "],["function-environment.html", "11.5 环境", " 11.5 环境 环境是复杂的,建议阅读原文. The last component of a function is its environment. This is not something you need to understand deeply when you first start writing functions. However, it’s important to know a little bit about environments because they are crucial to how functions work. The environment of a function controls how R finds the value associated with a name. For example, take this function: f &lt;- function(x) { x + y } 在很多其他的编程语言中这样定义函数是错误的，因为没有定义y.在R中,这是有效的代码,因为R使用称为lexical scoping的方式寻找关联值.在函数内部没有定义y,将在上一层环境中查看y: y &lt;- 100 f(10) #&gt; [1] 110 y &lt;- 1000 f(10) #&gt; [1] 1010 具体详细的资料请查阅： https://r4ds.had.co.nz/functions.html#environment http://adv-r.had.co.nz/ "],["function-expand.html", "11.6 拓展部分", " 11.6 拓展部分 在我之前工作中遇到需要分组计算时,我想要编写一个函数实现某些功能,但是分组的group_by()字段不一样时,导致代码没办法复用。 参考资料：https://dplyr.tidyverse.org/articles/programming.html #library(tidyverse) mean_mpg = function(data, group_col) { data %&gt;% group_by(group_col) %&gt;% summarize(mean_mpg = mean(mpg)) } mtcars %&gt;% mean_mpg(cyl) mtcars %&gt;% mean_mpg(gear) 当编写如下函数时,代码将成功运行 #自定义函数 my_summarise3 &lt;- function(data, group_var,mean_var, sd_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } res1 &lt;- my_summarise3(data = mtcars,group_var = cyl,mean_var = carb,sd_var = gear) my_summarise3(data = mtcars,group_var = am,mean_var = carb,sd_var = gear) #&gt; # A tibble: 2 x 3 #&gt; am mean sd #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 2.74 3.21 #&gt; 2 1 2.92 4.38 #正常写法 res2 &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarise(mean=mean(carb),sd=mean(gear)) identical(res1,res2) #&gt; [1] TRUE #res1 和res2 结果完全一致 以上my_summarise3()函数可以按照需求任意指定聚合汇总字段。 "],["file-system-operation.html", "12 R语言文件系统操作", " 12 R语言文件系统操作 即使是数据处理、分析也涉及到文件系统操作。比如一些表单中包含公司全部合作伙伴的数据，现在需要按照合作伙伴名称切割数据并将数据以附件的形式通过邮件发送？我们就需要将数据按照合作伙伴切割并分开保存打包，最后以邮件发送。那这个过程中就涉及到文件、目录等文件系统操作。 在使用Rstudio-server、部署shiny-server时，文件系统操作将会变得尤其重要。我们掌握好R里面的文件系统操作，就不用使用bash命令操作文件系统，让我们自己更加方便。 本章节主要讲R语言里的文件操作。分为： base R fs package介绍 base and fs and shell 对比 "],["file-base-r.html", "12.1 base R", " 12.1 base R base R 中提供了一组函数与计算机系统文件交互，从文件创建、复制、删除等常规文件操作。 12.1.1 用法 本小节主要将base R中常用的文件函数举例说明用法。 常用函数 # 查看路径下的文件列表 list.files() #&gt; [1] &quot;_book&quot; &quot;_bookdown.yml&quot; #&gt; [3] &quot;_common.R&quot; &quot;_output.yml&quot; #&gt; [5] &quot;01-datatable.Rmd&quot; &quot;02-database.Rmd&quot; #&gt; [7] &quot;03-strings.Rmd&quot; &quot;04-lubridate.Rmd&quot; #&gt; [9] &quot;05-forcats.Rmd&quot; &quot;06-tidy-data.Rmd&quot; #&gt; [11] &quot;07-Data-manipulation.Rmd&quot; &quot;08-loop.Rmd&quot; #&gt; [13] &quot;09-iteration.Rmd&quot; &quot;10-function.Rmd&quot; #&gt; [15] &quot;book.bib&quot; &quot;data&quot; #&gt; [17] &quot;Data-Handling-in-R.log&quot; &quot;Data-Handling-in-R.Rmd&quot; #&gt; [19] &quot;desktop.ini&quot; &quot;file-manipulation.Rmd&quot; #&gt; [21] &quot;index.Rmd&quot; &quot;packages.bib&quot; #&gt; [23] &quot;picture&quot; &quot;preamble.tex&quot; #&gt; [25] &quot;Rbook.Rmd&quot; &quot;Rbook.Rproj&quot; #&gt; [27] &quot;read-write-data.Rmd&quot; &quot;README.md&quot; #&gt; [29] &quot;rsconnect&quot; &quot;style.css&quot; # 创建文件夹 dir.create(&#39;test folder&#39;) # 是否存在 dir.exists(&#39;test folder&#39;) #&gt; [1] TRUE # 删除文件夹 unlink(&#39;test folder&#39;,recursive = TRUE,force=TRUE) # 注意recursive参数为TRUE，文件夹才能被删除 函数介绍 file.create(..., showWarnings = TRUE) file.exists(...) file.remove(...) file.rename(from, to) file.append(file1, file2) file.copy(from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE, copy.date = FALSE) file.symlink(from, to) file.link(from, to) 其中需要注意的参数即recursive，是否递归?像macos或linux上的cp -R命令。 getwd() #&gt; [1] &quot;C:/Users/zhongyf/Desktop/Rbook&quot; file.create():用指定的名称创建文件。创建成功则返回TRUE,失败将返回警告。 file.create(&#39;test.txt&#39;) #&gt; [1] TRUE file.create(&#39;test.csv&#39;) #&gt; [1] TRUE file.exists():返回文件是否存在的逻辑向量，如果存在则返回TRUE file.exists(c(&#39;test.txt&#39;,&#39;test.csv&#39;)) #&gt; [1] TRUE TRUE file.remove():删除指定名称文件。 file.remove(&#39;test.txt&#39;) #&gt; [1] TRUE file.rename():尝试重命名文件。 file.rename(from = &#39;test.csv&#39;,to = &#39;newtest.csv&#39;) #&gt; [1] TRUE file.append():尝试将第二个文件追加到第一个文件 cat(&quot;文件ta的内容\\n&quot;, file = &quot;ta.txt&quot;) cat(&quot;文件tb的内容\\n&quot;, file = &quot;tb.txt&quot;) file.append(&quot;ta.txt&quot;, &quot;tb.txt&quot;) #&gt; [1] TRUE cat(readLines(&#39;ta.txt&#39;)) #&gt; 文件ta的内容 文件tb的内容 file.copy():复制文件 dir.create(&#39;test&#39;) file.copy(from = &#39;ta.txt&#39;,to = &#39;./test&#39;,overwrite = T,recursive = TRUE) #&gt; [1] TRUE file.symlink():建立符号链接15，在winOS系统上即快捷方式，MacOS上即替身，linux上即软连接类似ln -s。 file.symlink(from = &#39;ta.txt&#39;,to = &#39;newab.txt&#39;) #&gt; Warning in file.symlink(from = &quot;ta.txt&quot;, to = &quot;newab.txt&quot;): 无法打 #&gt; 开&#39;ta.txt&#39;到&#39;newab.txt&#39;的链结，原因是&#39;客户端没有所需的特权。&#39; #&gt; [1] FALSE file.link():建立硬链接 详情可以参考文章 对数据分析而言，没有特别重要(可能在shiny部署时能用到)，请自行了解软链接硬链接。↩︎ "],["fs-package.html", "12.2 fs package", " 12.2 fs package fsgithub项目地址，fs为文件系统操作提供了一个跨平台的统计接口。本节基本从fs项目照搬demo。 12.2.1 安装 使用以下命令从CRAN安装 install.packages(&quot;fs&quot;) 安装来自GitHub的开发版本，其中包括： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;r-lib/fs&quot;) 12.2.2 优势 相比base R相同功能，fs包的优势： 向量化。所有fs的函数都是矢量化的，可以批量操作。 编码一致性。fs将输入的路径统一转化为UTF-8。 函数名一致性。fs函数使用一致的命名约定。 函数使用返回“tidy”paths,整洁的路径，和tidyverse一脉相承的概念。 12.2.3 基础用法 fs函数主要有四大类： path_系列用于路径构造 file_系列用于文件 dir_系列用木目录 link_系列用于链接 目录和链接是文件的特殊类型，因为file_在用于目录和链接时，功能通常可以使用。 library(fs) # `path()`函数构造路径 path(&#39;事业部&#39;,c(&#39;华东&#39;,&#39;华西&#39;,&#39;华南&#39;,&#39;华北&#39;),&#39;周补货数据&#39;) #&gt; 事业部/华东/周补货数据 事业部/华西/周补货数据 事业部/华南/周补货数据 事业部/华北/周补货数据 # 当前目录文件列表 dir_ls() #&gt; 01-datatable.Rmd 02-database.Rmd 03-strings.Rmd #&gt; 04-lubridate.Rmd 05-forcats.Rmd 06-tidy-data.Rmd #&gt; 07-Data-manipulation.Rmd 08-loop.Rmd 09-iteration.Rmd #&gt; 10-function.Rmd book.bib data #&gt; Data-Handling-in-R.log Data-Handling-in-R.Rmd desktop.ini #&gt; file-manipulation.Rmd index.Rmd packages.bib #&gt; picture preamble.tex Rbook.Rmd #&gt; Rbook.Rproj read-write-data.Rmd README.md #&gt; rsconnect style.css _book #&gt; _bookdown.yml _common.R _output.yml # 以Rmd结尾的文件 dir_ls(regexp = &#39;Rmd$&#39;) #&gt; 01-datatable.Rmd 02-database.Rmd 03-strings.Rmd #&gt; 04-lubridate.Rmd 05-forcats.Rmd 06-tidy-data.Rmd #&gt; 07-Data-manipulation.Rmd 08-loop.Rmd 09-iteration.Rmd #&gt; 10-function.Rmd Data-Handling-in-R.Rmd file-manipulation.Rmd #&gt; index.Rmd Rbook.Rmd read-write-data.Rmd # 创建一个文件夹 tmp &lt;- dir_create(file_temp()) tmp #&gt; C:/Users/zhongyf/AppData/Local/Temp/RtmpOuNuiH/fileb5c6c2150c8 # 在文件夹中创建文件 file_create(path(tmp, &quot;my-file.txt&quot;)) dir_ls(tmp) #&gt; C:/Users/zhongyf/AppData/Local/Temp/RtmpOuNuiH/fileb5c6c2150c8/my-file.txt # 从文件夹中删除文件 file_delete(path(tmp, &quot;my-file.txt&quot;)) dir_ls(tmp) #&gt; character(0) # 删除文件 dir_delete(tmp) "],["fs-functions.html", "12.3 fs函数介绍", " 12.3 fs函数介绍 从文件、目录、链接、路径等方面介绍fs中常用的函数。 12.3.1 文件操作 文件操作 函数作用 file_copy() dir_copy() link_copy() 复制文件、目录、链接 file_create() dir_create() link_create() 创建文件、目录、链接 file_delete() dir_delete() link_delete() 删除文件、目录、链接 file_access() file_exists() dir_exists() link_exists() 文件是否存在和权限查询 file_chmod() 更改文件权限 file_chown() 更改文件的所有者和组 file_info() file_size() 文件信息 file_move() 移动和重命名文件 file_show() 打开文件或目录 file_temp() file_temp_push() file_temp_pop() path_temp() 临时文件或路径 file_touch() 与linux不同，不创建文件，仅更改文件访问和修改时间 12.3.2 目录操作 目录操作 函数作用 file_copy() dir_copy() link_copy() 复制文件、目录、链接 file_create() dir_create() link_create() 创建文件、目录、链接 file_delete() dir_delete() link_delete() 删除文件、目录、链接 dir_ls() dir_map() dir_walk() dir_info() 查看文件列表、信息 dir_tree() 以树状结构打印文件 file_access() file_exists() dir_exists() link_exists() 文件是否存在和权限查询 12.3.3 链接操作 链接操作 函数作用 file_copy() dir_copy() link_copy() 复制文件、目录、链接 file_create() dir_create() link_create() 创建文件、目录、链接 file_delete() dir_delete() link_delete() 删除文件、目录、链接 file_access() file_exists() dir_exists() link_exists() 文件是否存在和权限查询 link_path() 读取链接文件路径 12.3.4 路径操作 路径操作 函数作用 path() path_wd() 构造文件、目录路径；获取当前路径 file_temp() file_temp_push() file_temp_pop() path_temp() 创建临时文件 path_expand() path_expand_r() path_home() path_home_r() 查找用户主目录 path_file() path_dir() path_ext() path_ext_remove() path_ext_set() path_ext&lt;-() 处理文件路径 path_filter() 筛选路径 path_real() path_split() path_join() path_abs() path_norm() path_rel() path_common() path_has_parent() 处理路径 path_package() 包的路径 path_sanitize() 通过删除目录路径和无效字符清理文件名 path_tidy() 整洁路径 12.3.5 辅助函数 帮助函数 函数作用 is_file() is_dir() is_link() is_file_empty() 测试文件类型 as_fs_path() fs_path() 文件路径 as_fs_bytes() fs_bytes() 可读文件的大小 as_fs_perms() fs_perms() 创建、修改、查看文件权限 "],["file-base-fs-difference.html", "12.4 base-fs-shell比较", " 12.4 base-fs-shell比较 对比base，fs,shell相同功能函数，加深记忆。直接阅读官网介绍 使用Rvest包将官网介绍的信息“爬”下来。由于是外网，想要快速正确爬虫确保网络通畅。 爬取代码如下: library(rvest) library(tidyverse,warn.conflicts = FALSE) # 目录功能对比 directory_functions_dt &lt;- read_html(&#39;https://fs.r-lib.org/articles/function-comparisons.html&#39;) %&gt;% html_nodes(&#39;#directory-functions&#39;) %&gt;% rvest::html_table() %&gt;% `[[`(1) # 文件功能对比 file_functions_dt &lt;- read_html(&#39;https://fs.r-lib.org/articles/function-comparisons.html&#39;) %&gt;% html_nodes(&#39;#file-functions&#39;) %&gt;% rvest::html_table() %&gt;% `[[`(1) # 路径功能对比 path_functions_dt &lt;- read_html(&#39;https://fs.r-lib.org/articles/function-comparisons.html&#39;) %&gt;% html_nodes(&#39;#path-functions&#39;) %&gt;% rvest::html_table() %&gt;% `[[`(1) fs-base-shell "],["file-manipulation-reference-material.html", "12.5 参考资料", " 12.5 参考资料 软硬链接:https://www.jianshu.com/p/dde6a01c4094 R file manipulation:https://stat.ethz.ch/R-manual/R-devel/library/base/html/files.html fs package:https://fs.r-lib.org/ "]]
