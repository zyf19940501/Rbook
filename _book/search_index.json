[["index.html", "R语言学习笔记 欢迎", " R语言学习笔记 Yufei Zhong 2021-05-21 欢迎 本文主要是我作为商业数据分析师的R语言学习笔记，主要是数据清洗相关包的介绍。 使用R语言自动完成如下报表: .tabwid table{ border-collapse:collapse; line-height:1; margin-left:auto; margin-right:auto; border-width: 0; display: table; margin-top: 1.275em; margin-bottom: 1.275em; border-spacing: 0; border-color: transparent; } .tabwid_left table{ margin-left:0; } .tabwid_right table{ margin-right:0; } .tabwid td { padding: 0; } .tabwid a { text-decoration: none; } .tabwid thead { background-color: transparent; } .tabwid tfoot { background-color: transparent; } .tabwid table tr { background-color: transparent; } .cl-846df20e{border-collapse:collapse;}.cl-8465174c{font-family:'Arial';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(255, 255, 255, 1.00);background-color:transparent;}.cl-8465174d{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-8465174e{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:italic;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-84653fe2{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-84653fe3{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-84653fe4{margin:0;text-align:center;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-84658e16{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e17{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e18{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e19{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1a{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1b{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1c{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1d{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1e{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e1f{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84658e20{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b508{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b509{width:60.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50a{width:63.3pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50b{width:57.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50c{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50d{width:61.8pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50e{width:53.5pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b50f{width:81.7pt;background-color:transparent;vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b510{width:81.7pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b511{width:53.5pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465b512{width:57.8pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465dc0e{width:63.3pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465dc0f{width:60.3pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465dc10{width:53.5pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8465dc11{width:61.8pt;background-clip: padding-box;background-color:rgba(224, 82, 151, 1.00);vertical-align: middle;border-bottom: 1pt solid rgba(102, 102, 102, 1.00);border-top: 1pt solid rgba(102, 102, 102, 1.00);border-left: 1pt solid rgba(102, 102, 102, 1.00);border-right: 1pt solid rgba(102, 102, 102, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;} 一级部门分析大类当前销额当前%同比销额同比%金额增长%当前销量同比销量销量同比%当前折扣同比折扣事业部衬衣55,148,05635.4%51,999,20928.1%6.1%282,426358,658-21.3%81.0%60.1%箱包72,439,03846.5%92,585,62650.0%-21.8%124,584163,813-23.9%92.4%93.0%篮球鞋21,872,49514.0%33,590,83518.2%-34.9%44,26070,666-37.4%87.3%89.0%太阳镜1,526,9081.0%952,9340.5%60.2%6,6093,94467.6%94.0%97.0%周边商品1,691,8101.1%372,0500.2%354.7%11,7772,249423.7%87.0%87.0%袜子692,5910.4%587,5550.3%17.9%243,679271,089-10.1%94.7%22.2%其它2,312,9501.5%4,946,5102.7%-53.2%5,58110,128-44.9%94.0%93.1%事业部汇总155,683,848100.0%185,034,718100.0%-15.9%718,916880,547-18.4%87.3%79.3%数据更新时间:2021-05-21 "],["abstract.html", "内容概要", " 内容概要 主要内容是为了将数据报表，数据报告，数据可视化等需求利用R语言自动化。 数据导入导出 数据操作 dplyr 数据整洁 tidyr 字符处理 日期时间处理 因子处理 数据处理利器 data.table 数据库使用 循环结构 循环迭代之purrr包介绍 自定义函数功能 "],["sec-licenses.html", "授权说明", " 授权说明 本书采用 知识共享署名-非商业性使用-禁止演绎4.0国际许可协议 许可，请君自重。 项目中代码使用 MIT协议 开源。 "],["session.html", "运行信息", " 运行信息 xfun::session_info(packages = c( &quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;bookdown&quot;,&quot;collapse&quot;, &quot;data.table&quot;, &quot;DT&quot;, &quot;reactable&quot;,&quot;flextable&quot;, &quot;patchwork&quot;, &quot;plotly&quot;, &quot;shiny&quot;,&quot;formattable&quot;, &quot;ggplot2&quot;, &quot;dplyr&quot;, &quot;tidyverse&quot;,&quot;DBI&quot;,&quot;ROracle&quot;,&quot;dbplyr&quot; ), dependencies = FALSE) #&gt; R version 4.1.0 (2021-05-18) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 19041) #&gt; #&gt; Locale: #&gt; LC_COLLATE=Chinese (Simplified)_China.936 #&gt; LC_CTYPE=Chinese (Simplified)_China.936 #&gt; LC_MONETARY=Chinese (Simplified)_China.936 #&gt; LC_NUMERIC=C #&gt; LC_TIME=Chinese (Simplified)_China.936 #&gt; #&gt; Package version: #&gt; bookdown_0.22 collapse_1.5.3 data.table_1.14.0 DBI_1.1.1 #&gt; dbplyr_2.1.1 dplyr_1.0.6 DT_0.18 flextable_0.6.6 #&gt; formattable_0.2.1 ggplot2_3.3.3 knitr_1.33 patchwork_1.1.1 #&gt; plotly_4.9.3 reactable_0.2.3 rmarkdown_2.8 ROracle_1.3.1 #&gt; shiny_1.6.0 tidyverse_1.3.1 #&gt; #&gt; Pandoc version: 2.11.4 "],["author.html", "关于本人", " 关于本人 一名热爱R语言的商业数据分析师。R极大拓展了我数据处理能力,让我很轻松方便处理数据，有更多精力时间聚焦在具体问题上。 因个人能力有限，本书难免出现错误，如发现错误，欢迎联系本人更正。 Email: 598253220@qq.com 微信公众号: 宇飞的世界 语雀: https://www.yuque.com/zyufei "],["data-read-write-description.html", "1 数据导入导出", " 1 数据导入导出 作为一名普通的数据分析师，我日常接触最多的数据是业务系统中的销售订单表、商品库存表、会员信息表，门店信息表，商品信息表等之类的业务表，但最初接触R时，看到的演示代码以及数据集大部分都是R包中内置的数据集，没有很明确操作数据的意义，没有代入感。在刚开始学习使用R做数据处理后，我就想使用自己的数据集来操作数据，用R去实现Excel的透视表或sql功能。这时就首先需要将原始数据导入1R中。 现实生活中数据来源复杂，商业环境中数据源同样具有多样性，如SAP,不同的数据库、OA系统、EXCEL手工文件等;我们想要统一数据做分析，就需要将不同的数据源整合导入R中。 我们从读取方式简单区分为本地文件数据、数据库数据，本章主要说明常用的Excel文件和csv2、txt等文本文件的读写方式。关于数据库的数据的读取，可以参照后续database章节。 相信大家随便使用搜索引擎搜索诸如“将Excel导入R”的关键词都能得到一些行之有效的方法，但是不够系统全面。本章主要简述R中数据导入导出的相关R包，如readxl,writexl,openxlsx,readr, vroom等主要处理csv或Excel的R包。 当有其它数据格式需求的时候，那时候的你肯定已经会自行查找相关R包使用了。 在本章开始前，假定已经有一些R相关基础。如使用Rstudio查看导入的数据，R的数据结构等有一定认识。本章节主要分为: excel读写 csv等平面文件读写 文件路径 由于R是将数据加载至内存中，故数据集大小超过内存大小将导入失败。↩︎ csv即Comma-Separated Values，逗号分隔值，分隔符也可是不是逗号。 csv文件是一种以纯文本形式存储的表格数据,可以通过记事本打开。与Excel不同的是，CSV是一种文本格式，也不受Excel最大行数(1048576)限制。 csv文件也被称作平面文件，结构简单，平面文件比结构文件占用更少的空间；平面文件在数据仓库项目中广泛用于导入数据。↩︎ "],["readxl-description.html", "1.1 readxl", " 1.1 readxl readxl软件包使R获取Excel数据变得方便简洁。与现有的软件包(例如：xlsx)相比，readxl没有外部依赖性，xlsx等包依赖java环境。readxl包容易在所有的操作系统安装使用。 readxl项目地址，本节大部分代码来源项目官网介绍，可自行查阅官网。 1.1.1 安装 从CRAN安装最新发行版本的最简单方法是安装整个tidyverse。 install.packages(&quot;tidyverse&quot;) 由于readxl不是tidyverse核心加载包，使用时仅需加载library(readxl) 或者是从CRAN仅安装readxl; install.packages(&quot;readxl&quot;) 从github安装开发版： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readxl&quot;) 1.1.2 用法 1.读取 readxl包中包含了几个示例文件，我们在接下来的案例中使用。 查看readxl包中自带xlsx文件 library(readxl) readxl_example() readxl_example(&quot;clippy.xls&quot;) read_excel()可读取xls和xlsx文件。 xlsx_example &lt;- readxl_example(&quot;datasets.xlsx&quot;) dt &lt;- read_excel(xlsx_example) # 查看数据 head(dt) # 查看数据类型 str(dt) 通过函数excel_sheets()查看Excel的sheet名称 excel_sheets(xlsx_example) 指定worksheet的名字读取，可以是sheet的名字或序号。 当我们要读取的本地xlsx文件有多个sheets时，通过指定sheet参数读取指定的sheet。 read_excel(xlsx_example, sheet = &quot;chickwts&quot;) # not run #read_excel(xlsx_example, sheet = 1) #read_excel(xlsx_example, sheet = 3) 读取xlsx文件的指定范围，有多种方法控制。 本处提供几个案例，详情请?read_excel()查看帮助。 readxl::read_excel参数如下： read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot;) range接受单元格范围，最简单的表示方式即Excle中单元格表示方法,如as range = “D12:F15” or range = “R1C12:R6C15”。 其余参数中，个人觉得col_types比较重要，可以指定列的类型。可用选项:“skip,” “guess,” “logical,” “numeric,” “date,” “text” or “list”。 .name_repair 参数能自动避免重复字段，可避免手工Excle出现的字段名不唯一的情况。 1.1.3 批量读取 某文件夹下有大量相同的Excel文件(sheet名称以及列字段相同)，要合并全部Excel数据,代码如下： allfiles &lt;- list.files(path = &#39;./data/&#39;,pattern = &#39;.xlsx$&#39;,full.names = T) purrr::map_dfr(allfiles,read_excel) 1.1.4 批量输出 我们按照一定条件拆解数据集，分别输出，代码如下： library(tidyverse) dt &lt;- read_xlsx(path = &#39;./data/read-write/批量读写.xlsx&#39;) dt %&gt;% group_by(name) %&gt;% group_walk(~ write.csv(.x,file = file.path(&#39;data/read-write&#39;,paste0(.y$name,&#39;.csv&#39;)))) list.files(path = &#39;data/read-write/&#39;) 暂时不用理解批量读取和输出的代码具体含义，可以先记住用法。 "],["writexl.html", "1.2 writexl", " 1.2 writexl 截止到2021年5月17日，writexl包功能比较简单，仅有输出Excel功能。快速、不依赖java和Excle是它绝对的优势，并且输出文件相比openxlsx包较小。 项目地址 1.2.1 用法 安装 install.packages(&quot;writexl&quot;) 参数 write_xlsx( x, path = tempfile(fileext = &quot;.xlsx&quot;), col_names = TRUE, format_headers = TRUE, use_zip64 = FALSE ) 输出Excel library(writexl) writexl::write_xlsx(iris,path = &#39;iris.xlsx&#39;) write_xlsx(list(mysheet1 = iris,mysheet2 = iris),path = &#39;iris.xlsx&#39;) 效率比较 library(microbenchmark) library(nycflights13) microbenchmark( writexl = writexl::write_xlsx(flights, tempfile()), openxlsx = openxlsx::write.xlsx(flights, tempfile()), times = 2 ) 文件大小比较 writexl::write_xlsx(flights, tmp1 &lt;- tempfile()) file.info(tmp1)$size openxlsx::write.xlsx(flights, tmp2 &lt;- tempfile()) file.info(tmp2)$size 其它功能 df &lt;- data.frame( name = c(&quot;UCLA&quot;, &quot;Berkeley&quot;, &quot;Jeroen&quot;), founded = c(1919, 1868, 2030), website = xl_hyperlink(c(&quot;http://www.ucla.edu&quot;, &quot;http://www.berkeley.edu&quot;, NA), &quot;homepage&quot;) ) df$age &lt;- xl_formula(&#39;=(YEAR(TODAY()) - INDIRECT(&quot;B&quot; &amp; ROW()))&#39;) write_xlsx(df, &#39;universities.xlsx&#39;) # cleanup unlink(&#39;universities.xlsx&#39;) "],["openxlsx-description.html", "1.3 openxlsx", " 1.3 openxlsx openxlsx是当我需要定制输出Excel表格或报表时常用R包。目前该包的版本4.2.3，通过使用Rcpp加速，包的读写速度在Excel的百万级下是可接受状态，包的相关函数功能完善且简易好用，并且正在积极开发中，相信它以后功能会越来越强大。 项目官方地址:https://ycphs.github.io/openxlsx/index.html 个人感觉主要优势： 不依赖java环境 读写速度可接受 可设置条件格式，与Excel中『开始』选项卡的条件格式功能接近 可批量插入ggplot2图 可插入公式 可渲染大部分Excel格式，并且效率相比部分python包高效 可添加页眉页脚以及其他格式，方便直接打印 功能稳定可用并且在积极开发中 版本信息查看 packageVersion(&quot;openxlsx&quot;) 本人公众号:宇飞的世界中有更加详细的阐述:https://mp.weixin.qq.com/s/ZD0dJb0y8fsWGI1dCPh2mQ 1.3.1 安装 稳定版 # 稳定版 install.packages(&quot;openxlsx&quot;, dependencies = TRUE, repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;) 开发版 install.packages(c(&quot;Rcpp&quot;, &quot;devtools&quot;), dependencies = TRUE) library(devtools) install_github(&quot;ycphs/openxlsx&quot;) 1.3.2 基础功能 本文仅呈现基础功能部分，即读写EXCEL文件。其它功能，请查阅项目官方地址或微信公众号文章R包-openxlsx-学习笔记 1.3.2.1 读取Excel read.xlsx()是读取函数，主要参数如下： library(openxlsx) read.xlsx( xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = &quot;.&quot;, namedRegion = NULL, na.strings = &quot;NA&quot;, fillMergedCells = FALSE ) 以上参数中需要注意 ： detecDates参数，当你的Excel表格中带日期列时需要将参数设置为TRUE,不然将会把日期识别为数字读入。 fillMergedCells参数，当你读取的表格中存在合并单元格，将用值填充其他全部单元格,如下所示： read.xlsx(&#39;./test.xlsx&#39;,detectDates = TRUE,fillMergedCells = TRUE) 读取后如下所示： openxlsx-merge-xlsx readWorkbook()也可以读取Excel表格数据，参数与read.xlsx基本一致。 xlsxFile &lt;- system.file(&quot;extdata&quot;, &quot;readTest.xlsx&quot;, package = &quot;openxlsx&quot;) df1 &lt;- readWorkbook(xlsxFile = xlsxFile, sheet = 1) 1.3.2.2 写入Excel 数据清洗完之后，或者是透视表已经完成，需要将结果从R导出到Excle，这时就利用函数将结果数据集data.frame写入Excle中。 write.xlsx()函数写入 write.xlsx(iris, file = &quot;writeXLSX1.xlsx&quot;, colNames = TRUE, borders = &quot;columns&quot;) 带格式输出 hs &lt;- createStyle( textDecoration = &quot;BOLD&quot;, fontColour = &quot;#FFFFFF&quot;, fontSize = 12, fontName = &quot;Arial Narrow&quot;, fgFill = &quot;#4F80BD&quot; ) ## Not run: write.xlsx(iris, file = &quot;writeXLSX3.xlsx&quot;, colNames = TRUE, borders = &quot;rows&quot;, headerStyle = hs ) 1.3.3 带格式输出 输出过程共四步，第一步创建workbook,第二步添加sheet,第三步写入数据，第四步保存workbook。在输出的过程中可以通过addStyle()、createStyle()或conditionalFormatting添加格式或条件格式。 df &lt;- data.frame(a=1:10,b=1:10,d=1:10) wb &lt;- createWorkbook(creator = &#39;zhongyf&#39;,title = &#39;test&#39;) addWorksheet(wb,sheetName = &#39;test&#39;) writeData(wb,sheet = &#39;test&#39;,x = df) saveWorkbook(wb, &quot;test.xlsx&quot;, overwrite = TRUE) 我们以上面四步输出的方式，查看包自带的例子。 createWorkbook() addWorksheet() writeData() saveWorkbook() wb &lt;- createWorkbook(&quot;Fred&quot;) ## Add 3 worksheets addWorksheet(wb, &quot;Sheet 1&quot;) addWorksheet(wb, &quot;Sheet 2&quot;, gridLines = FALSE) addWorksheet(wb, &quot;Sheet 3&quot;, tabColour = &quot;red&quot;) addWorksheet(wb, &quot;Sheet 4&quot;, gridLines = FALSE, tabColour = &quot;#4F81BD&quot;) ## Headers and Footers addWorksheet(wb, &quot;Sheet 5&quot;, header = c(&quot;ODD HEAD LEFT&quot;, &quot;ODD HEAD CENTER&quot;, &quot;ODD HEAD RIGHT&quot;), footer = c(&quot;ODD FOOT RIGHT&quot;, &quot;ODD FOOT CENTER&quot;, &quot;ODD FOOT RIGHT&quot;), evenHeader = c(&quot;EVEN HEAD LEFT&quot;, &quot;EVEN HEAD CENTER&quot;, &quot;EVEN HEAD RIGHT&quot;), evenFooter = c(&quot;EVEN FOOT RIGHT&quot;, &quot;EVEN FOOT CENTER&quot;, &quot;EVEN FOOT RIGHT&quot;), firstHeader = c(&quot;TOP&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;), firstFooter = c(&quot;BOTTOM&quot;, &quot;OF FIRST&quot;, &quot;PAGE&quot;) ) addWorksheet(wb, &quot;Sheet 6&quot;, header = c(&quot;&amp;[Date]&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;&amp;[Page] / &amp;[Pages]&quot;), footer = c(&quot;&amp;[Path]&amp;[File]&quot;, NA, &quot;&amp;[Tab]&quot;), firstHeader = c(NA, &quot;Center Header of First Page&quot;, NA), firstFooter = c(NA, &quot;Center Footer of First Page&quot;, NA) ) addWorksheet(wb, &quot;Sheet 7&quot;, header = c(&quot;ALL HEAD LEFT 2&quot;, &quot;ALL HEAD CENTER 2&quot;, &quot;ALL HEAD RIGHT 2&quot;), footer = c(&quot;ALL FOOT RIGHT 2&quot;, &quot;ALL FOOT CENTER 2&quot;, &quot;ALL FOOT RIGHT 2&quot;) ) addWorksheet(wb, &quot;Sheet 8&quot;, firstHeader = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;), firstFooter = c(&quot;FIRST ONLY L&quot;, NA, &quot;FIRST ONLY R&quot;) ) ## Need data on worksheet to see all headers and footers writeData(wb, sheet = 5, 1:400) writeData(wb, sheet = 6, 1:400) writeData(wb, sheet = 7, 1:400) writeData(wb, sheet = 8, 1:400) ## Save workbook ## Not run: saveWorkbook(wb, &quot;addWorksheetExample.xlsx&quot;, overwrite = TRUE) 1.3.4 函数参数 输出Excel的过程分为四步，本小节主要拆解createWorkbook，addWorksheet,writeDataTable,saveWorkbook四个函数的参数以及用法。 createWorkbook createWorkbook( creator = ifelse(.Platform$OS.type == &quot;windows&quot;, Sys.getenv(&quot;USERNAME&quot;), Sys.getenv(&quot;USER&quot;)), title = NULL, subject = NULL, category = NULL ) wb &lt;- createWorkbook( creator = &quot;宇飞的世界&quot;, title = &quot;标题&quot;, subject = &quot;主题&quot;, category = &quot;类别目录&quot; ) addWorksheet addWorksheet( wb, sheetName, gridLines = TRUE, tabColour = NULL, zoom = 100, header = NULL, footer = NULL, evenHeader = NULL, evenFooter = NULL, firstHeader = NULL, firstFooter = NULL, visible = TRUE, paperSize = getOption(&quot;openxlsx.paperSize&quot;, default = 9), orientation = getOption(&quot;openxlsx.orientation&quot;, default = &quot;portrait&quot;), vdpi = getOption(&quot;openxlsx.vdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)), hdpi = getOption(&quot;openxlsx.hdpi&quot;, default = getOption(&quot;openxlsx.dpi&quot;, default = 300)) ) gridLines参数：表格中是否有网格线，在Excle『视图』选项卡下面的网格线去除打勾的效果一致 tabColour参数：输出表格sheet标签颜色 zoom：发大缩小，默认是100，可选范围10-400 header:页眉 长度为3的字符向量，左、中、右三个位置，用Na可跳过一位置，以下页眉页脚相同。 footer: 页脚 evenHeader: 每页页眉 evenFooter: 每页页脚 firstHeader: 第一页页眉 firstFooter: 第一页页脚 visible:sheet是否隐藏，如果为否sheet将被隐藏 paperSize:页面大小,详见 ?pageSetup orientation:One of &quot;portrait&quot; or &quot;landscape&quot; 不清楚干嘛用 vdpi: 屏幕分辨率 默认值即可，不用调整 hdpi: 屏幕分辨率 默认值即可，不用调整 writeDataTable writeDataTable()函数将data.frame写入Excel。 wb:即createWorkbook()函数创建 saveWorkbook saveWorkbook(wb, file, overwrite = FALSE, returnValue = FALSE) 参数较为简单，wb即上文中的workbook对象，file即输出的文件名，overwrite即如果存在是否覆盖，returnValue如果设置为TRUE，返回TRUE代表保存成功 1.3.5 总结 openxlsx包功能较为强大，更多详细用法大家可自行探索，或关注我的语雀笔记，笔记会不定期持续更新。 R包openxlsx学习笔记:https://www.yuque.com/docs/share/7a768e6f-95e0-417c-a9b5-dfc8862dc6be?# 个人主页:https://www.yuque.com/zyufei "],["readr-package.html", "1.4 readr", " 1.4 readr readr提供了一种快速友好的方式读取矩形数据3(如：csv,tsv,fwf)，且当读取大型数据集时默认有进度条显示。 如果对readr包不熟悉，可以直接阅读包作者大神Hadley Wickham的书R for data science 中data import chapter章节。 1.4.1 安装 直接安装tidyverse获取或单独安装readr。 # The easiest way to get readr is to install the whole tidyverse: install.packages(&quot;tidyverse&quot;) # Alternatively, install just readr: install.packages(&quot;readr&quot;) # Or the the development version from GitHub: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/readr&quot;) 1.4.2 用法 readr包是tidyverse系列的核心包，可以加载tidyverse使用。 library(tidyverse) 1.4.2.1 主要函数 readr支持七种read_功能的文件格式。 — read_csv():逗号分隔符文件 - read_tsv():制表符分割文件 - read_delim():规定分隔符文件 - read_fwf():固定宽度文件 - read_table():表格文件，列间用空格隔开 - read_log():Web日志文件 在大多数情况下，我们常使用read_csv()，提供文件路径，将得到数据表。示例如下: mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;)) 通过上述输出反馈，我们可以知道读进去的数据集每列类型。如果发现不对可以通过col_types参数修改。大多数情况下，我们并不需要指定列的类型，readr会自动猜测列类型。 mtcars &lt;- read_csv(readr_example(&quot;mtcars.csv&quot;), col_types = cols( mpg = col_double(), cyl = col_integer(), disp = col_double(), hp = col_integer(), drat = col_double(), vs = col_integer(), wt = col_double(), qsec = col_double(), am = col_integer(), gear = col_integer(), carb = col_integer() ) ) 1.4.2.2 参数 read_csv()的参数如下： read_csv( file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, quote = &quot;\\&quot;&quot;, comment = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), skip_empty_rows = TRUE ) col_types :指定列类型，可用项如下所示(含简写): c = character，i = integer，n = number，d = double，l = logical，f = factor，D = date，T = date time，t = time，默认值为guess. locale:locale参数是readr中很重要的一个参数，指定日期使用的月和日的名称，时区，字符编码，日期格式，数字的小数和点位数和分隔符。 locale()的第一个参数是date_names，控制月份和日期的名称，指定最简单的方式ISO 639 language code locale(&#39;zh&#39;) # 中文 locale(&#39;ja&#39;) #日本 locale(&#39;ko&#39;) #韩国 编码和时区问题是我们常面临的问题。 read_csv(readr_example(&quot;mtcars.csv&quot;),locale = locale(encoding = &#39;UTF-8&#39;,tz = &#39;Asia/Shanghai&#39;)) 详细信息查看手册vignette(\"locales\")。 1.4.3 导出功能 由于系统不同的缘故，在win系统下可能面临编码问题。我用readr导出数据时一般采用write_excel_csv()功能导出。 需要说明的是write_系列函数可以将输出文件压缩。 data(storms, package = &quot;dplyr&quot;) write_csv(storms, &quot;storms.csv&quot;) write_csv(storms, &quot;storms.csv.gz&quot;) 1.4.4 总结 大部分情况下，当数据整洁时且不涉及时间(日期不影响)时，采用默认参数读取数据即可。 当数据集前面行缺失值较多，readr自动猜数据列类型错误时，需要我们人为指定列类型；当编码时区等错误时，需指定locale()；以上是可能遇到的问题以及解决办法。 矩形数据英文中表示为 rectangular data，矩形数据每一列都是变量(特征)，而每一行都是案例或记录,关系数据库中的单表就是矩形数据的一种。↩︎ "],["data-vroom.html", "1.5 vroom", " 1.5 vroom vroom实现读取矩形数据到R中,如 comma separated(csv),tab separated(tsv), fixed width files(fwf)。该包的功能类似readr::read_csv(),data.table::fread()和read.csv(),但是对于许多数据集来说，vroom::vroom()读取速度会快得多。 vroom项目地址 1.5.1 安装 # 从cran安装 install.packages(&quot;vroom&quot;) # install.packages(&quot;devtools&quot;) devtools::install_dev(&quot;vroom&quot;) 1.5.2 用法 读取文件 library(vroom) file &lt;- vroom_example(&quot;mtcars.csv&quot;) file vroom(file) vroom(file, delim = &quot;,&quot;) 读取多文件 即vroom::vroom()具备迭代效果,具体情况如下： mt &lt;- tibble::rownames_to_column(mtcars, &quot;model&quot;) purrr::iwalk( split(mt, mt$cyl), ~ vroom_write(.x, glue::glue(&quot;mtcars_{.y}.csv&quot;), &quot;\\t&quot;) ) files &lt;- fs::dir_ls(glob = &quot;mtcars*csv&quot;) files # read_csv purrr::map_dfr(files,readr::read_delim,delim=&quot;\\t&quot;) # vroom same above vroom(files) 读取压缩文件 vroom支持zip,gz,bz2,xz等压缩文件，只需要将压缩文件名称传递给vroom即可。 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file) 读取网络文件 file &lt;- &quot;https://raw.githubusercontent.com/r-lib/vroom/master/inst/extdata/mtcars.csv&quot; vroom(file) 选择列读取 room提供了与dplyr::select()相同的列选择和重命名接口 file &lt;- vroom_example(&quot;mtcars.csv.gz&quot;) vroom(file, col_select = c(model, cyl, gear)) # vroom(file, col_select = c(1, 3, 11)) # vroom(file, col_select = list(car = model, everything())) "],["data-rstudio-addins.html", "1.6 Rstudio导入", " 1.6 Rstudio导入 1.6.1 利用rstudio工具栏导入 本质也是调用readr和readxl包，如下所示： rstudio-load-data 1.6.2 插件导入 项目地址 datapasta是一个addins插件，方便将数据复制到R。 1.安装 install.packages(&quot;datapasta&quot;) 2.使用 datapasta "],["data-file-path.html", "1.7 文件路径", " 1.7 文件路径 我们读取数据时都是读取某路径下的某文件，但是由于系统等原因，路径在不同系统下的表示方式不一致。 1.7.1 指定路径 win 路径 winOS系统：C:\\Users\\zhongyf\\Desktop\\Rbook，注意路径中是一个反斜杠()。 win-path 在R中读取时需要用一个正斜杠或两个反斜杠。 readr::read_csv(&#39;C:/Users/zhongyf/Desktop/Rbook/data/flights.csv&#39;) readr::read_csv(&#39;C:\\\\Users\\\\zhongyf\\\\Desktop\\\\Rbook\\\\data\\flights.csv&#39;) # same above readr:::read_csv(file = r&quot;(C:\\Users\\zhongyf\\Desktop\\Rbook\\data\\flights.csv)&quot;) # same above 工作中，当需要读取或写入共享盘4中文件时，路径表示方式为： the_shared_disk &lt;- r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot; # load data into R readr::read_csv(file = &quot;\\\\\\\\192.168.2.117\\\\公司A-新\\\\01事业部\\\\flights.csv&quot;) readr::read_csv(file = r&quot;(\\\\192.168.2.117\\公司A-新\\01事业部\\)&quot;) r“()”用法是R-4.0-之后的特性。在win系统下表示路径特别有用 mac 路径 macOS系统: /User/vega_mac/Desktop/r,路径中是一个正斜杠。 mac-path readr::read_csv(&#39;/User/vega_mac/Desktop/r/Rbook/data/flights.csv&#39;) 1.7.2 默认路径 getwd()是查看当前工作目录的函数，在进行文件读写时的默认路径，也就是当没有明确指定路径时，读取导出的默认路径是getwd()。想要改变工作目录，通过设定setwd()即可。 getwd() # not run setwd(&#39;C:/Users/zhongyf/Desktop/Rbook/data&#39;) getwd() 共享盘的地址即某电脑(服务器)的地址，知道共享盘在局域网中的ip地址后在 开始-&gt;运行中输入\\192.168.1.247即可打开共享盘。↩︎ "],["data-expand.html", "1.8 拓展", " 1.8 拓展 feather项目地址https://github.com/wesm/feather qs提供接口，用于快速将R对象保存到磁盘以及从磁盘读取。该包的目标是替换R中的saveRDS和readRDS。项目地址https://github.com/traversc/qs arrow是feather的接替项目，地址https://arrow.apache.org/docs/r/ 其它统计学软件数据如spss，stata,SAs等可用foreign包读取 "],["Data-Manipulation-dplyr.html", "2 数据处理之-dplyr", " 2 数据处理之-dplyr 本章节主要目的是通过阐述dplyr动词用法，实现与Excel透视表或sql相同功能，从而达到不同的数据整理、聚合需求。 本章主要从以下方面阐述： 行条件筛选 列筛选 字段重命名 列位置排序 行排序 新增计算字段 分组聚合 表关联 行列操作 使用dplyr编写自定义函数 其中9,10行列操作和自定义函数有一定难度，大家可以先熟悉dplyr基本用法后再了解其用法。 与sql相比，用dplyr的优势： 代码量极大减少 逻辑复杂时，dplyr动词可以按照顺序一步步实现，无需嵌套，实现过程简单 代码可读性好 配合dbplyr包使用，大部分情况下可以扔掉sql语法，从而实现不同数据库间语法并不完全一致时，代码可重复使用 本章节中部分案例照搬dplyr包的官方案例， dplyr动词从数据库相关操作中抽象而来，从sql迁移成本低 "],["dplyr-description.html", "2.1 前言", " 2.1 前言 dplyr包是tidyverse系列的核心包之一。dplyr是A Grammar of Data Manipulation ，即dplyr是数据处理的语法。数据操作在数据库中往往被增、改、删、查四字描述，加上表连接查询基本涵盖了大部分的数据操作。 dplyr包通过提供一组动词来解决最常见的数据处理问题： mutate() 添加新变量,现有变量的函数 select() 筛选列,根据现有变量名称选择变量 filter() 筛选行，根据条件筛选 summarise() 按照一定条件汇总聚合 arrange() 行排序 以上动词都可以和group_by()结合，使我们可以按组执行以上任何操作。除了以上单个表操作的动词，dplyr中还有操作两表(表关联)的动词，可以通过vignette(\"two-table\")查看学习。 2.1.1 安装 dplyr包可以直接安装。 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;dplyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/dplyr&quot;) 在开始使用前，请确保自己dplyr版本是较新版本，因为1.0.0版本有较大更新。 packageVersion(&#39;dplyr&#39;) 2.1.2 Excel and Sql 类比 与Excel相比,dplyr使用filter实现筛选，mutate实现列新增计算，summarise配合group_by实现数据透视表，arrange实现排序功能。 dplyr::left_join()等表连接功能，实现Excel中的vlookup,xlookup等函数效果。 请看案例： 案例中使用的数据集是R包nycflights13带的flights数据集。 Excel实现 透视表截图 R实现： library(tidyverse,warn.conflicts = FALSE) data &lt;- readr::read_csv(&quot;./data/flights.csv&quot;) data %&gt;% filter(year==2014,month==6) %&gt;% group_by(origin,dest) %&gt;% summarise(distance求和项 = sum(distance)) Sql实现： select origin,dest,sum(distance) distance求和项 from flights where year = 2014 and month =6 group by origin,dest 2.1.3 常见问题 筛选订单表中的1-5月订单数据，按照城市汇总，求每个城市的销售额和门店数(去重)? data %&gt;% filter(between(月,1,5)) %&gt;% group_by(城市) %&gt;% summarise(金额 = sum(金额),门店数 = n_distinct(门店编码)) 近30天商品销量排名? data %&gt;% filter(订单日期 &gt;= Sys.Date()-30) %&gt;% group_by(分析大类,商品编码) %&gt;% summarise(商品销量 = sum(数量)) %&gt;% group_by(分析大类) %&gt;% mutate(商品排名 = dense_rank(desc(商品销量))) # 注意用desc倒序，销量高排第一 销售和库存形成笛卡尔积表，计算商品有货率、动销率? Cheat Sheet 手册搬运于dplyr官方介绍 dplyr-sheet Rstudio其它手册:https://www.rstudio.com/resources/cheatsheets/ "],["dplyr-usage.html", "2.2 基础用法", " 2.2 基础用法 基础用法部分，我们将从行筛选，重命名、列位置调整、新增计算列、排序、分组聚合几个方面阐述dplyr动词功能。 首先加载包，加载包时可能会有一些重名函数的提示，可以通过warn.conflict参数禁掉提示。如下所示： # 禁掉提示 library(dplyr,warn.conflicts = FALSE) 2.2.1 filter filter动词顾名思义即筛选功能，按照一定条件筛选data.frame；与Excel中的筛选功能和SQL中where条件一致。 filter条件筛选中可以分为单条件筛选和多条件筛选；多条件中间用,分隔。 单条件 条件为species == \"Droid\"时，如下所示： starwars %&gt;% filter(species == &quot;Droid&quot;) select * from starwars where species = &quot;Droid&quot; -- 注意=与==的区别 多条件 多条件筛选时，用英文逗号隔开多个条件。用“and”连接多个条件与用逗号隔开效果相同,“and”在R中用&amp;表示。 starwars %&gt;% filter(species == &quot;Droid&quot;,skin_color == &quot;gold&quot;) # same above # starwars %&gt;% # filter(species == &quot;Droid&quot; &amp; skin_color == &quot;gold&quot;) select * from starwars where species = &quot;Droid&quot; and skin_color = &quot;gold&quot; 多情况筛选 类似SQL中 in 的用法，或Excel中筛选条件时“或”条件 starwars %&gt;% filter(species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) select * from starwars where species in (&quot;Droid&quot;,&quot;Clawdite&quot;) --sql查询 逻辑关系筛选 条件运算分为逻辑运算、关系运算。 关系运算符 &gt;、&lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。 逻辑运算符 &amp;、|、！。 |为 或, &amp; 为并、且条件，!为非。 library(nycflights13) filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) # same above filter(flights, arr_delay &lt;= 120 &amp; dep_delay &lt;= 120) # %in% 的反面 starwars %&gt;% filter(!species %in% c(&quot;Droid&quot;,&#39;Clawdite&#39;)) !的运算级别相比 %in% 更高 2.2.2 select 当完整数据集列较多时，我们某次分析可能并不需要那么多列，通过动词select()筛选列,剔除不需要的列。 基础用法 通过指定列名称筛选，并指定列之间顺序 starwars %&gt;% select(name,height,mass,hair_color,skin_color,eye_color) 列索引 通过列名或数字向量索引，但是不建议用数字索引，避免原始数据列顺序变化后导致报错。 starwars %&gt;% select(name : eye_color) #same above starwars %&gt;% select(1:6) # starwars %&gt;% select(c(1,2,4,5,7)) 新增列筛选方式 # starwars %&gt;% select(!(name:mass)) # iris %&gt;% select(!ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) &amp; ends_with(&quot;Width&quot;)) # iris %&gt;% select(starts_with(&quot;Petal&quot;) | ends_with(&quot;Width&quot;)) 2.2.3 rename 列重命名使用rename()函数，新名称写前面，如下所示： starwars %&gt;% rename(home_world = homeworld) # 多列同换 starwars %&gt;% rename(home_world = homeworld,skincolor = skin_color) select * ,homeworld as home_word from starwars select * ,homeworld home_word from starwars as 可以省略，但中间有一个以上空格。与R的差异是新增home_word列，原始列继续存在，R中是替换列名。 2.2.4 relocate 更改列顺序，与使用select()动词指定列顺序功能相似。 relocate参数如下： relocate(.data, ..., .before = NULL, .after = NULL) # sex:homeworld列在height列前面 starwars %&gt;% relocate(sex:homeworld, .before = height) 2.2.5 mutate 动词mutate可以新增计算列，删除列，更新已有列，列之间的计算都可以通过mutate实现。 新增计算列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2)) %&gt;% select(name:mass,bmi) 新增计算列基础上新增列 starwars %&gt;% mutate(bmi = mass / ((height / 100) ^ 2),newbmi = bmi *2) %&gt;% select(name:mass,bmi,newbmi) 删除列 starwars %&gt;% mutate(height = NULL) 2.2.6 arrange 单列排序，默认升序，通过desc()降序排列 starwars %&gt;% arrange(desc(mass)) 多列排序 starwars %&gt;% arrange(height,desc(mass)) select * from starwars order by height,mass desc 2.2.7 summarise summarise常与group_by结合使用。 mtcars %&gt;% summarise(mean = mean(disp), n = n()) n()是dplyr包中的计算当前组的大小，用在summarise()和mutate()中。通常可用来组计算。 2.2.8 group_by 聚合前一般都需要分组，group_by()动词实现该功能，与SQL中group by ···类似。 starwars %&gt;% group_by(species) %&gt;% summarise( n = n(), mass = mean(mass, na.rm = TRUE) ) SELECT species, count(species) n, AVG(mass) mass FROM [spb].[dbo].[starwars] GROUP BY species "],["dplyr-merge-table.html", "2.3 表关联", " 2.3 表关联 表关联指像sql中的left join,inner join等表格之间的操作，或者是Excel中Power Piovt建模的建立关系，从而实现不同表格间的关联。 2.3.1 基础 left_join(),full_join,inner_join()等动词关联两个表。详情请查看：vignette(\"two-table\") left_join()实现类似Excel中VLOOKUP函数功能或数据库中left join功能，将“右表”的字段依据“主键”关联到“左表”上。 基础用法 left_join(),right_join(),full_join(),inner_join()，第一个以左表为主，第二个右表为主，第三个全连接，第四个内连接(只返回两表中都有的记录)，和数据库中连接方式一致。 默认会自动寻找两表中相同的字段名作为关联的条件 library(&quot;nycflights13&quot;) # Drop unimportant variables so it&#39;s easier to understand the join results. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 %&gt;% left_join(airlines) 指定关联条件列，类似数据库中on a.column = b.column。 R实现 flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) Sql实现 select * from flights2 a left join planes b on a.tailnum = b.tailnum 不同名称列关联 left_join(x,y,by = c(\"a\" = \"b\", \"c\" = \"d\")) 将会匹配 x$a to y$b 和 x$c to y$d 作为关联条件 #出发机场和目的机场信息 flights2 %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) #flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) # 组合条件 多条件时用向量包裹即可c(&quot;dest&quot; = &quot;faa&quot;,&quot;cola&quot; = &quot;colb&quot;)) 筛选连接 anti_join() 删除所有左表中在右表中匹配到的行 semi_join()保留所有左表在右表中匹配到的行 df1 &lt;- tibble(a=letters[1:20],b=1:20) df2 &lt;- tibble(a=letters,b=1:26) df1 %&gt;% semi_join(df2) df2 %&gt;% anti_join(df1) 集合操作 intersect(x,y)返回x,y交集 union(x,y)返回x,y中唯一的值 setdiff(x,y)返回存在x中但是不存在y中的记录 (df1 &lt;- tibble(x = 1:2, y = c(1L, 1L))) (df2 &lt;- tibble(x = 1:2, y = 1:2)) intersect(df1, df2) union(df1, df2) setdiff(df1, df2) setdiff(df2, df1) 2.3.2 多表操作 多表操作请使用purrr::reduce(),当需要合并多个表格时，可用以下方式减少合并代码量。 dt1 &lt;- data.frame(x = letters) dt2 &lt;- data.frame(x = letters,cola = 1:26) dt3 &lt;- data.frame(x = letters,colb = 1:26) dt4 &lt;- data.frame(x = letters,cold = 1:26) dt5 &lt;- data.frame(x = letters,cole = 1:26) dtlist &lt;- list(dt1,dt2,dt3,dt4,dt5) purrr::reduce(dtlist,left_join,by=&#39;x&#39;) "],["dplyr-column-manipulation.html", "2.4 列操作", " 2.4 列操作 在多列上执行相同的操作是常用的操作，但是通过复制和粘贴代码，麻烦不说还容易错： df %&gt;% group_by(g1, g2) %&gt;% summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(d)) 通过across()函数可以更简洁地重写上面代码： df %&gt;% group_by(g1, g2) %&gt;% summarise(across(a:d, mean)) 2.4.1 基本操作 across() 有两个主要参数： 第一个参数，.cols选择要操作的列。它使用tidyr的方式选择（例如select()），因此您可以按位置，名称和类型选择变量。 第二个参数，.fns是要应用于每一列的一个函数或函数列表。这也可以是purrr样式的公式（或公式列表），例如~ .x / 2。 starwars %&gt;% summarise(across(where(is.character), ~ length(unique(.x)))) # 列属性是字符的列求唯一值数 # starwars %&gt;% # summarise(length(unique(name))) # starwars %&gt;% # summarise(length(unique(hair_color))) starwars %&gt;% group_by(species) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(c(sex, gender, homeworld), ~ length(unique(.x)))) starwars %&gt;% group_by(homeworld) %&gt;% filter(n() &gt; 1) %&gt;% summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) across() 不会选择分组变量： df &lt;- data.frame(g = c(1, 1, 2), x = c(-1, 1, 3), y = c(-1, -4, -9)) df %&gt;% group_by(g) %&gt;% summarise(across(where(is.numeric), sum)) 2.4.2 多种函数功能 通过在第二个参数提供函数或lambda函数的命名列表，可是使用多个函数转换每个变量： min_max &lt;- list( min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE) ) starwars %&gt;% summarise(across(where(is.numeric), min_max)) 通过.names参数控制名称： NB:该参数的机制没有特别理解，需多练习体会。主要是运用到匿名函数时 以下是官方案例，但是报错(目前已修复)： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{.fn}.{.col}&quot;)) 修改后正常运行： starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}.{col}&quot;)) 区别主要是.names参数的使用方式问题，.加不加的问题。 starwars %&gt;% summarise(across(where(is.numeric), min_max, .names = &quot;{fn}——{col}&quot;)) 2.4.3 当前列 如果需要，可以通过调用访问内部的“当前”列的名称cur_column()。 该函数不是特别容易理解，需要多尝试使用加深认识。 df &lt;- tibble(x = 1:3, y = 3:5, z = 5:7) mult &lt;- list(x = 1, y = 10, z = 100) df %&gt;% mutate(across(all_of(names(mult)), ~ .x * mult[[cur_column()]])) "],["dplyr-row-manipulation.html", "2.5 行操作", " 2.5 行操作 行操作指不同字段间的计算，如Excle的列与列之间计算,Excle中的函数对行列不敏感，没有明显区别，但是R中tidyverse里列计算简单，行间计算依赖rowwise()函数实现 2.5.1 比较差异 df &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() 像group_by(),rowwise()并没有做任何事情，它的作用是改变其他动词的工作方式。 注意以下代码返回结果不同 df %&gt;% mutate(m = mean(c(x, y, z))) df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z))) df %&gt;% mutate(m = mean(c(x, y, z)))返回的结果是x,y,z散列全部数据的均值；df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))通过rowwise改变了mean的作为范围，返回的某行x,y,z列3个数字的均值。两种动词的作用的范围因为rowwise完全改变。 您可以选择在调用中提供“标识符”变量rowwise()。这些变量在您调用时被保留summarise()，因此它们的行为与传递给的分组变量有些相似group_by()： df &lt;- tibble(name = c(&quot;Mara&quot;, &quot;Hadley&quot;), x = 1:2, y = 3:4, z = 5:6) df %&gt;% rowwise() %&gt;% summarise(m = mean(c(x, y, z))) df %&gt;% rowwise(name) %&gt;% summarise(m = mean(c(x, y, z))) 2.5.2 行汇总 dplyr::summarise()使得聚合一列的值非常容易。当summarise()与rowwise()结合使用时，可以轻松聚合一行各列的值： df &lt;- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45) rf &lt;- df %&gt;% rowwise(id) rf %&gt;% mutate(total = sum(c(w, x, y, z))) rf %&gt;% summarise(total = sum(c(w, x, y, z))) 键入每个变量名称很繁琐，通过c_across()使更简单。 详情可见vignette(“rowwise”)。 rf %&gt;% mutate(total = sum(c_across(w:z))) rf %&gt;% mutate(total = sum(c_across(where(is.numeric)))) rf %&gt;% mutate(total = sum(c_across(w:z))) %&gt;% ungroup() %&gt;% mutate(across(w:z, ~ . / total)) "],["dplyr-groupby-manipulation.html", "2.6 分组操作", " 2.6 分组操作 详情: https://cloud.r-project.org/web/packages/dplyr/vignettes/grouping.html group_by()最重要的分组动词,需要一个数据框和一个或多个变量进行分组： 2.6.1 添加分组 by_species &lt;- starwars %&gt;% group_by(species) by_sex_gender &lt;- starwars %&gt;% group_by(sex, gender) 除了按照现有变量分组外，还可以按照函数处理后的变量分组，等效在mutate()之后执行group_by: bmi_breaks &lt;- c(0, 18.5, 25, 30, Inf) starwars %&gt;% group_by(bmi_cat = cut(mass/(height/100)^2, breaks=bmi_breaks)) %&gt;% tally() 2.6.2 删除分组变量 要删除所有分组变量，使用ungroup(): by_species %&gt;% ungroup() %&gt;% tally() 2.6.3 动词 summarise() 计算每个组的汇总，表示从group_keys开始右侧添加汇总变量 by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE) ) 该.groups=参数控制输出的分组结构。删除右侧分组变量的历史行为对应于.groups = “drop_last”没有消息或.groups = NULL有消息（默认值）。 从1.0.0版开始，分组信息可以保留(.groups = \"keep\")或删除 (.groups = 'drop) a &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;drop&#39;) %&gt;% group_vars() b &lt;- by_species %&gt;% summarise( n = n(), height = mean(height, na.rm = TRUE),.groups=&#39;keep&#39;) %&gt;% group_vars() object.size(a) object.size(b) 在实际使用中，当数据较大时需要删掉分组信息。以上可以看到保留分组信息的比没保留的大了两倍多。 "],["dplyr-functions.html", "2.7 常用函数", " 2.7 常用函数 2.7.1 条件判断 相比于base::ifelse,if_else更为严格，无论TRUE或FALSE输出类型一致，这样速度更快。与data.table::fifelse()功能相似。 if_else(condition, true, false, missing = NULL) 与ifelse不同的是，if_else保留类型 x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) 2.7.2 case_when 当条件嵌套条件较多时，使用case_when,使代码可读并且不易出错。与sql 中的case when 等价。 Dates &lt;- as.Date(c(&#39;2018-10-01&#39;, &#39;2018-10-02&#39;, &#39;2018-10-03&#39;)) case_when( Dates == &#39;2018-10-01&#39; ~ Dates - 1, Dates == &#39;2018-10-02&#39; ~ Dates + 1, Dates == &#39;2018-10-03&#39; ~ Dates + 2, TRUE ~ Dates ) 2.7.3 计数函数 计数 count()函数用来计数。下面两种表达方式等价。 df %&gt;% count(a, b) # same above df %&gt;% group_by(a, b) %&gt;% summarise(n = n()) starwars %&gt;% count(species) # same above 等价 starwars %&gt;% group_by(species) %&gt;% summarise(n = n()) 非重复计数 n_distinct()与length(unique(x))等价，但是更快更简洁。当我们需要给门店或订单之类数据需要去重计算时采用该函数。 x &lt;- sample(1:10, 1e5, rep = TRUE) length(unique(x)) n_distinct(x) 2.7.4 排序函数 dplyr共六种排序函数，模仿SQL2003中的排名函数。 row_number():等于 rank(ties.method = “first”) min_rank(): 等于 rank(ties.method = “min”) dense_rank(): 与min_rank()相似,但是没有间隔 percent_rank():返回0，1之间，通过min_rank()返回值缩放至[0,1] x &lt;- c(5, 1, 3, 2, 2, NA) row_number(x) min_rank(x) dense_rank(x) percent_rank(x) cume_dist(x) 2.7.5 提取向量 该系列函数是对[[的包装。 nth(x, n, order_by = NULL, default = default_missing(x)) first(x, order_by = NULL, default = default_missing(x)) last(x, order_by = NULL, default = default_missing(x)) x &lt;- 1:10 y &lt;- 10:1 first(x) last(y) nth(x, 1) nth(x, 5) 2.7.6 group 系列 group_by(),group_map(), group_nest(), group_split(), group_trim()等一系列函数。 其中我常用group_by(),group_split()两个函数。group_by()是大部分数据操作中的分组操作，按照group_by()的指定分组条件。 group_by() #group_by()不会改变数据框 by_cyl &lt;- mtcars %&gt;% group_by(cyl) by_cyl # It changes how it acts with the other dplyr verbs: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) # group_by中可以添加计算字段 即mutate操作 mtcars %&gt;% group_by(vsam = vs + am) %&gt;% group_vars() group_map() group_map，group_modify,group_walk等三个函数是purrr类具有迭代风格的函数。简单关系数据库的数据清洗一般不涉及，常用在建模等方面。 但是目前三个函数是实验性的，未来可能会发生变化。 # return a list # 返回列表 mtcars %&gt;% group_by(cyl) %&gt;% group_map(~ head(.x, 2L)) iris %&gt;% group_by(Species) %&gt;% group_modify(~ { .x %&gt;% purrr::map_dfc(fivenum) %&gt;% mutate(nms = c(&quot;min&quot;, &quot;Q1&quot;, &quot;median&quot;, &quot;Q3&quot;, &quot;max&quot;)) }) # group_walk dir.create(temp &lt;- tempfile()) iris %&gt;% group_by(Species) %&gt;% group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, &quot;.csv&quot;)))) list.files(temp, pattern = &quot;csv$&quot;) unlink(temp, recursive = TRUE) group_cols() 选择分组变量 gdf &lt;- iris %&gt;% group_by(Species) gdf %&gt;% select(group_cols()) 2.7.7 其它函数 between cummean cumsum cumall cumany 累计系列函数 x &lt;- c(1, 3, 5, 2, 2) cummean(x) cumsum(x) / seq_along(x) cumall(x &lt; 5) cumany(x == 3) distinct df &lt;- tibble( x = sample(10, 100, rep = TRUE), y = sample(10, 100, rep = TRUE) ) distinct(df, x) distinct(df, x, .keep_all = TRUE) distinct(df, diff = abs(x - y)) "],["dplyr-programming.html", "2.8 dplyr编程", " 2.8 dplyr编程 Programming with dplyr 本节概念性东西较多且复杂不易理解，先尝试会使用，概念再慢慢消化理解。虽然复杂,但是比较实用，尤其是当我们需要定义一些通用功能函数时。 以下是对原文引用 两种情况： When you have the data-variable in a function argument (i.e. an env-variable that holds a promise2), you need to ** embrace ** the argument by surrounding it in doubled braces, like filter(df, {{ var }}). The following function uses embracing to create a wrapper around summarise() that computes the minimum and maximum values of a variable, as well as the number of observations that were summarised: var_summary &lt;- function(data, var) { data %&gt;% summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %&gt;% group_by(cyl) %&gt;% var_summary(mpg) When you have an env-variable that is a character vector, you need to index into the .data pronoun with [[, like summarise(df, mean = mean(.data[[var]])). The following example uses .data to count the number of unique values in each variable of mtcars: for (var in names(mtcars)) { mtcars %&gt;% count(.data[[var]]) %&gt;% print() } Note that .data is not a data frame; it’s a special construct, a pronoun, that allows you to access the current variables either directly, with .data$x or indirectly with .data[[var]]. Don’t expect other functions to work with it. 2.8.1 案例 当我们不知道接下来会用哪个变量汇总时： my_summarise &lt;- function(data, group_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean(mass)) } 如果在多个位置使用： my_summarise2 &lt;- function(data, expr) { data %&gt;% summarise( mean = mean({{ expr }}), sum = sum({{ expr }}), n = n() ) } 当多个表达式时： my_summarise3 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } 如果要输出变量名时： my_summarise4 &lt;- function(data, expr) { data %&gt;% summarise( &quot;mean_{{expr}}&quot; := mean({{ expr }}), &quot;sum_{{expr}}&quot; := sum({{ expr }}), &quot;n_{{expr}}&quot; := n() ) } my_summarise5 &lt;- function(data, mean_var, sd_var) { data %&gt;% summarise( &quot;mean_{{mean_var}}&quot; := mean({{ mean_var }}), &quot;sd_{{sd_var}}&quot; := mean({{ sd_var }}) ) } 任意个表达式： 这种使用场景更多 my_summarise &lt;- function(.data, ...) { .data %&gt;% group_by(...) %&gt;% summarise(mass = mean(mass, na.rm = TRUE), height = mean(height, na.rm = TRUE)) } starwars %&gt;% my_summarise(homeworld) starwars %&gt;% my_summarise(sex, gender) "],["参考资料.html", "2.9 参考资料", " 2.9 参考资料 1.programming https://dplyr.tidyverse.org/dev/articles/programming.html 2.https://cloud.r-project.org/web/packages/dplyr/vignettes/programming.html "],["tidyr.html", "3 tidyr", " 3 tidyr 在实际工作中，我们数据分析工作者80%的时间可能贡献在数据准备和数据清晰上。另外发现新问题时，可能又要重复数据准备、数据清晰的过程。如果采用不能完全复现的方式做数据准备清洗的工作，那将是一场灾难。 数据工作者最常用的工具可能是Excel,但是Excel并不具备很强的数据清洗能力，即使Excel有POwer query 、Dax等两大利器。工作中，实际面临原始的数据是脏乱无须的，业务系统仅仅只是记录了历史过程数据。当我们需要分析某一现象时，需要按照自己的需求重新采集数据，清洗为“标准”的数据格式。 标准数据：达到工作需求的数据，可以直接用Excel,power bi ，tableau等BI工具直接使用的程度。 R中的tidyverse系列构建了一种一致的数据结构，当我们用tidyverse软件包提供的“数据整洁工具”整洁数据时，我们将花费更少的时间将数据从一种形式迁移到另外一种形式。从而，我们拥有更多的时间专注在具体的业务问题上。 "],["安装-1.html", "3.1 安装", " 3.1 安装 本章节，我们重点关注tidyr包，这个软件包提供了许多的功能函数整理混乱的数据。tidyr是tidyverse的核心成员包 ## 最简单是的方式就是安装tidyverse install.packages(&#39;tidyverse&#39;) ## 或者仅仅安装 tidyr: install.packages(&#39;tidyr&#39;) ## 或者从github 安装开发版本 ## install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/tidyr&quot;) # CTEST CODE "],["主要功能.html", "3.2 主要功能", " 3.2 主要功能 整洁的数据表现为： 每个变量是单独的一列 每一个观察的值都在自己的行 每一个值都是独立的单元格 大部分的数据集都是用行和列构成的data.frame。用Excel的单元格来表示，即每列代表不同意义的字段，每行是某个情形下的一系列字段；单元格则是独立的值,属于某个变量的观察值，这样构建的二维数据结构则是“整洁数据”。 library(tidyr) tidyr包中的函数可以分为5个主要大类 pivot_longer() 和 pivot_wider() 宽转长以及长转宽 unnest_longer() 和 unnest_wider(),hoist() 将列表嵌套转化为整洁数据 nest() 数据嵌套 separate(),extract()拆分列,提取新列 replace_na() 缺失值处理 3.2.1 宽转长 详情查看vignette(\"pivot\"),以下是照搬该图册中的内容 3.2.1.1 基础 长数据与宽数据之间的转换，类似我们常用的EXcel中的透视表功能。接下来用tidyr包自带的插图案例记录相关函数用法 在Excel中有时候方便我们肉眼观察，可能一个数据集会有很多列,如下所示： col1 col2 col3 col4 col5 col6 col7 v1 v2 v3 v4 v5 v6 v7 vb1 vb2 vb3 vb4 vb5 vb6 vb7 方便观察，但是不方便统计分析，这是我们需要把数据做处理，从“宽数据变成长数据”即宽转长。 library(tidyr) library(dplyr) library(readr) relig_income %&gt;% pivot_longer(cols = !religion,names_to = &#39;income&#39;,values_to = &quot;count&quot;) 第一个参数是数据集 第二个参数是那些列需要重塑，在该例中除了religion的其他全部列 names_to这个参数是新增的列名 values_to是新增的存储之前数据集中数据的列名 3.2.1.2 列名带数字 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE ) names_prefix 调整内容前缀，配合names_transform参数使用 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, names_transform = list(week = as.integer), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) 经过以上转换week列属性变成了整数，当然达到以上效果有其他的途径，如下： library(tidyverse,warn.conflicts = TRUE) # method 1 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, names_transform = list(week = readr::parse_number), values_to = &quot;rank&quot;, values_drop_na = TRUE, ) # method 2 billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week&quot;, values_to = &quot;rank&quot;, values_drop_na = TRUE, ) %&gt;% mutate(week = str_remove(week, &quot;wk&quot;) %&gt;% as.integer()) 3.2.1.3 多变量列名 该案列设计比较复杂的正则表达式,new_?(.*)_(.)(.*)需要一定正则表达式基础。 new_?表示匹配new或new_，(.*)匹配任意0次或多次任意字符。 正则表达式介绍 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, values_to = &quot;count&quot; ) 进一步处理列gender，age 。 who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), names_pattern = &quot;new_?(.*)_(.)(.*)&quot;, names_transform = list( gender = ~ readr::parse_factor(.x, levels = c(&quot;f&quot;, &quot;m&quot;)), age = ~ readr::parse_factor( .x, levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), ordered = TRUE ) ), values_to = &quot;count&quot;, ) 3.2.1.4 一行多观测值 family &lt;- tribble( ~family, ~dob_child1, ~dob_child2, ~gender_child1, ~gender_child2, 1L, &quot;1998-11-26&quot;, &quot;2000-01-29&quot;, 1L, 2L, 2L, &quot;1996-06-22&quot;, NA, 2L, NA, 3L, &quot;2002-07-11&quot;, &quot;2004-04-05&quot;, 2L, 2L, 4L, &quot;2004-10-10&quot;, &quot;2009-08-27&quot;, 1L, 1L, 5L, &quot;2000-12-05&quot;, &quot;2005-02-28&quot;, 2L, 1L, ) family &lt;- family %&gt;% mutate_at(vars(starts_with(&quot;dob&quot;)), parse_date) family family %&gt;% pivot_longer( !family, names_to = c(&quot;.value&quot;, &quot;child&quot;), names_sep = &quot;_&quot;, values_drop_na = TRUE ) anscombe %&gt;% pivot_longer(everything(), names_to = c(&quot;.value&quot;, &quot;set&quot;), names_pattern = &quot;(.)(.)&quot; ) %&gt;% arrange(set) pnl &lt;- tibble( x = 1:4, a = c(1, 1,0, 0), b = c(0, 1, 1, 1), y1 = rnorm(4), y2 = rnorm(4), z1 = rep(3, 4), z2 = rep(-2, 4), ) pnl %&gt;% pivot_longer( !c(x, a, b), names_to = c(&quot;.value&quot;, &quot;time&quot;), names_pattern = &quot;(.)(.)&quot; ) 3.2.1.5 重复列名 df &lt;- tibble(id = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = &quot;minimal&quot;) df %&gt;% pivot_longer(!id, names_to = &quot;name&quot;, values_to = &quot;value&quot;) 3.2.2 长转宽 pivot_wider()功能与pivot_longer()相反。通过增加列数减少行数使数据集变得更宽，通常我们在汇总时候使用，达到类似Excel透视表结果。 3.2.2.1 基础 fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) 缺失值填充 fish_encounters %&gt;% pivot_wider( names_from = station, values_from = seen, values_fill = 0 ) 3.2.2.2 聚合 warpbreaks &lt;- warpbreaks %&gt;% as_tibble() warpbreaks %&gt;% count(wool, tension) 需要通过values_fn指定聚合方式 warpbreaks %&gt;% pivot_wider(names_from = wool, values_from = breaks,values_fn= list(breaks = sum)) 3.2.2.3 从多个变量生成新列名 production &lt;- expand_grid( product = c(&quot;A&quot;, &quot;B&quot;), country = c(&quot;AI&quot;, &quot;EI&quot;), year = 2000:2014 ) %&gt;% filter((product == &quot;A&quot; &amp; country == &quot;AI&quot;) | product == &quot;B&quot;) %&gt;% mutate(production = rnorm(nrow(.))) production production %&gt;% pivot_wider( names_from = c(product, country), values_from = production ) 通过names_sep和names_prefix参数控制新的列名，或通过names_glue production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_sep = &quot;.&quot;, names_prefix = &quot;prod.&quot; ) production %&gt;% pivot_wider( names_from = c(product, country), values_from = production, names_glue = &quot;prod_{product}_{country}&quot; ) 3.2.2.4 多值变宽 us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) 3.2.3 处理json,html的数据 实际工作中不是经常使用，需要使用的时候往往会用相关的包处理：jsonlite 可通过vignette(\"rectangle\")自行学习 library(tidyr) library(dplyr) library(repurrrsive) users &lt;- tibble(user = gh_users) users users %&gt;% unnest_wider(user) 3.2.4 嵌套数据 library(tidyr) library(dplyr) library(purrr) 3.2.4.1 基础 嵌套数据即：数据框中嵌套数据框，如下所示： df1 &lt;- tibble( g = c(1, 2, 3), data = list( tibble(x = 1, y = 2), tibble(x = 4:5, y = 6:7), tibble(x = 10) ) ) df1 因为data.frame()的列特性【每列都是列表】【不确定理解对不对】：可以做如下操作： df2 &lt;- tribble( ~g, ~x, ~y, 1, 1, 2, 2, 4, 6, 2, 5, 7, 3, 10, NA ) df2 %&gt;% nest(data = c(x, y)) #sample above #df2 %&gt;% group_by(g) %&gt;% nest() nest的反面 unnest df1 %&gt;% unnest(data) 3.2.5 嵌套数据和模型 mtcars_nested &lt;- mtcars %&gt;% group_by(cyl) %&gt;% nest() mtcars_nested mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(data, function(df) lm(mpg ~ wt, data = df))) mtcars_nested mtcars_nested &lt;- mtcars_nested %&gt;% mutate(model = map(model, predict)) mtcars_nested 3.2.6 拆分和合并 3.2.6.1 拆分 有时我们需要将一列拆分为多列： library(tidyr) df &lt;- data.frame(x = c(NA, &quot;a.b&quot;, &quot;a.d&quot;, &quot;b.c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;, &quot;B&quot;)) 拆分数多列或少列时用NA补齐： df &lt;- data.frame(x = c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;, NA)) df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;)) 多余的部分舍弃，缺失填充在左边还是右边： # The same behaviour as previous, but drops the c without warnings: df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;drop&quot;, fill = &quot;right&quot;) 多余部分合并，缺失填充在左边 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;merge&quot;, fill = &quot;left&quot;) 或者全部保留 df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 指定分隔符 df %&gt;% separate(x, c(&quot;key&quot;, &quot;value&quot;), sep = &quot;: &quot;, extra = &quot;merge&quot;) 使用正则表达式 # Use regular expressions to separate on multiple characters: df &lt;- data.frame(x = c(NA, &quot;a?b&quot;, &quot;a.d&quot;, &quot;b:c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;,&quot;B&quot;), sep = &quot;([.?:])&quot;) 3.2.6.2 新列提取 df &lt;- data.frame(x = c(NA, &quot;a-b&quot;, &quot;a-d&quot;, &quot;b-c&quot;, &quot;d-e&quot;)) df %&gt;% extract(x, &quot;A&quot;) df %&gt;% extract(x, c(&quot;A&quot;, &quot;B&quot;), &quot;([[:alnum:]]+)-([[:alnum:]]+)&quot;) # [:alnum:] 匹配字母和数字 以上本质是字符处理，正则表达式 3.2.6.3 合并 df &lt;- expand_grid(x = c(&quot;a&quot;, NA), y = c(&quot;b&quot;, NA)) df df %&gt;% unite(&quot;z&quot;, x:y, remove = FALSE) # expand_grid 类似笛卡尔积功能 移除缺失值 df %&gt;% unite(&quot;z&quot;, x:y, na.rm = TRUE, remove = FALSE) 合并后再拆分 df %&gt;% unite(&quot;xy&quot;, x:y) %&gt;% separate(xy, c(&quot;x&quot;, &quot;y&quot;)) 3.2.7 缺失值处理 replace_na()用特定值替换缺失值。 df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;)) df %&gt;% replace_na(list(x = 0, y = &quot;unknown&quot;)) df %&gt;% dplyr::mutate(x = replace_na(x, 0)) "],["character-handling.html", "4 字符处理", " 4 字符处理 实际数据分析工作中,经常需要处理字符串以便让数据整洁，符合分析需求。在我们常用的Excel或sql中也有处理字符串的经验，大部分时候截断、替换等基础实现就能满足我们的大部分字符处理需求。 Excel中自带的字符串函数5，如:left,len,mid,find,Proper,rept,trim,upper,substitute,concatenate,以及Excle2019新出的concat,TEXTJOIN等字符函数，TEXTJOIN函数我个人比较喜欢用。在学习R的字符处理时候可以自行尝试实现以上相对应功能。 但是Excel中字符处理功能存在一定局限性,没有直接可用的正则表达式6函数,在正则表达式本身就很困难的情况下，在VBA中实现较复杂的函数将会难上加难。 字符处理本人觉得本质上就是将字符定位后去实现不同的操作。所以觉得难点在于字符串中字符的定位，而实现这个功能就需要用到正则表达式，所以字符处理真正的难点在于正则表达式的编写，但是在我看来正则表达式想要掌握，难度过高，我们秉着随用随查的态度对待即可。 因为大部分的数据分析工作者并不会面临太多复杂的字符处理工作，对大部分常规商业数据分析工作者面对的数据而言，字符处理可能仅仅只是合并、剔除、删除空格、倒序等基础操作。面对舆情监控，购物评价等纯文本情感分析工作，个人觉得对普通数据分析岗位有点超纲，所以本章节的字符处理仅仅是常规的字符处理。 Excel中支持的[TEXT functions] (https://support.microsoft.com/zh-cn/office/%e6%96%87%e6%9c%ac%e5%87%bd%e6%95%b0%ef%bc%88%e5%8f%82%e8%80%83%ef%bc%89-cccd86ad-547d-4ea9-a065-7bb697c2a56e?ui=zh-CN&amp;rs=zh-CN&amp;ad=CN)↩︎ 正则表达式(regular expression)描述了一种字符串匹配的模式(pattern),查看帮助?regex。↩︎ "],["character-base-R.html", "4.1 base R", " 4.1 base R 本部分简述base R中关于字符处理的常用函数。 4.1.1 单双引号 R语言中字符串输入时，可以使用单引号，也可以使用双引号，详情请看?Quotes。 单双引号用法和意义没有差别 R中推荐使用双引号分隔符，打印、显示时都是用双引号 单引号字符串通常用在字符串内包含双引号时，如用R执行sql字符串代码时 R-4.0之后引入的R字符[newfeatures]，让单双引号基本没区别 R中的字符用单双引号都可创建，如下所示: x &lt;- &quot;R语言&quot; x x &lt;- &#39;R语言&#39; x 4.1.2 转义 要在字符串中包含单引号或双引号，需用 转义它，即遇到特殊符号时需要转义,如果不正确使用转义，可能会报错，如下所示： paste(&quot;&quot;&quot;,&quot;abc&quot;,sep=&quot;&quot;) #&gt; 错误: unexpected string constant in &quot;paste(&quot;&quot;&quot;,&quot;&quot; R语言中使用“\"把特定的字符转义为特殊字符，例如“是制表符，“”是换行符，或者是“”(系统差异)。想要正确显示“’”，需使用转义，如下所示： char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; char 打印会显示转义符,主要是因为R语言内数据存储和打印是不一样的，运行结果为存储的数据形式，不是打印形式。 要查看字符串的原始内容,可使用writeLines()或cat() x &lt;- c(&quot;\\&quot;&quot;, &quot;\\\\&quot;) x writeLines(x) writeLines(char) cat(char) 4.1.3 常用函数 字符数量 s &lt;- &#39;abcdefg&#39; nchar(s) 大小写 toupper(&#39;abc&#39;) tolower(&#39;ABC&#39;) 拼接 函数paste()将不同的字符向量拼接组合起来，返回的数据类型是字符向量。其中分割参数sep默认值是\" \"(空格)。collapse参数是使用指定的字符把各元素拼接在一次成一个单独的字符串。 paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;) paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,sep = &#39;&#39;) paste(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,sep = &#39;_&#39;) paste(c(&#39;a&#39;,&#39;b&#39;),c(&#39;d&#39;,&#39;e&#39;),collapse = &#39;_&#39;) 大家可以自行了解paste和paste0两个函数的差异。 截取 substr函数用于字符串截取子字符串,start,stop参数是整数。 # 空格占据一个长度 substr(&quot;R is free software&quot; ,start = 1,stop = 6) 分割 函数strsplit按照指定的字符把字符分割成子字符。参数x被分割的字符，split是用于分割的字符标准，fixed是否完全匹配分隔符，默认是TRUE,完全匹配模式，当fixed参数为FALSE时，表名split参数是正则表达式，使用正则匹配。 strsplit(x,split,fixed,perl,useBytes) strsplit函数返回的结果是列表，大部分时候需要向量化后使用。 strsplit(&#39;广东省-深圳市-宝安区&#39;,split=&#39;-&#39;) # 向量化 # unlist(strsplit(&#39;广东省-深圳市-宝安区&#39;,split=&#39;-&#39;)) 官方手册中提供一个字符倒叙的自定义编写的函数： strReverse &lt;- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;) strReverse(c(&quot;abc&quot;, &quot;Statistics&quot;)) 4.1.4 新特性 该特性让反斜杠或单引号和双引号书写变得容易。用法r“(…)”，括号中可以是任意字符，详情请看?Quotes。 # windows下路径 ,不用转义路径复制直接可用 char &lt;- r&quot;(C:\\Users\\zhongyf\\Desktop\\Rbook)&quot; char char &lt;- &quot;我是一名\\&#39;小学生\\&#39;&quot; cat(char) char &lt;- r&quot;(我是一名&#39;R语言&#39;学习者)&quot; cat(char) 注意该特性需要在R-4.0.0之后的版本中使用 "],["character-stringr-packages.html", "4.2 stringr", " 4.2 stringr 本小节介绍R包stringr，stringr处理字符相对简单，并且是tidyverse系列的一部分，是很成熟的R包，API功能稳定。stringr是基于stringi之上构建的,stringr包集合了常见字符功能函数，如果发现stringr缺少某些功能可以查看stringi包。 如上文所说，字符串处理的难点，个人觉得在于正则表达式的掌握程度。对大部分常规商业数据分析工作者的面对的表格数据而言，字符处理可能仅仅只是合并、剔除、删除空格、倒叙等基础操作，所以stringr包基本满足字符处理需求。 stringr项目地址:https://github.com/tidyverse/stringr/ 如果不熟悉R中的字符串，可以从R for Data Science的字符串部分开始学习， 本小节的部分案例照搬R for Data Science。 4.2.1 安装 # Install the released version from CRAN: install.packages(&quot;stringr&quot;) # Install the cutting edge development version from GitHub: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;tidyverse/stringr&quot;) 4.2.2 基本使用 stringr包中所有的函数都已str_开头，让字符做第一个参数。 字符串长度 library(stringr) char &lt;- &quot;我是R语言学习者&quot; str_length(char) # 向量化 str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA)) 连接字符串 R中字符串不像python中可以用加号连接字符串,如下所示: R 版本 #base R paste0(&#39;a&#39;,&#39;b&#39;) #stringr str_c(&quot;a&quot;,&quot;b&quot;) str_c(&quot;a&quot;, &quot;b&quot;, sep = &quot;, &quot;) #sep 参数控制分隔符 Python 版本 &#39;a&#39; + &#39;b&#39; 多个字符串合并为一个字符,stringr中的函数都是向量化的，合并一个和多个字符都是同样道理。 #base R paste0(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #stringr str_c(c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;),collapse = &#39;,&#39;) #collapse 参数控制 移除 在正则表达式中 有特殊含义,有时需要两个 ，多体会下面这段，代码实现移除“||”的功能。 library(stringr) str_remove(string = &#39;a||b&#39;,pattern = &quot;\\\\|\\\\|&quot;) 另外常见的\\n, \\t需要被转义处理,在字符清洗,如小说语义分析,网页爬虫后整理等数据清洗过程中经常用到. 4.2.3 常用函数 4.2.3.1 截取字符 与Excle中left,mid,right函数功能类似 str_sub() 函数 三个参数: string:需要被截取的字符串 start: 默认1L,即从最开始截取 end:默认-1L,即截取到最后 #注意end 3 和 -3的区别 str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = 3) str_sub(string = &#39;我是R语言学习者&#39;,start = 2,end = -3) 4.2.3.2 匹配字符 查看函数帮助文档,str_match()按照指定pattern(正则表达式)查找字符。困难点在于正则表达式的编写。 ?str_match() ?str_match_all() ?str_extract() ?str_extract_all() str_extract()函数返回向量,str_match()函数返回矩阵. #原文来源烽火戏诸侯的&lt;剑来&gt; strings &lt;- c(&#39;陈平安放下新折的那根桃枝,吹灭蜡烛,走出屋子后,坐在台阶上,仰头望去,星空璀璨.&#39;) str_extract(strings,&#39;陈平安&#39;) str_match(strings,&#39;陈平安&#39;) 匹配中文 匹配中文的正则表达式\\[\\u4e00-\\u9fa5\\] str_extract_all(strings,&#39;[\\u4e00-\\u9fa5]&#39;) #返回list 匹配数字或英文 查找数字的正则表达式[0-9];查找英文的正则表达式:[a-zA-Z] strings &lt;- c(&#39;00123545&#39;,&#39;LOL league of legends&#39;) str_extract_all(strings,&#39;[0-9]&#39;) str_extract_all(strings,&#39;[a-zA-Z]&#39;) 4.2.3.3 添加字符 str_pad() 函数向字符串添加字符 像工作中处理月份的时候,1,2,3,4,5,6,7,8,9,10,11,12变成01,02,03,04,05,06,07,08,09,10,11,12.按照日期时间输出文件名称,如下所示: str_pad(string = 1:12,width = 2,side = &#39;left&#39;,pad = &#39;0&#39;) 4.2.3.4 去除空格 与excel中trim函数功能类似，剔除字符中的空格，但是不可以剔除字符中的空格 # side 可选 both left right str_trim(&#39; ab af &#39;,side = &#39;both&#39;) 4.2.3.5 分割字符 str_split()处理后的结果是列表 # 得到列表,需要向量化 str_split(&quot;a,b,d,e&quot;,pattern = &#39;,&#39;) str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% unlist() # same above #str_split(&#39;ab||cd&#39;,&#39;\\\\|\\\\|&#39;) %&gt;% purrr::as_vector() 当待处理的字符串是字符串向量时，得到的列表长度与向量长度一致 fruits &lt;- c( &quot;apples and oranges and pears and bananas&quot;, &quot;pineapples and mangos and guavas&quot; ) str_split(fruits, &quot; and &quot;) 4.2.3.6 替换字符 str_replace()，str_replace_all()函数用来替换字符 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_replace(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) str_replace_all(fruits, &quot;[aeiou]&quot;, &quot;-&quot;) 4.2.3.7 移除字符 str_remove(),str_remove_all()移除字符。本人常用该函数剔除文本中的空格。 fruits &lt;- c(&quot;one apple&quot;, &quot;two pears&quot;, &quot;three bananas&quot;) str_remove(fruits, &quot;[aeiou]&quot;) str_remove_all(fruits, &quot;[aeiou]&quot;) 移除文本中空格 str_replace_all(string = &#39; d a b &#39;,pattern = &#39; &#39;,replacement = &#39;&#39;) 4.2.3.8 字符排序 numeric参数决定是否按照数字排序。 str_order(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_sort(x, decreasing = FALSE, na_last = TRUE, locale = &quot;en&quot;, numeric = FALSE, ...) str_order(letters) str_sort(letters) numeric参数 x &lt;- c(&quot;100a10&quot;, &quot;100a5&quot;, &quot;2b&quot;, &quot;2a&quot;) str_sort(x) str_sort(x, numeric = TRUE) 4.2.3.9 提取单词 从句子中提取单词。 参数 word(string, start = 1L, end = start, sep = fixed(&quot; &quot;)) 案例 sentences &lt;- c(&quot;Jane saw a cat&quot;, &quot;Jane sat down&quot;) word(sentences, 2, -1) word(sentences[1], 1:3, -1) 指定分隔符 # Can define words by other separators str &lt;- &#39;abc.def..123.4568.999&#39; word(str, 1, sep = fixed(&#39;..&#39;)) word(str, 2, sep = fixed(&#39;..&#39;)) 4.2.3.10 其他函数 str_subset() str_which() 匹配字符串本身行筛选时候能用 fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_subset(fruit, &quot;a&quot;) str_which(fruit, &quot;a&quot;) # 匹配字符首次出现的位置 #str_which 是which(str_detect(x,pattern))的包装 #str_which() #str_subset是对x[str_detect(x,pattern)]的包装 #str_subset() #筛选出字母行 set.seed(24) dt &lt;- data.table::data.table(col=sample(c(letters,1:10),100,replace = T)) head(dt[str_which(col,pattern = &#39;[a-z]&#39;)]) str_dup() 复制字符串 fruit &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_dup(fruit, 2) str_dup(fruit, 1:3) str_c(&quot;ba&quot;, str_dup(&quot;na&quot;, 0:5)) str_starts() str_ends() 从str_detect()包装得到. str_starts(&#39;abd&#39;,&#39;a&#39;) str_detect(&#39;abd&#39;,&#39;^a&#39;) str_ends(&#39;abd&#39;,&#39;d&#39;) str_detect(&#39;abd&#39;,&#39;a$&#39;) 大小写转换 dog &lt;- &quot;The quick brown dog&quot; str_to_upper(dog) str_to_lower(dog) str_to_title(dog) str_to_sentence(&quot;the quick brown dog&quot;) "],["character-application.html", "4.3 综合运用", " 4.3 综合运用 4.3.1 实现excel函数 以下函数实现，仅仅只是从stringr包的函数上修改，并且没有完善，没有报错提示等的简陋版本，如果感兴趣的可以尝试利用Rcpp写出高性能版本的同功能函数。 left r_left &lt;- function(str,num){ str_sub(string = str,start = 1,end = num) } r_left(&#39;我是R语言学习者&#39;,3) right r_right &lt;- function(str,num){ str_sub(string = str,start = str_length(str) - num + 1) } r_right(&#39;我是R语言学习者&#39;,3) mid r_mid &lt;- function(str,start,num){ str_sub(string = str,start = start,end = start + num -1) } r_mid(&#39;我是R语言学习者&#39;,3,3) 其余函数可以尝试自行实现。 4.3.2 使用案例 实际运用案例 合并 library(data.table) dt &lt;- data.table(col=rep(&#39;a&#39;,10),letters=letters[1:10]) dt[,newcol:=str_c(letters,collapse = &#39;|&#39;),by=.(col)][] 拆解 #工作中路径需要拆解 类似商品品类路径 进口水果-热带水果-生鲜,用户行为路径等 dt &lt;- data.table(col=&#39;a&#39;,letters=str_c(letters[1:10],collapse = &#39;|&#39;)) my_str_split &lt;- function(x){ str_split(x,pattern = &quot;\\\\|&quot;) %&gt;% unlist() #str_split 拆解出来是列表 需要向量化 } dt[,list(newcol=my_str_split(letters)),by=.(col)] "],["character-the-difference-stringr-and-base.html", "4.4 base和stringr", " 4.4 base和stringr 以下表格数据对比，主要是base R 和 stringr中的相应字符处理功能函数对比。 表格数据来源stringr and base differences。表格数据可用以下代码获取(注意网络): library(tidyverse) library(rvest) dt &lt;- read_html(&#39;https://stringr.tidyverse.org/articles/from-base.html&#39;) %&gt;% html_table() %&gt;% `[[`(1) base stringr gregexpr(pattern, x) str_locate_all(x, pattern) grep(pattern, x, value = TRUE) str_subset(x, pattern) grep(pattern, x) str_which(x, pattern) grepl(pattern, x) str_detect(x, pattern) gsub(pattern, replacement, x) str_replace_all(x, pattern, replacement) nchar(x) str_length(x) order(x) str_order(x) regexec(pattern, x) + regmatches() str_match(x, pattern) regexpr(pattern, x) + regmatches() str_extract(x, pattern) regexpr(pattern, x) str_locate(x, pattern) sort(x) str_sort(x) strrep(x, n) str_dup(x, n) strsplit(x, pattern) str_split(x, pattern) strwrap(x) str_wrap(x) sub(pattern, replacement, x) str_replace(x, pattern, replacement) substr(x, start, end) str_sub(x, start, end) tolower(x) str_to_lower(x) tools::toTitleCase(x) str_to_title(x) toupper(x) str_to_upper(x) trimws(x) str_trim(x) 通过以上对比，方便我们从Base R 切换到stringr包的使用。 "],["character-reference-material.html", "4.5 参考资料", " 4.5 参考资料 tidyverse-stringr:https://stringr.tidyverse.org/articles/from-base.html stringr vignettes:https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html R new feature:https://www.r-bloggers.com/4-for-4-0-0-four-useful-new-features-in-r-4-0-0/ R-4.0.0 NEW features:https://cran.r-project.org/doc/manuals/r-devel/NEWS.html "],["datetime.html", "5 时间处理", " 5 时间处理 时间处理看起来是一件简单的事情，因为我们每天都在使用，但事实上是一件复杂的事情。闰年导致每年的天数并不一致，每天也并不是24小时。可以自行搜索“夏令时”，“为什么一天是24小时”或“Why do we have 24 hours in a day”等问题了解关于时间的概念。 但是我们做数据分析，可能仅需要简单的计算时间，并不是必须了解“时间”。我们大部分时候能处理同环比，间隔天数等常规问题即可。 由于能力有限以及处理的日期数据类型有限，本章节仅就常规商业数据分析中时间处理提供一种解决办法。 本章主要分为三大部分： Base R中时间处理函数 lubridate包提供的日期时间处理方法 常规运用以及和Excel的时间系统对比 "],["datetime-base-R.html", "5.1 base R", " 5.1 base R R中内置Date,POSIXct和POSIXlt三个关于日期和时间的类7。 5.1.1 Date 如果我们的数据结构中只有日期，没有时间，我们仅需要使用Date类。 class(Sys.Date()) 1.创建日期 date1 &lt;- as.Date(&#39;2021-05-18&#39;) # as.Date(32768, origin = &quot;1900-01-01&quot;) # date1 &lt;- as.Date(&#39;2021-05-18&#39;,origin = &quot;1900-01-01&quot;) 当日期字符不规则时必须指定format参数 date2 &lt;- as.Date(&quot;5/14/2021&quot;,format=&quot;%m/%d/%Y&quot;) 想想如何才将将“2021年5月8日”转换成日期： as.Date(&quot;2021年5月18日&quot;,format=&quot;%Y年%m月%d日&quot;) 重点是时间的format，详情可以通过?strptime()查看。 2.日期计算 两日期之间间隔 date1 - date2 difftime(date1,date2,units = &#39;days&#39;) 日期加减天数 date1 - 4 date2 + 4 向量化计算 three_date &lt;- as.Date(c(&#39;2021-05-01&#39;,&#39;2021-05-05&#39;,&#39;2021-05-10&#39;)) diff(three_date) 在计算顾客购物间隔天数时比较有用。 3.创建日期向量 date3 &lt;- as.Date(&#39;2020-01-01&#39;) date4 &lt;- as.Date(&#39;2021-01-01&#39;) date_col &lt;- date3:date4 head(date_col) 以上方式创建日期向量会数字化，正确方式如下所示: # seq(date3,date4) seq(date3,date4,by=&quot;30 days&quot;) seq(date3,date4,by=&quot;8 weeks&quot;) 5.1.2 POSIXct 如果在数据中有时间，最好使用该类； Sys.time() #获取当前时间 class(Sys.time()) 1.创建POSIXct类 tm1 &lt;- as.POSIXct(&quot;2021-5-19 16:05:45&quot;) tm1 tm2 &lt;- as.POSIXct(&quot;19052021 16:05:45&quot;,format = &quot;%d%m%Y %H:%M:%S&quot;) tm2 # 比较是否相同 identical(tm1,tm2) 2.时区 时区如果不正确指定，将导致我们在做时间计算时可能出现错误，一般相差8小时,因为我们在东八区。 默认时区 Sys.timezone() as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) #不知道什么原因 CST需要变成CST6CDT不会报错 as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;GMT&#39;) - as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;UTC&#39;) - as.POSIXct(&quot;2021-5-19 16:05:45&quot;,tz = &#39;CST6CDT&#39;) 3.计算 比较 tm1 &lt;- as.POSIXct(&quot;2021-5-19 16:05:45&quot;) tm2 &lt;- as.POSIXct(&quot;2021-5-19 16:15:45&quot;) tm2 &gt; tm1 加减计算，默认单位秒 tm1 + 300 tm2 - 300 tm2 - tm1 5.1.3 POSIXlt 通过此类，我们可以很便捷提取时间中的特定成分。其中“ct”代表日历时间,“it”代表本地时间,该类对象是list(列表)。 创建时间 t1 &lt;- as.POSIXlt(&#39;2021-5-19 16:05:45&#39;) t1 unclass(t1) 提取 t1$mday t1$wday 截断 trunc(t1,&#39;day&#39;) trunc(t1,&#39;min&#39;) 类是面向对象编程的一个术语，一个对象通常有0个1个或多个类。在R中用class()函数查看所属对象的类。↩︎ "],["lubridate.html", "5.2 lubridate", " 5.2 lubridate lubridate包是对Base R中POSIXct类的封装。所以无论从函数名还是功能等方面，lubridate包中的函数功能更加清晰明了。从获取当前日期、时间，解析时间日期中的年、月、日、星期，计算年月间隔天数等常用的时间日期功能，lubridate包中都有相对应的功能函数。 在处理日期时间数据时，我常用lubridate解决，本节将介绍包中部分函数用法。 5.2.1 安装包 install.packages(&quot;tidyverse&quot;) # 仅仅只安装lubridate install.packages(&#39;lubridate&#39;) # 开发版 devtools::install_github(&quot;tidyverse/lubridate&quot;) # 加载包 library(lubridate,warn.conflicts = FALSE) 5.2.2 当前时间日期 now函数 now()函数是当前时间，只有一个参数tzone,默认为系统的timezone。 now() # now(tzone = &#39;Asia/Shanghai&#39;) # base R base::Sys.time() today函数 时区同样默认为系统的timezone。 today(tzone = &#39;Asia/Shanghai&#39;) #base R base::Sys.Date() 5.2.3 构造日期时间 使用数值直接创建日期时间。 函数make_date()和make_datetime()函数默认时区8为“UTC”。 make_date(year = 2021, month = 5, day = 1, tz = &quot;Asia/Shanghai&quot;) make_datetime( year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L, sec = 0, tz = &quot;Asia/Shanghai&quot; ) make_datetime make_datetime( year = year(today()), month = month(today()), day = day(today()), hour = hour(now()), min = minute(now()), sec = second(now()), tz = &quot;asia/shanghai&quot; ) as_datetime as_datetime(&#39;2020-01-09 09:15:40&#39;,tz=&#39;asia/shanghai&#39;) as_date(&#39;2020-01-09&#39;) #ymd格式 # same above #as_date(&#39;2020/01/09&#39;) #as_date(&#39;20200109&#39;) 5.2.4 解析日期时间 数据源中日期列可能是各种的字符形式，需要转换为时间格式方便进行日期计算。商业环境中的数据是混乱的，生产库可能是不同的数据库系统，导致时间日期格式混乱，如果公司没有统一的用户层数据源，我们就需要自己清洗数据，将不同形式的日期格式转化为标准格式。 解析日期 # 整数和字符都可以 ymd(20200604) ymd(&#39;20200604&#39;) mdy(06042020) dmy(04062020) 解析时间 ymd_hm(&quot;20100201 07-01&quot;, &quot;20100201 07-1&quot;, &quot;20100201 7-01&quot;) ymd_hms(&quot;2013-01-24 19:39:07&quot;) 当需要处理unix时间戳时应.POSIXct()函数转化. unix在线转换 .POSIXct(1591709615) ymd_hms(.POSIXct(1591709615)) 在使用unix时间戳转换时一定注意R环境和数据系统环境时区是否一直。 曾经我在使用阿里云的RDS数据库时没注意时区差异，导致我清洗出来的时间数据错误。 ymd_hms(.POSIXct(1591709615),tz = &#39;Asia/Shanghai&#39;) 5.2.5 提取日期时间成分 #获取年 year(now()) #获取月 month(now()) # 当前时间所在年份天数 yday(now()) # 当前时间所在月天数 mday(now()) # 周几 wday(now(),label = TRUE,week_start = 1) # 所在时刻 hour(now()) # 所在时刻 minute(now()) # 所在时刻 second(now()) 5.2.6 处理时区 数据时区与本地R环境一致时，数据中的时区没必要处理，但是当数据是跨时区的或者不同生产系统的时区不一致，我们需要将数据时区处理一致。 1.时区查看 时区和所用系统设置相关 Sys.timezone() # windows 系统默认的时区 中国台北 # linux 上是&quot;Asia/Shanghai&quot; # mac 上是&quot;Asia/Shanghai&quot; 这里还有一个奇怪的点，Windows系统下时区设置为(UTC+08:00)北京,重庆,香港特别行政区,乌鲁木齐,但是R返回的时区是Asia/Taipei。 now() now()输出结果中，CST是时区概念。 CST可以同时代表四个时间 Central Standard Time (USA) UT-6:00 Central Standard Time (Australia) UT+9:30 China Standard Time UT+8:00 Cuba Standard Time UT-4:00 2.时区调整 lubridate中用with_tz()，force_tz()处理时区问题 time &lt;- ymd_hms(&quot;2020-12-13 15:30:30&quot;) time # Changes printing with_tz(time, &quot;Asia/Shanghai&quot;) # Changes time force_tz(time, &quot;Asia/Shanghai&quot;) 时区差异 从下面三个时间观察时区，CST时间:中央标准时间;UTC时间:世界协调时间(UTC)是世界上不同国家用来调节时钟和时间的主要时间标准。 如:当UTC时间为0点时，中国CST时间为8点，因为零时区和中国北京时区相差8个时区. https://home.kpn.nl/vanadovv/time/TZworld.html#asi lubridate::now() # now函数调用系统默认时区 as_datetime(now()) #as_datetime默认是UTC as_datetime(now(),tz = &#39;asia/shanghai&#39;) 5.2.7 时间间隔 lubridate中将时间间隔保存为interveal类对象。 arrive &lt;- ymd_hms(&quot;2020-12-04 12:00:00&quot;, tz = &quot;asia/shanghai&quot;) arrive leave &lt;- ymd_hms(&quot;2020-12-10 14:00:00&quot;, tz = &quot;asia/shanghai&quot;) leave res &lt;- interval(arrive, leave) # same above res &lt;- arrive %--% leave 查看类 class(res) 两个时间间隔是否重复 jsm &lt;- interval(ymd(20201020, tz = &quot;asia/shanghai&quot;), ymd(20201231, tz = &quot;asia/shanghai&quot;)) jsm int_overlaps(jsm, res) 更多详细用法?interveal interval(start = NULL, end = NULL, tzone = tz(start)) start %--% end is.interval(x) int_start(int) int_start(int) &lt;- value int_end(int) int_end(int) &lt;- value int_length(int) int_flip(int) int_shift(int, by) int_overlaps(int1, int2) int_standardize(int) int_aligns(int1, int2) int_diff(times) 5.2.8 时间日期计算 时间日期计算以number line为依据计算。原文是Because the timeline is not as reliable as the number line，我没理解这句话。 minutes(2) dminutes(2) dhours(2) 注意闰年时计算年份的差异 leap_year(2019) ymd(20190101) + dyears(1) ymd(20190101) + years(1) leap_year(2020) ymd(20200101) + dyears(1) # 注意查看闰年时的差异 ymd(20200101) + years(1) lubridate中的函数都已向量化 meeting &lt;- ymd_hms(&quot;2020-12-01 09:00:00&quot;, tz = &quot;asia/shanghai&quot;) meeting &lt;- meeting + weeks(0:5) meeting %within% jsm 除法计算 res / ddays(1) res / dminutes(1) res %/% months(1) res %% months(1) as.period用法 as.period(res %% months(1)) 对于日期而言，因为月天数、年天数不一致，导致不能直接加减天数，如下： jan31 &lt;- ymd(&quot;2020-01-31&quot;) jan31 + months(0:11) lubridate中不存在的日期返回NA 解决方案是：%m+%或%m-% jan31 %m+% months(0:11) jan31 %m-% months(0:11) lubridate包中大部分函数默认时区为“UTC”，在涉及时间处理时需要注意时区。↩︎ "],["datetime-application.html", "5.3 综合运用", " 5.3 综合运用 5.3.1 日报同环比计算 零售行业基本都存在日报，作为数据分析师大概率是需要出日报的，但根据所在部门情况会有所不同。很多人都已经在sql或exel中实现了，本案例不完全实现日报，主要是教大家为了实现同环比，怎么利用R做日期范围筛选。 首先我们看看R里面怎么做日期的同环比计算： 常用函数 round_date()函数根据要求周期回滚日期 floor_date(today(),unit = &#39;year&#39;) floor_date(today(),unit = &#39;month&#39;) floor_date(today(),unit = &#39;week&#39;) 以上同系列函数从名字就能大概看出端倪，其中关键参数是unit，可选想如下: 1s,second,minute,5 mins,hour,dat,week,months,bimonth,quarter,season,halfyear,year。 round_date( x, unit = &quot;second&quot;, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) floor_date( x, unit = &quot;seconds&quot;, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) ceiling_date( x, unit = &quot;seconds&quot;, change_on_boundary = NULL, week_start = getOption(&quot;lubridate.week.start&quot;, 7) ) change_on_boundary参数 ceiling_date(ymd_hms(&#39;2021-01-1 00:00:00&#39;),&#39;month&#39;) ceiling_date(ymd_hms(&#39;2021-01-1 00:00:00&#39;),&#39;month&#39;,change_on_boundary = T) 计算年同比 n &lt;- 1 date &lt;- today() # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) current_start_date date # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_start_date last_end_date &lt;- date %m-% years(n) last_end_date 以上,n表示间隔年数，大部分时候都是1。但特殊时候，比如2021年同比2020年2-4月(新冠疫情)基本没有同比意义，所以在此设置为参数。 计算月同比 rollback()函数返回上个月的最后一天或当前月的第一天 rollback(today()) rollback(today(),roll_to_first = TRUE) 计算月环比 计算环比时，%m+%或%m-%可以很好解决月份天数不一的问题 as_date(&#39;2020-03-30&#39;) %m-% months(1) # 环比月截止日 today() today() %m-% months(1) 经过以上计算，得到一对对时间周期，然后在订单或者其它数据中筛选即可获得同环比维度数据。 模拟计算 # 构造数据 bill_date &lt;- as_date((as_date(&#39;2019-01-01&#39;):as_date(&#39;2020-12-01&#39;))) area &lt;- sample(c(&#39;华东&#39;,&#39;华西&#39;,&#39;华南&#39;,&#39;华北&#39;),size = length(bill_date),replace = TRUE) category &lt;- sample(c(&#39;品类A&#39;,&#39;品类B&#39;,&#39;品类C&#39;,&#39;品类D&#39;),size = length(bill_date),replace = TRUE) dt &lt;- tibble::tibble(bill_date = bill_date ,money = sample(80:150,size = length(bill_date),replace = TRUE),area = area,category = category) head(dt) 自定义函数 library(dplyr,warn.conflicts = FALSE) library(lubridate) y_to_y &lt;- function(.dt,date,n = 1,...){ date &lt;- ymd(date) if(is.na(date)){ stop(&#39;请输入正确日期格式，如20200101&#39;) } # current current_start_date &lt;- floor_date(date,unit = &#39;year&#39;) # last year last_start_date &lt;- floor_date(date,unit = &#39;year&#39;) %m-% years(n) last_end_date &lt;- date %m-% years(n) .dt %&gt;% mutate( 类型 = case_when(between(bill_date,current_start_date,date) ~ &quot;当前&quot;, between(bill_date,last_start_date,last_end_date) ~ &quot;同期&quot;, TRUE ~ &quot;其他&quot;)) %&gt;% filter(类型 != &quot;其他&quot;) %&gt;% group_by(...) %&gt;% summarise(金额 = sum(money,na.rm = TRUE)) %&gt;% ungroup() #%&gt;% pivot_wider(names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) } y_to_y(dt,date = &#39;20201001&#39;,n = 1,area,类型) %&gt;% tidyr::pivot_wider(id_cols = &#39;area&#39;,names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) %&gt;% mutate(增长率 = 当前 / 同期) y_to_y(dt,date = &#39;20201001&#39;,n = 1,area,类型,category) %&gt;% tidyr::pivot_wider(id_cols = c(&#39;area&#39;,&#39;category&#39;),names_from = &#39;类型&#39;,values_from = &#39;金额&#39;) %&gt;% mutate(增长率 = 当前 / 同期) 5.3.2 清洗不同类型日期格式 如将c('2001/2/13 10:33','1/24/13 11:16')转换为相同格式的日期格式; 通过一个简单自定义函数解决，本质是区分不同类型日期后采用不同函数去解析日期格式 library(lubridate) library(tidyverse) date1 &lt;- c(&#39;2001/2/13 10:33&#39;,&#39;1/24/13 11:16&#39;) myfun &lt;- function(x){ n_length &lt;- length(x) res &lt;- vector(length = n_length) for(i in 1:n_length){ n &lt;- strsplit(x[i],&#39;/&#39;) %&gt;% `[[`(1) %&gt;% `[[`(1) if(str_length(n)==4){ res[i] &lt;- ymd_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } else { res[i] &lt;- mdy_hm(x[i],tz = &#39;Asia/Shanghai&#39;) } } as_datetime(res,tz = &#39;Asia/Shanghai&#39;) } myfun(date1) 5.3.3 扫码后中奖时间匹配 假定有两张表，一张是用户扫码表，一张是用户中奖表，如下所示： 数据源视图 由于中奖时间和扫码时间不完全一致，导致没办法直接通过客户ID以及时间关联匹配找到客户每次中奖时的积分码,现在要求找到客户每次中奖时对应的积分码？ 思路：通过观察数据，发现扫码后如果中奖，一般几秒钟内会有中奖记录，那我们就可以通过“每次中奖时间最近的一次扫码时间的积分码”就是该次中奖对应的积分码解决问题。这样我们通过简单编写自定义函数即可获取答案，即一个时间点从一串时间中找到离自己最近时间点。 testfun &lt;- function(x,y){ result &lt;- data.frame() #应采用列表存储结果向量化 n &lt;- length(x) for( i in 1:n){ res &lt;- x[i]-y res &lt;- abs(res) %&gt;% which.min() #本处不对，应该判断res大于0的部分中谁最小 kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result &lt;- rbind(kong,result) } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 改进代码 testfun &lt;- function(x,y){ n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } return(result) } res &lt;- testfun(dt$时间,scan_dt$时间) 理论上不同用户可以在同一时间扫码且同时中奖，那上面的代码即不可以获取正确答案。但是我们只要通过按照用户ID切割数据框后稍微改造上面的自定义函数即可。 testfun &lt;- function(dt){ x &lt;- dt$中奖时间 y &lt;- dt$扫的时间 n &lt;- length(x) result &lt;- list() for( i in 1:n){ y &lt;- y[x&gt;y] res &lt;- x[i]-y res &lt;- res %&gt;% which.min() kong &lt;- data.frame(中奖时间 = x[i],扫的时间 = y[res]) result[[i]] &lt;- kong } result &lt;- dplyr::bind_rows(result) return(result) } dtlist &lt;- split(alldt,&#39;客户ID&#39;) purrr::map_dfr(dtlist,testfun) 虽然可以通过寻找最近一次的扫码记录判断积分码，但是因为网络延迟或中途接电话等各种原因导致扫码时间和中奖时间相差并不是几秒，导致情景复杂，那我们就应该在设计系统时就设计好锁定对应关系，从根本上解决问题。 "],["datetime-additional-information.html", "5.4 补充资料", " 5.4 补充资料 5.4.1 Excel and R Excel是我们天天打交道的工具，但是R与Excel都有自己的时间系统，而且还不统一，在计算时会给我们带来误解。 Excle日期系统 下面就Excel和R中的差异做简单阐述。 5.4.1.1 差异 R中日期起始时间是1970-01-01,Excel中起始日期9(Windows)是1900-01-01,转化成数字两者相差25568。如下所示： as.Date(&#39;1970-01-01&#39;) as.Date(25568,origin=&#39;1900-01-01&#39;) # 1970-01-02 as.Date(25568,origin=&#39;1899-12-31&#39;) # 1970-01-01 Excel中1900-01-01代表数字1，但是R中1970-01-01代表0。这也是比较怪异的点，毕竟R一般都是从1开始。 as.numeric(as.Date(&#39;1970-01-01&#39;)) 这样导致: R日期2021-05-21转化成数字是18768, Excel中日期2021-05-21转化成数字是44337,两者相差25569。 在用R读取Excel文件时，涉及到数字日期转化时需要注意其中差异。 5.4.1.2 Excel时间函数 在Excel的Power Pivot中有一组DAX智能函数，如： 基础函数 date,datediff,datevalue,edate,eomonth,quarter,TIMEVALUE等等 智能函数 dateadd,DATESBETWEEN,DATESMTD,TOTALMTD,TOTALQTD,TOTALYTD等等 Excel中因为有了以上时间智能函数，用度量值在透视表中计算同环比变得简单。 假如熟悉DAX时间智能函数，在R中设计相关功能或实现时可以借鉴参考DAX函数的思路。比如在R中写自动化报表时，涉及到同环比计算时就可以按照这个模式设计。 5.4.2 参考资料 lubridate https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html date and time https://www.stat.berkeley.edu/~s133/dates.html dax时间函数 https://docs.microsoft.com/en-us/dax/time-intelligence-functions-dax Excel日期系统 https://support.microsoft.com/zh-cn/office/excel-%e4%b8%ad%e7%9a%84%e6%97%a5%e6%9c%9f%e7%b3%bb%e7%bb%9f-e7fe7167-48a9-4b96-bb53-5612a800b487?ui=zh-CN&amp;rs=zh-CN&amp;ad=CN https://www.rdocumentation.org/packages/lubridate/versions/1.7.8 pdf 下载 https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf Excel中存在两套日期系统↩︎ "],["forcats.html", "6 forcats", " 6 forcats 我在实际工作中因子数据类型使用较少,forcats软件包用来处理因子,该软件包是tidyverse的一部分. 因子是用于对数据进行分类的R的一种数据类型. 它们可以存储字符串和整数.它们在具有有限数量的唯一值的列中很有用. 像“男性”，“女性”和True，False等。它们在统计建模的数据分析中很有用. 因子变量会占用更小空间,R4.0改变了字符默认为因子的方式.想了解更多请参考 https://r4ds.had.co.nz/factors.html object.size(rep(letters,100000)) object.size(rep(forcats::as_factor(letters),100000)) "],["创建因子.html", "6.1 创建因子", " 6.1 创建因子 实际工作中,可能各个事业部或部门之间没有实际顺序,但是在数据处理过程中需要指定顺序可以用因子. library(forcats) vec1 &lt;- c(&#39;部门a&#39;,&#39;部门b&#39;,&#39;部门d&#39;,&#39;部门f&#39;) sort(vec1) vec2 &lt;- as_factor(c(&#39;部门f&#39;,&#39;部门d&#39;,&#39;部门a&#39;,&#39;部门b&#39;)) sort(vec2) 如上所示:实际工作中可以通过指定因子水平从而达到排序效果,在可视化中也可以运用,像指定X轴的顺序. "],["data-table.html", "7 data.table", " 7 data.table data.table包是我数据处理最常用的R包，是我目前觉得最好用的数据处理包,大部分我需要用到的功能集成在包里，不需要很多的依赖包。我简单接触过python，julia两种语言，并没有深入比较，所以我这个好用的印象仅仅是个人感受。 data.table包是我用了较长一段时间tidyverse系列后发现的“数据处理包”。已经忘记最初是什么吸引了我，我猜测可能是“大数据处理利器”之类的标签吸引了我，因为我喜欢“快”。但是和大部分人可能不同的是，初次接触时，语法的“怪异”并没有给我带来多少麻烦，因为我本来就没有编程基础以及很深的R语言基础。 所以我死记硬背data.table里一些常用用法，尤其喜欢拿Excle的一些用法参照，去实现Excle上面的部分操作，从读取、增、改、删除、筛选、计算列等常规操作入手。慢慢熟悉data.table语法之后，将会享受data.table带来的便利，其简洁的语法以及高效的计算速度（相比tidyverse系列）。 另外，Python中也有该包，目前正在积极开发中，期待ing，毕竟python也是很好用，在不同需求下选择不同的语言实现功能。 官方关于data.table的基础介绍请参阅: https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html data.table 优势： 速度快 内存效率高 API生命周期管理好 语法简洁 本文会照搬很多官方关于data.table的demo "],["基础介绍.html", "7.1 基础介绍", " 7.1 基础介绍 本部分从data.table安装，内置的案例查看，到data.table的句式语法，实现基础行列筛选和聚合计算。 1.安装 安装详细信息请参考the Installation wiki，有关于不同系统安装首次以及相关说明。 install.packages(&quot;data.table&quot;) # latest development version: data.table::update.dev.pkg() 2.使用说明 通过以下代码查看内置的使用案例。 library(data.table) example(data.table) 7.1.1 读取数据 在我实际工作中接触的数据大部分以数据库,csv,Excel等形式存在，并且CSV格式数据较少。但是data.table包读取数据的fread函数仅接受CSV格式。如果是Excel格式文件，需要通过如readxl，openxlsx等包读入后转换为data.table格式数据。 fread 函数可以直接读取CSV格式文件,无论是本地文件或者在线文件,如下所示: 案例中使用的数据集是R包nycflights13带的flights数据集。 library(data.table) input &lt;- if (file.exists(&quot;./data/flights.csv&quot;)) { &quot;./data/flights.csv&quot; #本地文件 } else { &quot;https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights.csv&quot; #在线文件需翻墙 } flights &lt;- fread(input) #具体参数请参照文档 实际工作中可能会用到的encoding参数,编码 encoding=&#39;UTF-8&#39; head(flights) 本文读取本地文件,如果该数据集下载失败,可更改地址为(http://www.zhongyufei.com/datatable/data/flights.csv) flights &lt;- fread(&quot;http://www.zhongyufei.com/Rbook/data/flights.csv&quot;) 数据集记录的是 2014 年,纽约市3大机场(分别为:JFK 肯尼迪国际机场、 LGA 拉瓜迪亚机场,和 EWR 纽瓦克自由国际机场)起飞的航班信息。 具体的记录信息(特征列)，包括起飞时间、到达时间、延误时长、航空公司、始发机场、目的机场、飞行时长，和飞行距离等。 7.1.2 基本格式 DT[i, j, by]是data.table的基本样式，在不同位置上实现不同功能。 i-j-by DT[i, j, by] ## R: i j by ## SQL: where | order by select | update group by data.table个人理解主要有三大类参数,i参数做筛选,j参数做计算,by参数做分组. 拿Excel透视表类别,i位置参数当作『筛选』,by位置用来做汇总字段『行』,j位置当作『值』,如下所示: 透视表截图 1.代码实例 代码求2014年6月,从各始发机场到各目的机场的飞行距离求和. library(data.table) flights &lt;- fread(&quot;./data/flights.csv&quot;) flights[year==2014 &amp; month==6,.(求和项distance=sum(distance)),by=.(origin,dest)] 2.代码解释 i 的部分：条件year==2014 和 month==6 ; j 的部分：求和项distance=sum(distance)，写在.()中或者list()中； by 的部分.(origin,dest),重点是写在.()中,和Excel透视表一一对应。 至于为什么要用.()包裹起来，最开始默认为格式强制要求。就这个问题我想说：大部分人可能觉得是比较“怪异”的用法，并且不理解，从而可能留下data.table不好用，很古怪的印象，但是我觉得任何东西存在即合理，你学一个东西总得接受一些你可能不认可的东西，这样可能才是真正的学习，就像拿Python来做数据分析，我刚开始觉得pandas很难用，很反人类，但是后来知道python代码可以直接打包封装成exe后，觉得真香，说这么多主要是想表达我们学会挑选合适的工具用，适应它，用好它就可以了。 7.1.3 i j by 使用 使用data.table处理数据，接下来我们就用该函数读取数据演示i,j,by的简单使用。 7.1.3.1 i行筛选 行筛选是一种很常见的数据操作行为，类似我们Excel中的筛选，即按照一定条件筛选符合要求的数据。条件筛选一般分为单条件筛选、多条件筛选； 在筛选时涉及到条件判断，R语言中常用的条件判断分为逻辑运算、关系运算。常用的关系运算符 &gt;、 &lt;、==、!=、&gt;=、&lt;=分别代表大于、小于、等于、不等于、大于等于、小于等于。常用的逻辑运算符 &amp;、|、！等。 #单条件筛选 filghts[year == 2014] #筛选year==2014 #多条件筛选 用 &amp; 链接 flights[ year == 2014 &amp; month == 6] # | 相当于中文条件或 flights[ month == 5 | month == 6] # %in% 类似sql中in用法 flights[month %in% c(1,3,5,7,9)] # %between% 类似sql中between and 用法 flights[month %between% c(1,7)] 7.1.3.2 j列操作 数据集较大、字段较多时，由于无效信息较多可以做适当精选，这时需要我们筛选列。与sql中的select用法一致，即保留想要的字段。 .()或list()是data.table中的比较特殊的实现列筛选的用法。常规数字索引，字符向量索引同样有效。 #注意前面的. .() flights[,.(year,month,day,dep_delay,carrier,origin)] # flights[,list(year,month,day,dep_delay,carrier,origin)] same above # not run # flights[,1:3] # not run # flights[,c(&#39;year&#39;,&#39;month&#39;,&#39;day&#39;)] setcolorder函数可以调整列的顺序，将常用的字段信息排在前面可以用过该函数实现。 # not run # setcolorder(x = flights,neworder = c( &quot;month&quot;,&quot;day&quot;,&quot;dep_delay&quot; ,&quot;arr_delay&quot;,&quot;carrier&quot; )) # 按照指定列顺序排序 其余字段保持不变,不是建立副本,是直接修改了flights 数据的列顺序 常规计算 根据最开始的Excel透视表截图，我们想要获得如截图一样的结果该怎么实现呢？代码如下： flights[year==2014 &amp; month==6,.(求和项distance=sum(distance),平均距离=mean(distance)),by=.(origin,dest)] 在i的位置做筛选，j的位置做计算，by指定分组字段。在j的位置可以做各种各样的计算，R中自带的函数，或者是自己定义的函数。 myfun &lt;- function(x){ x^2/2 } flights[year==2014 &amp; month==6,.(myfun(distance)),by=.(origin,dest)] 7.1.3.3 by 分组 分组是按照某种分组实现一定条件下某种聚合方式的计算。分组可以是单字段，多字段以及条件字段等。 1.按月分组 flights[,.(sum(distance)),by=.(month)] 2.多条件分组 dt &lt;- flights[,.(sum(distance)),by=.(carrier,origin)] head(dt) #可直接重新命名 dt &lt;- flights[,.(sum(distance)),by=.(newcol1 = carrier,newcol2 = origin)] head(dt) 3.按月份是否大于6分组 即得到是否大于6的两类分组 dt &lt;- flights[,.(sum(distance)),by=.(month&gt;6)] #by里面可以做计算 head(dt) 7.1.4 行列筛选总结 行筛选在 i 的位置上进行, 列筛选在 j 的位置上进行;data.table中j的位置比较灵活多变，但是i的位置大部分时候都是进行条件筛选。我们通过上述的行列筛选已经大概知道data.table中i,j的用法。也就是我们常规数据清洗过程中的数据筛选过程，筛选符合要求的数据记录。 dt &lt;- flights[ year == 2014 &amp; month == 6 &amp; day &gt;=15,.(year,month,day,dep_delay,carrier,origin)] head(dt) "],["常规操作.html", "7.2 常规操作", " 7.2 常规操作 7.2.1 行筛选 上文已经大致讲过行筛选，但是行筛选使用有一定的技巧，涉及到运算的快慢。主要是逻辑条件的设置，交集并集之间的差异。除了上文中的关系运算筛选，逻辑运算筛选除外，data.table中还有几个常用的筛选函数。 数字向量筛选 %in%用法与 sql 中 in 用法类似。 # 筛选 %in% flights[ hour %in% seq(1,24,2) ] 字符向量筛选 %chin%用法与 %in% 类似，但仅仅针对字符。 # 字符筛选 flights[ origin %chin% c(&#39;JFK&#39;,&#39;LGA&#39;)] # not run 同上 %chin% 对字符速度筛选速度更快 #flights[ origin %in% c(&#39;JFK&#39;,&#39;LGA&#39;)] between 筛选 该函数的新特性矢量化挺实用。 #between 函数参数 #between(x, lower, upper, incbounds=TRUE, NAbounds=TRUE, check=FALSE) X &lt;- data.table(a=1:5, b=6:10, c=c(5:1)) X[b %between% c(7,9)] X[between(b, 7, 9)] #效果同上 X[c %between% list(a,b)] # 矢量化 like 筛选 %like% 用法与SQL中 like 类似。 # %like% 用法与SQL中 like 类似 DT = data.table(Name=c(&quot;Mary&quot;,&quot;George&quot;,&quot;Martha&quot;), Salary=c(2,3,4)) DT[Name %like% &quot;^Mar&quot;] 7.2.2 新增更新列 新增或删除或更新列是我们数据清洗过程中的常规操作，data.table中实现该类功能是通过:=符号实现。 选择列 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) dt[,.(col1,col2)] # same above dt[,list(col1,col2)] 新增列 如下所示:新增addcol列，最后的[]是为了显示新增列的数据框,可不增加。 #data.table()函数创建data.table数据框 dt &lt;- data.table(col1=1:10,col2=letters[1:10],col3=LETTERS[1:10],col4=1:10) # 新增列 := dt[,addcol:=rep(&#39;新列&#39;,10)][] #最后的[]是为了显示新增列的数据框,可不增加 #dt[,addcol:=rep(&#39;新列&#39;,10)] 不会显示返回结果,加上[]会显示返回 # 新增多列 dt[,`:=`(newcol1=rep(&#39;newcol1&#39;,10),newcol2=rep(&#39;newcol2&#39;,10))][] 删除列 删除列即将列赋值NULL即可 # 删除列 dt[,col1:=NULL][] # 删除多列 dt[,c(&#39;newcol1&#39;,&#39;newcol2&#39;):=NULL][] 更新 更新即重新赋值，将现有列参与计算等于是重新赋值，可以看成是更新列。 # 更新列 dt[,col1:=11:20][] # not run # 两列间计算 也可以理解为更新 dt[,newcol:=col1/col4] Note: DT[a &gt; 4, b := c] is different from DT[a &gt; 4][, b := c] 7.2.3 排序 当我们清洗数据时，我们需要将数据框排序，我们可以使用setorder或setorderv函数实现排序。函数是data.table包的函数，比base R 中的order函数要节省内存。 注意：按照函数文档说法：Note that queries like x[order(.)] are optimised internally to use data.table’s fast order。即x[order(.)]这样的用法会被优化为data.table的排序方法。 set.seed(45L) DT = data.table(A=sample(3, 10, TRUE), B=sample(letters[1:3], 10, TRUE), C=sample(10)) setorder(DT, A, -B) #将DT按照A、B排序 A 升序,-B降序 # 和上面同样的效果 但是函数变成 setorderv setorderv(DT, c(&quot;A&quot;, &quot;B&quot;), c(1, -1)) "],["常用函数-1.html", "7.3 常用函数", " 7.3 常用函数 常用函数指我们常用功能的函数，如排名、排序、非重复计数、判断、表连接、长宽转换等功能。 7.3.1 特殊符号 .SD,.BY,.N,.I,.NGRP和.GRP,.SDcols等,只能用在 j 的位置,.N 可以用在 i 的位置。 如果想要记住用法需要自己多尝试练习，对于我来说.N使用较多。 DT = data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT X = data.table(x=c(&quot;c&quot;,&quot;b&quot;), v=8:7, foo=c(4,2)) X # 用在i的位置 DT[.N] #取DT最后一行,.N 计数函数 DT[,.N] #DT 共有多少行记录 返回一个整数 DT[, .N, by=x] #分组计数 DT[, .SD, .SDcols=x:y] # 选择x 到y 列 #DT[, .SD, .SDcols=c(&quot;x&quot;,&quot;y&quot;)] 与上面不一样 DT[, .SD[1]] #取第一行 DT[, .SD[1], by=x] #按x列分组后 DT[, c(.N, lapply(.SD, sum)), by=x] #按照x分组后 行数计数和每列求和 7.3.2 排序函数 frank和frankv函数参数如下： frank(x, ..., na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;last&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) frankv(x, cols=seq_along(x), order=1L, na.last=TRUE, ties.method=c(&quot;average&quot;, &quot;first&quot;, &quot;random&quot;, &quot;max&quot;, &quot;min&quot;, &quot;dense&quot;)) 官方案例,如下所示: # on vectors x = c(4, 1, 4, NA, 1, NA, 4) # NAs are considered identical (unlike base R) # default is average frankv(x) # na.last=TRUE frankv(x, na.last=FALSE) # on data.table DT = data.table(x, y=c(1, 1, 1, 0, NA, 0, 2)) frankv(DT, cols=&quot;x&quot;) # same as frankv(x) from before frankv(DT, cols=&quot;x&quot;, na.last=&quot;keep&quot;) frankv(DT, cols=&quot;x&quot;, ties.method=&quot;dense&quot;, na.last=NA) frank(DT, x, ties.method=&quot;dense&quot;, na.last=NA) # equivalent of above using frank frankv在排序时,NA被认为是一样的,基础base R 中认为不一样. x &lt;- c(4, 1, 4, NA, 1, NA, 4) frankv(x) rank(x) 升序降序选择 order参数只能为1或者-1.默认为1代表升序 frankv(x,order = 1L) frankv(x,order = -1L) 排序方式选择 默认 average,还有dense,random,first,last,max,min等方式。其中dense是紧凑排名，random是随机让相同的随机排列后排名 x &lt;- c(1,1,1,2,3) frankv(x) #大小相同 排名相同,下一位排名除以2 frankv(x,ties.method = &#39;min&#39;) #大小相同 排名相同,取最小排名 frankv(x,ties.method = &#39;max&#39;) #大小相同 排名相同,取最大排名 frankv(x,ties.method = &#39;first&#39;) #相同大小排名以后往后递增 根据实际情况决定 frankv(x,ties.method = &#39;dense&#39;) frankv(x,ties.method = &#39;random&#39;) NA处理 默认是将NA排在最后,NAs是相同的，与base R 不一样。 na.last参数等于TRUE时，缺失值被排最后；如果等于FALSE,放在前面；如果等于NA，将被移除；如果等于“keep,”将会保留NA. frankv(c(NA,NA,1,2,3), na.last = TRUE,ties.method = &#39;first&#39;) frankv(c(NA,NA,1,2,3), na.last = FALSE,ties.method = &#39;first&#39;) frankv(c(NA,NA,1,2,3), na.last = NA,ties.method = &#39;first&#39;) frankv(c(NA,NA,1,2,3), na.last = &#39;keep&#39;,ties.method = &#39;first&#39;) 7.3.3 非重复计数 uniqueN相当于length(unique(x)),但是计算更快，内存效率更高。 x &lt;-sample(1:10,50,replace = TRUE) uniqueN(x) DT &lt;- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3), C = rep(1:2, 6), key = &quot;A,B&quot;) uniqueN(DT, by = key(DT)) uniqueN(DT) 7.3.4 判断函数 fifelse fifelse()类似dplyr::if_else()函数,相比base::ifelse() 更快。 x &lt;- c(1:4, 3:2, 1:4,5) fifelse(x &gt; 2L, x, x - 1L) fifelse(x &gt; 2L,fifelse(x &gt;= 4L,x + 1L,x),x-1L) fcase 与sql中的case when，与dplyr中的case_when()函数用法相似。相比fifelse相比，嵌套更加方便。 x = 1:10 fcase( x &lt; 5L, 1L, x &gt; 5L, 3L ) # not run 两种函数实现方式 fifelse(x &gt; 5,fifelse(x &gt;8,2,1),0) fcase( x &gt; 8,2, x &gt; 5,1, default = 0 ) 7.3.5 交集 差集 合并 相当于base R 中 union(),intersect(),setdiff() 和setequal() 功能.all参数控制如何处理重复的行,和SQL中不同的是,data.table将保留行顺序. fintersect(x, y, all = FALSE) fsetdiff(x, y, all = FALSE) funion(x, y, all = FALSE) fsetequal(x, y, all = TRUE) x &lt;- data.table(c(1,2,2,2,3,4,4)) x2 &lt;- data.table(c(1,2,3,4)) # same set of rows as x y &lt;- data.table(c(2,3,4,4,4,5)) fintersect(x, y) # intersect fintersect(x, y, all=TRUE) # intersect all fsetdiff(x, y) # except fsetdiff(x, y, all=TRUE) # except all funion(x, y) # union funion(x, y, all=TRUE) # union all fsetequal(x, x2, all=FALSE) # setequal fsetequal(x, x2) # setequal all 7.3.6 长宽转换 主要是两个函数dcast以及melt实现长宽转换，实现Excel中部分透视表功能。具体的函数参数请自行查阅文档。 dcast函数能实现长转宽 参数如下：fun.aggregate函数指定聚合函数，value.var参数指定参与聚合的字段。formula指定聚合维度，格式用x+y~z，其中x,y在行的位置，z在列的位置。 dcast(data, formula, fun.aggregate = NULL, sep = &quot;_&quot;, ..., margins = NULL, subset = NULL, fill = NULL, drop = TRUE, value.var = guess(data), verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下： dt &lt;- data.table(分公司=rep(c(&#39;华东&#39;,&#39;华南&#39;,&#39;华西&#39;,&#39;华北&#39;),1000), 季度=rep(c(&#39;一季度&#39;,&#39;二季度&#39;,&#39;三季度&#39;,&#39;四季度&#39;),1000), 销售额=sample(100:200,4000,replace = TRUE)) dcast(dt,分公司~季度,value.var = &quot;销售额&quot;,fun.aggregate = sum) 从版本V1.9.6起可以同时对多个值实现不同聚合后的长转宽。 fun参数即 fun.aggregate的简写，可以是自定义的函数。 dt &lt;- data.table(x=sample(5,20,TRUE), y=sample(2,20,TRUE), z=sample(letters[1:2], 20,TRUE), d1 = runif(20), d2=1L) dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=c(&quot;d1&quot;,&quot;d2&quot;)) dcast(dt, x + y ~ z, fun=list(sum,mean), value.var=list(&quot;d1&quot;,&quot;d2&quot;)) #注意value.var是向量和列表时的区别 melt函数实现宽转长 melt(data, id.vars, measure.vars, variable.name = &quot;variable&quot;, value.name = &quot;value&quot;, ..., na.rm = FALSE, variable.factor = TRUE, value.factor = FALSE, verbose = getOption(&quot;datatable.verbose&quot;)) 示例如下: ChickWeight = as.data.table(ChickWeight) setnames(ChickWeight, tolower(names(ChickWeight))) DT &lt;- melt(as.data.table(ChickWeight), id=2:4) # calls melt.data.table DT 7.3.7 表连接 两个数据框之间左连,右连等操作,类似数据库中的left_join right_join,inner_join 等函数. 键入?merge()查看函数帮助,data.table 包中和base R 中都有merge 函数,当第一个数据框是data.table格式时启用data.table::merge(). ?merge() merge(x, y, by = NULL, by.x = NULL, by.y = NULL, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(&quot;.x&quot;, &quot;.y&quot;), no.dups = TRUE, allow.cartesian=getOption(&quot;datatable.allow.cartesian&quot;), # default FALSE ...) x.y为连个数据框,当两个数据框连接字段相同时,用by=c(’‘,’’)连接,不同时采用,by.x=,by.y= ,all,all.x,all.y等参数决定连接方式,sort 默认为排序,当不需要排序时更改参数,allow.cartesian=是否允许笛卡尔,默认不允许,当需要时设置为TURE. "],["高级函数.html", "7.4 高级函数", " 7.4 高级函数 高级函数并不是指使用难度，而是使用频率可能不高，但在实现某些功能时特别便利的函数。 如分组聚合的groupingsets,前后移动的shift等函数。 7.4.1 groupingsets 产生多个层次的合计数据，与sql中的grouping set功能相似。 用法 rollup(x, j, by, .SDcols, id = FALSE, ...) groupingsets(x, j, by, sets, .SDcols, id = FALSE, jj, ...) # rollup rollup(DT, j = lapply(.SD, sum), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE, .SDcols=&quot;value&quot;) rollup(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 如果要达到像Excel中透视表一样的效果，如下所示: Excel groupingsets透视表 rollup library(magrittr) DT &lt;- fread(&#39;./data/data-table-groupingsets.csv&#39;,encoding = &#39;UTF-8&#39;) (rollup(DT,j =list(以下项目的总和 =sum(value)),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) %&gt;% setorderv(cols=c(&#39;area&#39;,&#39;grouping&#39;),na.last = TRUE)) 通过上述计算,发现计算结果与Excel透视表一样。 cube 观察cube()计算结果与rollup()差异，发现cube()聚合层次更多。 cube(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),id = TRUE) groupingsets 根据需要指定指定聚合的层次。 # 与本例中rollup 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;), character()),id = TRUE) # 与本例中cube 结果一致 groupingsets(DT,j = sum(value),by = c(&quot;area&quot;,&quot;store_type&quot;),sets = list(&#39;area&#39;,c(&quot;area&quot;,&quot;store_type&quot;),&quot;store_type&quot;, character()),id = TRUE) groupingsets: sets参数,用list()包裹想要聚合的字段组合,最后character(),加上该部分相当于不区分层级全部聚合,用法类似sql中“().” SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ()); 7.4.2 rleid 该函数根据分组生成长度列。 即将0011001110111101类似这种分组成1 1 2 2 3 3 4 4 4 5 6 6 6 6 7 8。在特定时候是很便捷的一个函数。如在计算股票连续上涨或下跌天数时。 rleid(c(0,0,1,1,0,0,1,1,1,0,1,1,1,1,0,1)) 用法： rleid(..., prefix=NULL) rleidv(x, cols=seq_along(x), prefix=NULL) DT = data.table(grp=rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;), c(2,2,3,1,2)), value=1:10) rleid(DT$grp) # get run-length ids rleidv(DT, &quot;grp&quot;) # same as above rleid(DT$grp, prefix=&quot;grp&quot;) # prefix with &#39;grp&#39; 7.4.3 shift 向前或向后功能,通俗来说就是向前或向后移动位置。 示例如下： x = 1:5 # lag with n=1 and pad with NA (returns vector) shift(x, n=1, fill=NA, type=&quot;lag&quot;) 其中参数n控制偏移量，n正负数和type的参数相对应。, n=-1 and type=‘lead’ 与 n=1 and type=’lag’效果相同。 在data.table上使用： DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5]) cols = c(&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;) anscols = paste(&quot;lead&quot;, cols, sep=&quot;_&quot;) DT[, (anscols) := shift(.SD, 1, 0, &quot;lead&quot;), .SDcols=cols] 例如求某人连续消费时间间隔天数时： DT = data.table(dates =lubridate::ymd(c(20210105,20210115,20210124,20210218,20210424))) DT[,newdate:=shift(dates)] DT 通过构造新列newdate，然后将两列相减dates-newdate即可得到每次购物间隔天数。 7.4.4 J J 是.(),list()等的别名。SJ是排序连接，CJ是交叉连接。 用法： # DT[J(...)] # J() only for use inside DT[...] # DT[.(...)] # .() only for use inside DT[...] # DT[list(...)] # same; .(), list() and J() are identical SJ(...) # DT[SJ(...)] CJ(..., sorted=TRUE, unique=FALSE) # DT[CJ(...)] CJ 我喜欢用CJ()函数创建笛卡尔积表。例如在商品运营中，时常需要将门店和商品形成笛卡尔积表，相比起dplyr::full_join() ,data.table::merge.data.table(allow.cartesian = TRUE ),CJ更加方便快捷。 # CJ usage examples CJ(c(5, NA, 1), c(1, 3, 2)) # sorted and keyed data.table # do.call(CJ, list(c(5, NA, 1), c(1, 3, 2))) # same as above # CJ(c(5, NA, 1), c(1, 3, 2), sorted=FALSE) # same order as input, unkeyed SJ SJ : Sorted Join. The same value as J() but additionally setkey() is called on all columns in the order they were passed to SJ. For efficiency, to invoke a binary merge rather than a repeated binary full search for each row of i. "],["小技巧.html", "7.5 小技巧", " 7.5 小技巧 7.5.1 用{}抑制中间过程输出 默认只返回未命名花括号中定义的最后一个对象。 dt &lt;- data.table(mtcars) dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2)}, by=cyl] 在我不知道上述技巧之前，我可能的操作是 dt &lt;- data.table(mtcars) res &lt;- dt[,tmp1:=mean(mpg), by=cyl][,.(tmp2=mean(abs(mpg-tmp1))), by=.(cyl)] res[,.(round(tmp2,2)),by=.(cyl)][] 保留中间变量 dt[,{tmp1=mean(mpg); tmp2=mean(abs(mpg-tmp1)); tmp3=round(tmp2, 2); list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] 不写分号的方式 dt[,{tmp1=mean(mpg) tmp2=mean(abs(mpg-tmp1)) tmp3=round(tmp2, 2) list(tmp2=tmp2, tmp3=tmp3)}, by=cyl][] 7.5.2 使用[]打印data.table 在测试代码查看结果时很有用。 df &lt;- head(mtcars) # doesn&#39;t print (df &lt;- head(mtcars)) # does print # data.table way of printing after an assignment dt &lt;- data.table(head(mtcars)) # doesn&#39;t print dt[,hp2wt:=hp/wt][] # does print "],["运用.html", "7.6 运用", " 7.6 运用 7.6.1 自定义函数计算 1.自定义函数处理列 按照自定义函数计算修改单列或多列 # 测试函数 fun &lt;- function(x){ x &lt;- x^2+1 } DT &lt;- data.table(x=rep(c(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1) DT[,.(newcol=fun(y)),by=.(x)] #Not run #DT[,lapply(.SD,fun),.SDcols=c(&#39;y&#39;,&#39;a&#39;),by=.(x)] #多列参与计算 # 批量修改列 #Not run # myfun &lt;- function(x){ # return(x) # } # # dt &lt;- dt[,colnames(dt):=lapply(.SD[,1:ncol(dt)],myfun)] #很重要的用法 7.6.2 带汇总的聚合运算 按照by的字段级别汇总. rollup 分组聚合后设置id=TRUE将各个级别的汇总显示清晰,当by字段只有一个是和正常聚合计算没有区别.以下是官方案例. #Usage #rollup(x, j, by, .SDcols, id = FALSE, ...) n = 24L set.seed(25) DT &lt;- data.table( color = sample(c(&quot;green&quot;,&quot;yellow&quot;,&quot;red&quot;), n, TRUE), year = as.Date(sample(paste0(2011:2015,&quot;-01-01&quot;), n, TRUE)), status = as.factor(sample(c(&quot;removed&quot;,&quot;active&quot;,&quot;inactive&quot;,&quot;archived&quot;), n, TRUE)), amount = sample(1:5, n, TRUE), value = sample(c(3, 3.5, 2.5, 2), n, TRUE) ) rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;)) # default id=FALSE #rollup(DT, j = sum(value), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), id=TRUE) 个人运用,实际工作中常常需要汇总项,汇总项在Excel透视表中很简单,在R中我之前是构造重复的数据源聚合汇总出现汇总项,极大浪费内存,运算速度减慢. 新方法 rollup set.seed(25) N &lt;- 1000 dt &lt;- data.table(col1=sample(LETTERS[1:5],N,replace = T),col2=sample(letters[1:5],N,replace = T),num=1:N) rollup(dt,j=c(list(sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #同上 添加汇总项名称 total #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;)) #添加id=TRUE参数,多出的grouping 列显示聚合级别 #rollup(dt,j=c(list(total=sum(num))),by=c(&#39;col1&#39;,&#39;col2&#39;),id=TRUE) 2.groupingsets 按照指定字段聚合.包作者说相同与SQL中的 GROUPING SETS 操作.详情参照postgresql res &lt;- groupingsets(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c(&quot;color&quot;,&quot;year&quot;,&quot;status&quot;), sets = list(&quot;color&quot;, c(&quot;year&quot;,&quot;status&quot;), character()), id=TRUE) head(res) 注意groupingsets函数中sets参数,用list()包裹想要聚合的字段组合,最后还有一个character(),加上该部分相当于全部聚合.当by只有一个字段时,相当于汇总.用法类似sql中“().” 上述语句结果等同于下面sql. select color ,year, status,count(*) count,sum(amount) amount,sum(value) value FROM dbo.DT GROUP BY GROUPING SETS( (color), (year,status), () ---- 类似 character() ) 最后还有cube()函数,可?cube查看用法 7.6.3 行列转变 一列变多行 用tstrsplit()函数实现 n &lt;- 10 dt &lt;- data.table(name=LETTERS[1:n],char=rep(&#39;我-爱-R-语-言&#39;),n) res &lt;- dt[,.(newcol=tstrsplit(char,&#39;-&#39;)),by=.(name)] head(res) 多行变一列 res[,.(char=paste0(newcol,collapse = &#39;-&#39;)),by=.(name)] #同上 #res[,.(char=stringr::str_c(newcol,collapse = &#39;-&#39;)),by=.(name)] # A 我-爱-R-语-言 # B 我-爱-R-语-言 # C 我-爱-R-语-言 # D 我-爱-R-语-言 # E 我-爱-R-语-言 # F 我-爱-R-语-言 # G 我-爱-R-语-言 # H 我-爱-R-语-言 # I 我-爱-R-语-言 # J 我-爱-R-语-言 "],["database.html", "8 database", " 8 database 实际工作中，需要从数据库获取数据并清洗，R与数据库有多种交互方式,目前工作中打交道数据库主要是MSSQL,Oracle,mysql等,本文主要从以上数据库介绍记录“R与数据库的连接”。 R中与数据库交互的包主要有DBI,RODBC,RMySQL,ROracle,odbc等包。DBI库在查询或上传工作中效率比RODBC高,特别数据量较大时,上传效率差异巨大,具体差异请点击查看详情。 即使你暂时没有用数据库，也建议你未来用数据库存储数据，尤其是当有一定数据量时;在我最开始接触数据时，数据一般保存在Excel,那时候数据量大概在50万行左右，当公式较多，尤其时需要大批量vlookup时，Excel表格将会很卡顿。 "],["安装数据库.html", "8.1 安装数据库", " 8.1 安装数据库 如果暂时没有数据库使用经验，如果是使用Windows系统，直接去微软官网下载安装数据库即可。如果决定用R做数据分析相关工作，尤其时商业环境下，使用数据库有较强的必要性。安装数据库后，利用数据库做数据分析的练习测试也是不错的体验。另外也可以积累ETL相关经验。 仅简单介绍 MS SQL Server 安装 Win环境下安装 MS下载，选择开发版或精简版(Developer、Express)其中一个版本下载即可。 数据库下载 成功下载后，按照提示一步步确认即可安装成功。另外使用SSMS工具，微软配套的MS SQL SERVER数据库链接工具连接数据库。至于详细的数据库配置尤其是远程连接、账户等信息请自行查阅相关资料。 Linux环境下安装 官网安装指南 以下用于 SQL Server 2019 的命令指向 Ubuntu 20.04 存储库。 如果使用的是 Ubuntu 18.04 或 16.04，请将以下路径更改为 /ubuntu/18.04/ 或 /ubuntu/16.04/，而不是 /ubuntu/20.04/。 # 导入公共存储库的密钥 wget -qO- https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - # 为 SQL Server 2019 注册 Microsoft SQL Server Ubuntu 存储库 sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/20.04/mssql-server-2019.list)&quot; # sudo add-apt-repository &quot;$(wget -qO- https://packages.microsoft.com/config/ubuntu/18.04/mssql-server-2019.list)&quot; # 安装 SQL Server sudo apt-get update sudo apt-get install -y mssql-server # 验证服务是否运行 systemctl status mssql-server --no-pager 至于其他如安装sql server 命令行工具请查阅官网安装。 接下来我们就R语言与数据库的交互包展开介绍。 "],["dbi.html", "8.2 DBI", " 8.2 DBI 8.2.1 安装 install.packages(&#39;DBI&#39;) 8.2.2 连接数据库 连接MS SQL SERVER 通过以下代码即可连接到服务器172.16.88.2(即IP地址)的数据库，成功连接后即可与数据库交互。 library(DBI) con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;SQL Server&quot;, server = &quot;172.16.88.2&quot;,database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) 如果你用windows系统，通过DBI包连接数据库发现乱码时，根据数据库编码指定encoding参数即可，常规在win下连接sqlserver设置encoding = “GBK”。 library(DBI) #根据数据库编码方式指定encoding con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot;, encoding = &quot;GBK&quot; ) # 查看本机可用驱动 如缺少相应驱动则安装，ODBC Driver 17 for SQL Server 就是个人安装的驱动 Drivers_tbl &lt;- odbc::odbcListDrivers() head(Drivers_tbl) 查询数据库编码方式,从而选择连接数据库时相应的编码方式。 con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;ODBC Driver 17 for SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot; ) #查看编码是否是936 代表中文简体 sql &lt;- &quot;SELECT COLLATIONPROPERTY( &#39;chinese_prc_ci_as&#39;, &#39;codepage&#39; )&quot; dbGetQuery(con,sql) # same above # dbExecute(con,sql) # 用完后记得关闭数据库连接 DBI::dbDisconnect(con) 连接mysql MySQL()函数来源RMySQL包，用来创建&lt;MySQLDriver&gt;驱动，以下代码可连接到阿里云的MySQL数据库。 library(RMySQL) con &lt;- dbConnect(MySQL(), dbname = &quot;test&quot;, user = &quot;test_admin&quot;, password = &quot;30HL1234M7#￥lD6gxjB&quot;, host = &quot;prd-public-mypersonal.mysql.test.zhangjiabei.rds.aliyuncs.com&quot; ) 或者通过本地已安装驱动连接数据库 con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;MySQL ODBC 8.0 Unicode Driver&quot;, Server = &quot;localhost&quot;, UID = &quot;root&quot;, PWD = &quot;123456&quot;, Database = &quot;mysql&quot;, Port = 3306 ) mysql数据库默认端口是3306,访问不通时记得检查3306端口是否开放。 8.2.3 执行sql任务 dbGetQuery()函数处理由DBI包创建的con连接查询任务,dbExecute()执行一些数据库任务 # dbGetQuery 直接查询 res_table &lt;- dbGetQuery(con,&#39;select * from table&#39;) #直接获取sql查询结果 #dbReadTable直接读取 dbReadTable(con,&#39;tbl_name&#39;) #直接读取数据库中某表 # dbSendQuery 执行一个查询任务 res &lt;- dbSendQuery(conn = con,statement = &#39;select * FROM tab&#39;) dbFetch(res) dbClearResult(res) # dbExecute dbExecute(con,&#39;delete from table where num &lt;=1000&#39;) #类似任务 # dbWriteTable() # 上传数据,指定表名,需上传的数据框df,overwrite是否覆盖,append是否可追加 dbWriteTable(conn = con,name = &#39;表名&#39;,value = df,overwrite=TURE,append=FALSE) 8.2.4 函数介绍 查看数据库信息,查看表名,删除表，关闭连接等常用操作. con &lt;- dbConnect( drv = odbc::odbc(), Driver = &quot;ODBC Driver 17 for SQL Server&quot;, server = &quot;172.16.88.2&quot;, database = &quot;spb&quot;, uid = &quot;zhongyf&quot;, pwd = &quot;Zyf123456&quot;, encoding = &quot;GBK&quot; ) #查看数据版本连接信息 dbGetInfo(con) # 数据库中的全部表名 dbListTables(con) #win下中文表名还是会乱码 # 删除表 dbRemoveTable(con,&#39;tbl_name&#39;) # 关闭连接 dbDisconnect(con) "],["odbc包.html", "8.3 odbc包", " 8.3 odbc包 官方介绍：Connect to ODBC databases (using the DBI interface) 记录到此时，并不时特别清晰odbc与DBI之间的关系。 odbc可以运用于包括(SQL Server, Oracle, MySQL,PostgreSQL,SQLite)等odbc驱动程序于DBI兼容的接口，相比起来DBI包适用范围更广。 1.安装包 #安装包 install.packages(&#39;odbc&#39;) 2.连接数据库 连接数据库需要注意时区、编码，尤其是涉及到时间时时区如果设置有误，可能导致上传数据错误。 当你在Win系统上连接Sql Server时，如果你使用的数据库是中文环境时，最好设置encoding参数。 如果是linux上通过odbc连接SqlServer,一般情况下可以不用设置编码。如果还是乱码，在连接字符中设置字符编码charset=zh_CN.GBK，设置为gbk会报错。 library(odbc) con &lt;- odbc::dbConnect(odbc(), Driver = &quot;SQL Server&quot;, Server = &quot;Vega&quot;, Database = &quot;ghzy&quot;, Trusted_Connection = &quot;True&quot; ) # windows身份认证连接 # con &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;Driver={SQL Server}; # server=Vega;database=ghzy;uid=zhongyf;pwd=Zyf123456;&quot;, timeout = 10) con ## Not run # Win con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;,encoding = &#39;gbk&#39;) #Linux con_dd &lt;- dbConnect(odbc::odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2; database=aojo_dd;uid=wj;pwd=12qw#$ER;charset=zh_CN.GBK&quot;, timeout = 10) 3.查询 dt &lt;- odbc::dbGetQuery(con,&#39;select * from DT&#39;) head(dt) 4.写入数据库 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,overwrite = T ) # 是否覆盖 odbc::dbWriteTable(con,name = &#39;表名&#39;,value = dt,append = T ) # 是否追加 "],["rodbc包.html", "8.4 RODBC包", " 8.4 RODBC包 RODBC包是R语言对ODBC数据库接口,可以连接所有的ODBC数据库. 1.安装包 install.packages(&#39;RODBC&#39;) 2.SQL SERVER 数据库举例 library(RODBC) con &lt;- odbcDriverConnect(&quot;driver={SQL Server};server=192.168.2.62;database=dbname;uid=zhongyf;pwd=Zyf123456&quot;) con RODBC::sqlQuery(con,&#39;select * from test&#39;) 在WINDOWS机器上,需要知道本机是否有相应数据库的驱动程序. 查看本机上可用驱动 odbc::odbcListDrivers() 怎样安装驱动 请参照驱动安装 ODBC for sql server driver 下载地址地址 3.数据库字符串 请参照数据库连接字符串 #ODBC Driver 17 for SQL Server cn &lt;- odbcDriverConnect(&quot;Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=name;UID=username;PWD=123456;&quot;) #server 数据库 UID 数据库账户 PWD 数据库账户密码 sql server 请参照sql server连接字符串 "],["roracle包.html", "8.5 ROracle包", " 8.5 ROracle包 在第一次安装这个包时遇到了很多困难，首先需要安装oracle客户端，其次配置好环境变量，最后安装包。R与Oracle的连接需要安装Oracle Instant Client， 安装客户端 安装oracle客户端，根据电脑的位数选择相应的32位或64位，根据要连接数据库版本，可以去官网自行下载，本机需要下载的客户端地址 配置环境变量 根据自己所使用的系统，配置环境变量 OCI_INC=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\oci\\include&#39; OCI_LIB64=&#39;D:\\app\\zhongyf\\product\\11.2.0\\client_1\\BIN&#39; linxu上安装Roracle包，可以参考我的 微信公众号：宇飞的世界 公众号文章连接 安装包 安装Roracle包需要配置相应版本的Rtools并添加到环境变量，另外配置两个oracle的环境变量。代码中有注释,按照自己安装版本路径修改。 由于ROracle依赖于Oracle Instant Client,安装之前一定要先安装好客户端。 install.packages(&#39;ROracle&#39;) 连接数据库 Roracle可以通过DBI包链接，除了驱动和连接字符串有差异，其他部分一样。 library(ROracle) drv &lt;-dbDriver(&quot;Oracle&quot;) connect.string &lt;- &#39;(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.16.88.129)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = bidev) ))&#39; #连接字符串 con &lt;- dbConnect(drv,username = &quot;query&quot;, password = &quot;query&quot;,dbname = connect.string) 乱码问题 如果连接oracle数据库，中文乱码设置以下环境变量即可，或者在启动文件配置该环境变量。 linux下可以在文件Renviron中添加，记得引号，路径为[/opt/R/4.0.2/lib/R/etc/Renviron] # 查询数据库编码 select userenv(&#39;language&#39;) from dual Sys.setenv(NLS_LANG=&quot;SIMPLIFIED CHINESE_CHINA.AL32UTF8&quot;) "],["rmysql包.html", "8.6 RMySQL包", " 8.6 RMySQL包 RMySQL包的主要作用可以提供驱动与mysql数据库进行连接，在本机未安装mysql的驱动的情况下.该包正在逐渐被淘汰，可以使用RMariaDB包替换。 8.6.1 安装 Win系统下直接安装即可，其它平台下需提前安装依赖环境。 #On recent Debian or Ubuntu install libmariadbclient-dev sudo apt-get install -y libmariadbclient-dev #On Fedora, CentOS or RHEL we need mariadb-devel: sudo yum install mariadb-devel #On OS-X use mariadb-connector-c from Homebrew: brew install mariadb-connector-c install.packages(&#39;RMySQL&#39;) 8.6.2 连接使用 连接数据库，与上述连接方式基本一致。 library(RMySQL) con &lt;- RMySQL::dbConnect(drv = RMySQL::MySQL(),host=&#39;localhost&#39;,dbname=&quot;mysql&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) RMariaDB包与RMySQL包用法基本一致，在连接时注意驱动的选择即可。 install.packages(&#39;RMariaDB&#39;) library(RMariaDB) con &lt;- RMySQL::dbConnect(drv = RMariaDB::MariaDB() ,host=&#39;localhost&#39;,dbname=&quot;dbtest&quot;,username=&quot;root&quot;,password=&#39;123456&#39;) "],["常见问题-1.html", "8.7 常见问题", " 8.7 常见问题 在使用R包连接数据库时有些常见的问题，整理如下： 8.7.1 乱码问题 R中中文乱码问题一直都很麻烦，并且常常遇见，尤其是使用win系统时。 MS SQL SERVER 乱码 修改encoding参数，在win系统下，可以考虑使用RODBC包连接查询数据库，因为该包将自动转换编码，不会存在乱码问题。但是上传效率奇慢，为了减少包依赖保持代码一致性使用odbc连接数据库时遇到乱码，在连接数据库时设定encoding即可。 # win con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ SQLServer};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;gbk&quot; ) # linux con_spb &lt;- dbConnect(odbc(), .connection_string = &quot;driver={ODBC Driver 17 for SQL Server};server=172.16.88.2;database=spb;uid=zhongyf;pwd=Zyf123456&quot;, timeout = 10, timezone = &quot;Asia/Shanghai&quot;, encoding = &quot;utf8&quot; ) MySQL乱码 1.代码修改 #执行查询语句前执行 dbSendQuery(con,&#39;SET NAMES gbk&#39;) 2.ODBC配置 如果是通过ODBC数据源连接,可通过配置需改,如下所示： ODBC配置截图 8.7.2 无法连接问题 首先需要装mysql的驱动,确保RMySQL成功安装 如果是测试自己安装的mysql,可以先用Navicat连接,如果出现Authentication plugin ‘caching_sha2_password’ cannot be loaded的错误。 可能是由于 mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password,通过修改加密规则可解决无法连接问题。 --cmd 登录本地数据 mysql -u root -p --输入密码 password: --执行命令 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 ---ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; 看账号权限注意与上面的区别 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新一下用户的密码 8.7.3 远程连接 当你需要远程连接时，需要确保数据库的远程连接已经开启。在数据库中开启某账户远程连接权限,在公司的话，数据库连接问题咨询公司的IT人员。自己个人电脑上安装的MS SQL SERVER数据库需要自行开启远程连接。 另外如果是云服务器上搭建的数据库,需要开启数据库端口，如Mysql默认端口3306;如果是阿里云的Rds数据库,找DBA管理员要数据库地址以及端口信息。 "],["dbplyr.html", "8.8 dbplyr", " 8.8 dbplyr dbplyr将dplyr包的函数转化为SQL语句去服务器获取数据；在数据量较大、计算较多时，可以将远程连接数据库中的表当作内存中的数据框使用，当本机内存不够大时，这样做的好处不言而喻。 至于为什么使用dbplyr而不是直接编写SQL,因为： dbplyr写起来简洁高效，基本跟用dplyr没有差别 能利用数据库所在服务器的算力，配合上并行计算，在处理大量数据时，大大加快速度。 不同数据库的语法存在差异，当源数据存在不同数据库时，用R的dbplyr包清洗数据时能加快效率 通过dplyr动词方便实现复杂的逻辑，当过程越多越复杂时dbplyr的优势越明显，不用一层层嵌套语句。 8.8.1 基础用法 library(dplyr) library(dbplyr) mf &lt;- memdb_frame(x = 1, y = 2) mf %&gt;% mutate( a = y * x, b = a ^ 2, ) %&gt;% show_query() library(dplyr) #connect database con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = &quot;:memory:&quot;) # 上传数据 copy_to(con, nycflights13::flights, &quot;flights&quot;, temporary = FALSE, indexes = list( c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), &quot;carrier&quot;, &quot;tailnum&quot;, &quot;dest&quot; ) ) # 查看库中全部表名 #dbListTables(con) #tbl()引用表flights flights_db &lt;- tbl(con, &quot;flights&quot;) flights_db # 开始查询 flights_db %&gt;% select(year:day, dep_delay, arr_delay) flights_db %&gt;% filter(dep_delay &gt; 240) flights_db %&gt;% group_by(dest) %&gt;% summarise(delay = mean(dep_time)) 部分简单不复杂的sql语句可以用dplyr的语法代替. tailnum_delay_db &lt;- flights_db %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay,na.rm = T), n = n() ) %&gt;% arrange(desc(delay)) %&gt;% filter(n &gt; 100) tailnum_delay_db tailnum_delay_db %&gt;% show_query() tailnum_delay &lt;- tailnum_delay_db %&gt;% collect() #把数据从数据库加载到R内存中 8.8.2 无法正确转化 在使用过程中发现无法识别lubridate包的函数，但是dbplyr对于不认识的函数都将保留。 利用这个特性，可以使用数据库中原生的相关函数：如下所示，在Oracle中to_date函数 以下的自定义函数可以实现按照想要group_by的字段汇总金额、数量、吊牌额、折扣率等,其中关于时间周期的筛选就利用了该特性。 date #个人写的争对目前公司数仓写的包中获取销售数据的一段代码 get_sales_data &lt;- function(con,...,start_date,end_date,brand_name,channel_type = NULL ,area_name = NULL,boss_name = NULL,category_name = NULL,shop_no = NULL){ store_table &lt;- store(con,brand_name = brand_name,channel_type = channel_type ,area_name = area_name,boss_name = boss_name,shop_no = shop_no) #门店信息 sku_table &lt;- sku(con,category_name = category_name ) #商品信息 tbl(con, in_schema(&quot;DW&quot;, &quot;DW_SALE_SHOP_F&quot;)) %&gt;% #DW层 select(BILL_DATE1, SKU_NO, SHOP_NO, BILL_QTY, BILL_MONEY2, PRICE) %&gt;% filter(between( BILL_DATE1, to_date(start_date, &quot;yyyy-mm-dd&quot;), to_date(end_date, &quot;yyyy-mm-dd&quot;) )) %&gt;% mutate(年 = year(BILL_DATE1), 月 = month(BILL_DATE1)) %&gt;% inner_join(store_table) %&gt;% inner_join(sku_table) %&gt;% group_by(...) %&gt;% summarise( 金额 = sum(BILL_MONEY2, na.rm = TRUE), 数量 = sum(BILL_QTY, na.rm = TRUE), 吊牌金额 = sum(BILL_QTY * PRICE, na.rm = TRUE)) %&gt;% collect() %&gt;% mutate(折扣率:= 金额 / 吊牌金额) %&gt;% arrange(...) # return(res) } like mf %&gt;% filter(x %LIKE% &quot;%foo%&quot;) %&gt;% show_query() 特殊用法 特殊情况可以使用sql()函数 mf %&gt;% transmute(factorial = sql(&quot;x!&quot;)) %&gt;% show_query() "],["参考资料-2.html", "8.9 参考资料", " 8.9 参考资料 DBI包资料https://dbi.r-dbi.org/reference/ dbplyr包资料https://dbplyr.tidyverse.org/ rstudio关于数据库介绍 https://db.rstudio.com/databases 数据库连接字符串介绍 https://www.connectionstrings.com/ 个人博客关于Roracle的安装介绍 http://www.zhongyufei.com/2020/07/25/roracle-install/ https://www.r-consortium.org/blog/2017/05/15/improving-dbi-a-retrospect "],["loop-structure.html", "9 Loop structure", " 9 Loop structure 实际场景中,当需要重复做某动作时,可运用循环结构。 "],["简单示例.html", "9.1 简单示例", " 9.1 简单示例 利用循环实现1到100连续相加求和 total &lt;- 0 for(i in 1:100){ total &lt;- total+i } print(paste0(&#39;1到100连续相加求和等于:&#39;,total)) # loop structure # for (var in seq) {expr} "],["循环基础.html", "9.2 循环基础", " 9.2 循环基础 9.2.1 循环结构 R中有三种循环结构： Repeat i &lt;- 1 total &lt;- 0 repeat{ total &lt;- total+i i &lt;- i+1 if(i &gt; 100){ print(paste0(&#39;连续相加求和等于:&#39;,total)) break } } while i &lt;- 1 total &lt;- 0 while(i &lt;= 1000){ total &lt;- total+i i &lt;- i+1 } print(paste0(&#39;1到1000连续相加求和等于:&#39;,total)) # not run # sum(1:1000) for 代码如示例所示 library(tidyverse) df &lt;- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) output &lt;- vector(&quot;double&quot;, ncol(df)) # 1. output for (i in seq_along(df)) { # 2. sequence output[[i]] &lt;- median(df[[i]]) # 3. body } output 循环中尽可能利用R中的向量化,比如指定output的长度,当数据量大的时候效率提升将比较明显,养成向量化的意识对提高代码效率有显著效果. 上面代码中 vector函数创建一个空向量带指定长度，有两个参数，第一个时向量类型(‘逻辑,’‘整数,’‘双精度,’’字符’等)，第二个是向量长度 vector(length=5),类型默认是逻辑型. seq_along可以?seq查看用法. hadely 解释如下: You might not have seen seq_along() before. It’s a safe version of the familiar 1:length(l), with an important difference: if you have a zero-length vector, seq_along() does the right thing: #wrong seq_along(c()) 1:length(c()) # generates the integer sequence 1, 2, ..., length(along.with). (along.with is usually abbreviated to along, and seq_along is much faster.) 9.2.2 next break 用法 next 用法 for(i in letters[1:6] ){ if(i == &quot;d&quot;){ next } print(i) } break 用法 可以当条件满足时跳出循环常常与repeat循环结构配合使用。 9.2.3 嵌套循环 # not run v &lt;- vector(length = 100) for(i in 1:10){ for(j in 1:10){ v[i*j] = i * j } } "],["循环变化.html", "9.3 循环变化", " 9.3 循环变化 9.3.1 修改已有对象 res &lt;- 1:100 for(i in seq_along(res)){ res[i] &lt;- res[i] * i } str(res) 9.3.2 循环模式 共有三种遍历向量的方法,之前展示的都是遍历数字索引for (i in seq_along(xs)),并使用提取值x[[i]].还有两种方式: 循环遍历元素 for(i in xs),例如我们需要保存文件时,可以利用这种循环模式 遍历名称 for (nm in names(xs)),我们可以使用x[[nm]] 该名称访问.当我们要在文件名中使用名称时会比较方便. results &lt;- vector(&quot;list&quot;, length(x)) names(results) &lt;- names(x) 数字索引的循环模式最常用,因为可以根据位置提取名称和值. for (i in seq_along(x)) { name &lt;- names(x)[[i]] value &lt;- x[[i]] } 9.3.3 未知长度输出 有时候我们的循环我们不确定输出的长度是多少.这样会逐步增加向量的长度,如下所示： means &lt;- c(0, 1, 2) output &lt;- double() for (i in seq_along(means)) { n &lt;- sample(100, 1) output &lt;- c(output, rnorm(n, means[[i]])) } str(output) 但是这种方式浪费时间，当数据量大时候效率会很低下.因为时间复杂度为(\\(O(n^2)\\)).解决方案是将结果保存在列表中,然后在完成循环后合并为单个向量: out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)) { n &lt;- sample(100, 1) out[[i]] &lt;- rnorm(n, means[[i]]) } str(out) str(unlist(out)) #unlist将列表向量化 "],["iteration.html", "10 Iteration", " 10 Iteration 常常需要重复操作同样的功能函数，这时可以用迭代来实现。purrr包提供了一套完整的函数来处理循环迭代,可以有效减少重复性工作和代码。 https://purrr.tidyverse.org/ "],["简单用法.html", "10.1 简单用法", " 10.1 简单用法 map 用map循环迭代,map函数始终返回list对象。 library(tidyverse) # define function addTen &lt;- function(.x) { return(.x + 10) } map(.x = c(1, 4, 7), .f = addTen) # not run # map(c(1, 4, 7), addTen) # same above map_dbl 用map_dbl循环迭代，map_dbl函数返回vector。 #library(purrr) add1 &lt;- function(x) { (x+1)*x } result1 &lt;- map_dbl(1:1000,add1) # maP_dbl 输出结果为向量 #for版本 result2 &lt;- vector(length = 1000) for(i in 1:1000){ result2[i] &lt;- (i+1) * i } # test #not run #table(result1 == result2) # all equal identical(result1,result2) "],["map系列常用函数.html", "10.2 map系列常用函数", " 10.2 map系列常用函数 map_chr map_chr(.x, .f) ,map_chr 返回对象为字符串 map_dbl map_dbl(.x, .f) ,map_dbl 返回数字向量(双精度) map_df map_df(.x, .f),map_df 返回对象为数据框,类似函数 map_dfr(.x,.f),map_dfc(.x,.f) map_gl map_lgl(.x, .f) 返回逻辑向量 map_int map_int(.x, .f, ...) 返回整数 map_df()函数示例 # 采用匿名函数 map_df(c(1, 4, 7), function(.x) { return(data.frame(old_number = .x, new_number = addTen(.x))) }) #同上 #step1 定义函数 make_dataframe &lt;- function(x){ data.frame(old_number = x,new_number = addTen(x)) } #step2 计算 map_df(c(1,4,7),make_dataframe) "],["归约累计函数.html", "10.3 归约累计函数", " 10.3 归约累计函数 reduce、accumulate()函数用法介绍. reduce 在实际工作中,我长用reduce函数实现merge()功能。示例如下： reduce(1:100,`+`) reduce(100:1,`-`) 将函数功能不断运用到list上得到最后结果。 n &lt;- 10 dt1 &lt;- data.frame(a=letters[n],b1=rnorm(n)) dt2 &lt;- data.frame(a=letters[n],b2=rnorm(n)) dt3 &lt;- data.frame(a=letters[n],b3=rnorm(n)) dt4 &lt;- data.frame(a=letters[n],b4=rnorm(n)) reduce(list(dt1,dt2,dt3,dt4),merge) # not run # reduce(list(dt1,dt2,dt3,dt4),merge,by=&#39;a&#39;) same above accumulate 1:5 %&gt;% accumulate(`+`) accumulate(letters[1:5], paste, sep = &quot;.&quot;) "],["安全函数.html", "10.4 安全函数", " 10.4 安全函数 possibly() 和 safely(),当循环时候遇到错误报错导致整个程序停止,这不是我们想要的。 l &lt;- list(1,2,3,4,&#39;5&#39;) map(l,function(.x) .x+1) 以上程序将会报错,不能正确得到结果。 l &lt;- list(1,2,3,4,&#39;5&#39;) test_fun &lt;- safely(function(.x) .x+1) map(l,test_fun) 用safely()函数将原始function包裹起来,即使执行过程中遇到错误也可以完成整个任务,不会因为中途报错停止,在大型循环过程中,如爬虫过程中比较实用。 "],["映射多个参数.html", "10.5 映射多个参数", " 10.5 映射多个参数 map2 和 pmap 函数可以映射两个及以上参数。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) map2(li1,li2,`+`) 类似函数 map2_dbl,map2_chr,map2_dfr等等。 li1 &lt;- list(1,3,5) li2 &lt;- list(2,4,6) li3 &lt;- list(2,4,6) li1 &lt;- c(1,3,5) li2 &lt;- c(2,4,6) li3 &lt;- c(2,3,4) li &lt;- list(li1,li2,li3) pmap(li,sum) 同上有pmap_int,pmap_dbl,pmap_dfr等函数。 "],["其他函数介绍.html", "10.6 其他函数介绍", " 10.6 其他函数介绍 flatten flatten()系列函数可以将列表输出为稳定类型。purrr package 自带Examples。 x &lt;- rerun(2, sample(4)) x x %&gt;% flatten() x %&gt;% flatten_int() # You can use flatten in conjunction with map x %&gt;% map(1L) %&gt;% flatten_int() # But it&#39;s more efficient to use the typed map instead. x %&gt;% map_int(1L) imap imap()系列函数官方描述： imap_xxx(x, …), an indexed map, is short hand for map2(x, names(x), …) if x has names, or map2(x, seq_along(x), …) if it does not. This is useful if you need to compute on both the value and the position of an element. imap,当x有names(x)或者seq_along(x)属性,imap是map2的另一种表达方式。 使用公式快捷方式时,第一个参数是值(.x),第二个参数是位置/名称(.y)。 详情请查看:?imap 示例1： imap_chr(sample(10), ~ paste0(.y, &quot;: &quot;, .x)) sample(10),没有names(),只有长度信息。转化成map2表达如下: #same above map2_chr(sample(10),1:10,~paste0(.y,&quot;: &quot;,.x)) # 第二个list 为位置信息. "],["define-function.html", "11 define function", " 11 define function 函数功能使我们尽可能避免复制粘贴代码,而且需要更改的时候不需要大面积修改代码仅需要调整函数参数,使代码整体更加模块化. 假设有工作任务需要给商品SKU排名,在代码中需要重复以下代码5次,当区间需要修改的时候就是灾难. 原始代码示例如下: library(tidyverse) num &lt;- sample(1:1000,1000) res1 &lt;- if_else(num &lt;= 50,&quot;1-50&quot;, if_else(num &lt;= 100,&quot;51-100&quot;, if_else(num &lt;= 150,&quot;101-150&quot;, if_else(num &lt;= 200 ,&quot;151-200&quot;, if_else(num &gt;200,&quot;200以上&quot;,&#39;其他&#39;))))) # same above # case_when(num &lt;= 50 ~ &#39;1-50&#39;, # num &lt;= 100 ~ &#39;51-100&#39;, # num &lt;= 150 ~ &#39;101-150&#39;, # num &lt;= 200 ~ &#39;151-200&#39;, # num &gt; 100 ~ &#39;200以上&#39; # ) # 个人倾向data.table # data.table::fifelse() # data.table::fcase() 是sql中case when的实现 函数化后代码示例如下: 当需要修改区间时候仅仅只需要调整参数,而不必大量修改代码,当在脚本中需要调用多次时,能简洁代码. # 排名区间函数 #library(tidyverse) cut_function &lt;- function(vecto,x,n){ vec &lt;- c(0) for(i in 1:n){ kong &lt;- i*x vec &lt;- c(vec,kong) } vec &lt;- c(vec,Inf) labels &lt;- c() j &lt;- 1 while (j&lt;=n) { labels[j] &lt;- str_c(vec[j]+1,&quot;-&quot;,vec[j+1]) j &lt;- j+1 } labels &lt;- c(labels,paste0(vec[j],&#39;以上&#39;)) res &lt;- cut(x = vecto,breaks = vec,labels = labels) %&gt;% as.character() } res2 &lt;- cut_function(num,50,4) # identical(res1,res2) # &gt; TRUE 参考资料 "],["简单示例-1.html", "11.1 简单示例", " 11.1 简单示例 给函数取一个合适名字是很难的事情,徐尽可能从函数名称看出你实现的功能. add_ten &lt;- function(x){ res &lt;- x+10 return(res) #可以不用显示返回 } add_ten(1) 写函数时需要考虑函数使用情况,尽可能考虑容错情况,当输入不符合预期时能友好提示错误. add_ten &lt;- function(x){ if(is.numeric(x)==TRUE){ x+10 } else { print(&#39;Error,请输入数字&#39;) } } "],["条件执行.html", "11.2 条件执行", " 11.2 条件执行 has_name &lt;- function(x) { nms &lt;- names(x) if (is.null(nms)) { rep(FALSE, length(x)) } else { !is.na(nms) &amp; nms != &quot;&quot; } } 11.2.1 多条件执行 if (this) { # do that } else if (that) { # do something else } else { # } 当需要很多if时可考虑用switch()功能 function(x, y, op) { switch(op, plus = x + y, minus = x - y, times = x * y, divide = x / y, stop(&quot;Unknown op!&quot;) ) } "],["函数参数-1.html", "11.3 函数参数", " 11.3 函数参数 函数的参数通常分为两大类,一组是提供要计算的参数,另外一组提供计算时的细节参数. mean_ci &lt;- function(x, conf = 0.95) { se &lt;- sd(x) / sqrt(length(x)) alpha &lt;- 1 - conf mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2)) } x &lt;- runif(100) mean_ci(x) mean_ci(x, conf = 0.99) 11.3.1 参数名称 参数的名称很重要,方便我们理解参数含义,调用时不会混乱.以下时几个重要的参数名称 x, y, z: vectors. w: a vector of weights. df: a data frame. i, j: numeric indices (typically rows and columns). n: length, or number of rows. p: number of columns. 11.3.2 检查参数值 在写函数时,并不清楚最终函数的输出,在编写函数时进行约束是有必要的. wt_mean &lt;- function(x, w) { if (length(x) != length(w)) { stop(&quot;`x` and `w` must be the same length&quot;, call. = FALSE) } sum(w * x) / sum(w) } 11.3.3 …参数 R中的许多函数都能接受任意数量的输入： sum(1,2,3,4,5,6,7,8,9,10) stringr::str_c(&#39;a&#39;,&#39;b&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;) 下面的例子中 commas &lt;- function(...) stringr::str_c(..., collapse = &quot;, &quot;) commas(letters[1:10]) #&gt; [1] &quot;a, b, c, d, e, f, g, h, i, j&quot; rule &lt;- function(..., pad = &quot;-&quot;) { title &lt;- paste0(...) width &lt;- getOption(&quot;width&quot;) - nchar(title) - 5 cat(title, &quot; &quot;, stringr::str_dup(pad, width), &quot;\\n&quot;, sep = &quot;&quot;) } rule(&quot;Important output&quot;) "],["返回值.html", "11.4 返回值", " 11.4 返回值 11.4.1 显式返回 函数返回的通常是最后一句代码的计算结果,可以显式利用return()提前返回。但是R for Data Science 中作者说: ‘我认为最好不要使用return()来表示,您可以使用更简单的解决方案尽早返回’ A common reason to do this is because the inputs are empty: complicated_function &lt;- function(x, y, z) { if (length(x) == 0 || length(y) == 0) { return(0) } # Complicated code here } Another reason is because you have a if statement with one complex block and one simple block. For example, you might write an if statement like this: f &lt;- function() { if (x) { # Do # something # that # takes # many # lines # to # express } else { # return something short } } 11.4.2 编写管道函数 管道函数有两种基本类型: transformations and side-effects。使用transformations时，会将对象传递到函数的第一个参数，然后返回修改后的对象。使用side-effects时,不会对传递的对象进行转换。相反，该函数对对象执行操作，例如绘制图或保存文件。副作用函数应该“无形地”返回第一个参数，以便在不打印它们时仍可以在管道中使用它们。例如，以下简单函数在数据框中打印缺失值的数量： 以上从 R for Data Science 中翻译得来。 show_missings &lt;- function(df) { n &lt;- sum(is.na(df)) cat(&quot;Missing values: &quot;, n, &quot;\\n&quot;, sep = &quot;&quot;) invisible(df) } 以交互invisible()方式调用它,则意味着输入df不会被打印出来: show_missings(mtcars) 但是结果仍存在，默认情况下只是不打印显示出来: x &lt;- show_missings(mtcars) class(x) dim(x) 在管道中继续使用 mtcars %&gt;% show_missings() %&gt;% mutate(mpg = ifelse(mpg &lt; 20, NA, mpg)) %&gt;% show_missings() "],["环境.html", "11.5 环境", " 11.5 环境 环境是复杂的,建议阅读原文. The last component of a function is its environment. This is not something you need to understand deeply when you first start writing functions. However, it’s important to know a little bit about environments because they are crucial to how functions work. The environment of a function controls how R finds the value associated with a name. For example, take this function: f &lt;- function(x) { x + y } 在很多其他的编程语言中这样定义函数是错误的，因为没有定义y.在R中,这是有效的代码,因为R使用称为lexical scoping的方式寻找关联值.在函数内部没有定义y,将在上一层环境中查看y: y &lt;- 100 f(10) y &lt;- 1000 f(10) 具体详细的资料请查阅： https://r4ds.had.co.nz/functions.html#environment http://adv-r.had.co.nz/ "],["拓展部分.html", "11.6 拓展部分", " 11.6 拓展部分 在我之前工作中遇到需要分组计算时,我想要编写一个函数实现某些功能,但是分组的group_by()字段不一样时,导致代码没办法复用。 参考资料：https://dplyr.tidyverse.org/articles/programming.html #library(tidyverse) mean_mpg = function(data, group_col) { data %&gt;% group_by(group_col) %&gt;% summarize(mean_mpg = mean(mpg)) } mtcars %&gt;% mean_mpg(cyl) mtcars %&gt;% mean_mpg(gear) 当编写如下函数时,代码将成功运行 #自定义函数 my_summarise3 &lt;- function(data, group_var,mean_var, sd_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarise(mean = mean({{ mean_var }}), sd = mean({{ sd_var }})) } res1 &lt;- my_summarise3(data = mtcars,group_var = cyl,mean_var = carb,sd_var = gear) my_summarise3(data = mtcars,group_var = am,mean_var = carb,sd_var = gear) #正常写法 res2 &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarise(mean=mean(carb),sd=mean(gear)) identical(res1,res2) #res1 和res2 结果完全一致 以上my_summarise3()函数可以按照需求任意指定聚合汇总字段。 "]]
