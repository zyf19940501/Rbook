# 循环迭代purrr介绍{#purrr:Iteration}

循环结构是完成重复操作一个处理框架，但是无论是 for 循环还是 apply 系列中的各个迭代函数，对于初次接触编程者而言，理解起来都略微有挑战，无论是函数的参数多样性，还是完成同一目的方法的多样性。 purrr 包的出现，在很大程度上减少初学者对于循环上手的难度。purrr 包提供一套完整且一致的函数用于处理函数和向量的工具(函数)，极大增强了 R 语言里面函数式编程，让我们以更简洁的代码替换 for 循环。如下所示：

```{r eval=FALSE}
library(tidyverse)
mtcars %>%
  split(.$cyl) %>% 
  map( ~ write_excel_csv(.x,file = paste0(unique(.x$cyl),'.csv')))
```

将数据集 mtcars 按照 cyl 字段拆分成多个数据集，并分别保存为相应名称 csv 文件。


大家可以直接阅读官方介绍[purrr](https://purrr.tidyverse.org/)，或者阅读 R for Data Science 的[迭代](https://r4ds.had.co.nz/iteration.html)章节。



## 安装

安装 purrr 的最简单方法即安装tidyverse。

```{r eval=FALSE}
install.packages("tidyverse")
```

或者是仅仅安装 purrr:

```{r eval=FALSE}
install.packages("purrr")

# 安装开发版
devtools::install_github("tidyverse/purrr")
```


## 常规用法{#purrr:basic-usage}

### map 系列

- map

用map循环迭代,map函数始终返回list对象。

```{r message=FALSE,warning=FALSE}
library(tidyverse)
# 定义一个加10的函数
addTen <- function(.x) {
  return(.x + 10)
}
map(.x = c(1, 4, 7), .f = addTen)
```



- map_dbl

用map_dbl循环迭代，map_dbl函数返回vector。

```{r}

add1 <- function(x) {
  (x+1)*x
}
result1 <- map_dbl(1:1000,add1) 

```

`map_dbl()`输出结果格式为向量。

for 循环版本：

```{r}

result2 <- vector(length = 1000)
for(i in 1:1000){
  result2[i] <- (i+1) * i
}
# 检查结果是否一样
identical(result1,result2)
```

### pmap 系列

使用pmap可以实现多参数时的向量化迭代，功能极其强大。

```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)
z <- list(100, 200, 300)
pmap(list(x, y, z), sum)
```

借助数据框实现多个参数的向量化：

```{r}
df <- data.frame(
  x = c("apple", "banana", "cherry"),
  pattern = c("p", "n", "h"),
  replacement = c("P", "N", "H"),
  stringsAsFactors = FALSE
  )
pmap(df, gsub)
```


## map系列函数{#purrr:map}

### 用法

- `map()`返回列表(list)
- `map_lgl()`,`map_int()`,`map_dbl()`,`map_chr()`返回指定类型的原子向量,即逻辑型，整数型，实数型，字符型等。
- `map_dfr()` 和 `map_dfc()`返回通过指定的行连接或列连接创建的数据框(data.frame)

```{r eval=FALSE}
map(.x, .f, ...)

map_lgl(.x, .f, ...)

map_chr(.x, .f, ...)

map_int(.x, .f, ...)

map_dbl(.x, .f, ...)

map_raw(.x, .f, ...)

map_dfr(.x, .f, ..., .id = NULL)

map_dfc(.x, .f, ...)
```

在 purrr 中，参数`.f` 可以是一个 function，formula or vector,像 ~ .x + 2 这种形式的公式会被转换成 function 使用,关于参数的引用有如下三种方式：

1. 对一个参数，使用 . 即可
2. 两个参数,使用 .x 和 .y 
3. 对于更多参数，使用..1,..2,..3等等


对于像 ~ .x + 2 会转换成：

```{r}
function(x){
  x + 2
}

# ~ .x + . y

function(x,y){
  x + y
}

```


```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)
z <- list(100, 200, 300)

pmap(list(x,y,z),~ (..1 + ..2 ) * ..3)

```

~ (..1 + ..2 ) * ..3转换成：

```{r}
function(x,y,z){
  (x + y) * z
}

# pmap 实现
pmap(list(x,y,z),function(x,y,z) ( x + y ) *z)

```


> 对于 purrr 风格的公式，我们可以看自己心情，可以学习这种方式也可以不学，因为用 R 里面的 function 也可以完全满足需求

- map_chr

`map_chr(.x, .f)` ,map_chr 返回对象为字符串

```{r}
map_chr(letters,paste,'yufei-world',sep='-')
```


### 案例

- map 

`map()`函数返回列表，如下：

```{r eval=FALSE}
1:10 %>%
  map(rnorm, n = 10)

# 用匿名函数
1:10 %>%
  map(function(x) rnorm(10, x))

# purrr 风格公式
1:10 %>%
  map(~ rnorm(10, .x))
```


使用`map()`提取列表对象中的列表元素:

```{r}
l2 <- list(
  list(num = 1:3,     letters[1:3]),
  list(num = 101:103, letters[4:6]),
  list()
)
l2 %>% map(c(2, 2))
```

提取每个列表中的元素，上述代码表示提取列表中第二个对象的第二位置的元素：

```{r}
list(num = 1:3,letters[1:3])[[2]][2]
list(num = 101:103, letters[4:6])[[2]][2]
```

通过list构建由"名称"和"数字"构建的提取器提取元素：

```{r}
l2 %>% map(list("num", 3))
l2 %>% map_int(list("num", 3), .default = NA)
```


- map_dbl

`map_dbl()`返回数字向量(双精度)。

```{r}
1:10 %>%
  map(rnorm, n = 10) %>%  #输出列表
  map_dbl(mean)
```

在数据框上应用，由于数据框(data.frame)可以看成是特殊的列表，df[[1]],df[[2]],df[[3]]等。

```{r}
mtcars %>% map_dbl(sum)
```

上述计算可以理解为计算:sum(mtcars[[1]]),sum(mtcars[[2]]),sum(mtcars[[3]])等。

- map_chr

`map_chr()`返回字符向量。

```{r}
c("foo", "bar") %>% map_chr(paste0, ":suffix")

favorite_desserts <- list(Sophia = "banana bread", Eliott = "pancakes", Karina = "chocolate cake")
favorite_desserts %>% map_chr(~ paste(.x, "rocks!"))
```

- map_int

通过名字或者是数字位置提取内容。

```{r}
l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
l1 %>% map("a", .default = "???")
l1 %>% map_int("b", .default = NA)
l1 %>% map_int(2, .default = NA)
```


- map_df

`map_df(.x, .f)`,map_df 返回对象为数据框,类似函数 `map_dfr(.x,.f)`,`map_dfc(.x,.f)`



map_df()函数示例

```{r}
map_df(c(1, 4, 7), function(.x) {
  return(data.frame(old_number = .x, 
                    new_number = addTen(.x)))
})


make_dataframe <- function(x){
  data.frame(old_number = x,new_number = addTen(x))
}

map_dfr(c(1,4,7),make_dataframe)

```

在[数据导入导出](#data-read-write-description)章节中提到的[批量读取](#batch:read),通过指定全部要读取的文件列表，使用`map_dfr()`函数读取全部文件并合并数据源。

```{r eval=FALSE}
allfiles <- list.files(path = './data/read-write/',pattern = '^[a-z].xlsx$',full.names = T)
purrr::map_dfr(allfiles,read_excel)
```

> 在我实际工作中，实现传统零售行业门店之间商品调拨时就可使用该函数,更多详细信息可以查看我的语雀笔记。

## map2 系列函数

map2 系列函数是对 map 系列函数的升级，map 系列函数是一个列表参数，而 map2 系列是两个列表参数。常用函数如下：

```{r eval=FALSE}
map2(.x, .y, .f, ...)

map2_lgl(.x, .y, .f, ...)

map2_int(.x, .y, .f, ...)

map2_dbl(.x, .y, .f, ...)

map2_chr(.x, .y, .f, ...)

map2_raw(.x, .y, .f, ...)

map2_dfr(.x, .y, .f, ..., .id = NULL)

map2_dfc(.x, .y, .f, ...)

walk2(.x, .y, .f, ...)
```

两个列表相加

```{r}
x <- list(1, 1, 1)
y <- list(10, 20, 30)

map2(x, y, ~ .x + .y)
map2(x, y, `+`)
```

两个向量分别相加后构造新的数据框

```{r}
ex_fun <- function(arg1, arg2){
col <- arg1 + arg2
x <- as.data.frame(col)
}
arg1 <- 1:4
arg2 <- 10:13
map2_dfr(arg1, arg2, ex_fun)
map2_dfc(arg1, arg2, ex_fun)
```

两个列表中取较小值

```{r}
df <- data.frame(
  x = c(1, 2, 5),
  y = c(5, 4, 8)
)

pmin(df$x, df$y)
map2_dbl(df$x, df$y, min)
```

## pmap系列函数 {#purrr:multi-parameter}

pmap 系列函数可以映射多个(2个以上)参数，两个参数使用 map2 函数。


```{r eval=FALSE}
pmap(.l, .f, ...)

pmap_lgl(.l, .f, ...)

pmap_int(.l, .f, ...)

pmap_dbl(.l, .f, ...)

pmap_chr(.l, .f, ...)

pmap_raw(.l, .f, ...)

pmap_dfr(.l, .f, ..., .id = NULL)

pmap_dfc(.l, .f, ...)

pwalk(.l, .f, ...)
```



```{r}
li1 <- list(1,3,5)
li2 <- list(2,4,6)
li3 <- list(2,4,6)
li1 <- c(1,3,5)
li2 <- c(2,4,6)
li3 <- c(2,3,4)
li <- list(li1,li2,li3)
pmap(li,sum)
```

```{r}
df <- data.frame(
  x = 1:3,
  y = 10:12,
  z = letters[1:3]
)

plus2 <- function(x, y, ...) x + y
pmap_dbl(df, plus2)
```

> 注意上述代码中plus2函数的特殊性，运用了...参数

本章开始案例中的 pmap 函数的应用，将各种参数构造为 data.frame，运用好此特性，可以发挥强大作用。

```{r}
df <- data.frame(
  x = c("apple", "banana", "cherry"),
  pattern = c("p", "n", "h"),
  replacement = c("P", "N", "H"),
  stringsAsFactors = FALSE
  )
pmap(df, gsub)
```

对大部分数据分析师而言，掌握 map 系列以及 map 变种系列函数即可很好处理大部分数据问题。



## 归约累计函数{#purrr:reduce}

reduce、accumulate()函数用法介绍.

- reduce

在实际工作中,我长用reduce函数实现merge()功能。示例如下：

```{r}
reduce(1:100,`+`)
reduce(100:1,`-`)
```

将函数功能不断运用到 list 上得到最后结果。

```{r eval=FALSE}
n <- 10
dt1 <- data.frame(a=letters[n],b1=rnorm(n))
dt2 <- data.frame(a=letters[n],b2=rnorm(n))
dt3 <- data.frame(a=letters[n],b3=rnorm(n))
dt4 <- data.frame(a=letters[n],b4=rnorm(n))

reduce(list(dt1,dt2,dt3,dt4),merge)
# not run
# reduce(list(dt1,dt2,dt3,dt4),merge,by='a') same above

```


- accumulate

```{r}
1:5 %>% accumulate(`+`)
accumulate(letters[1:5], paste, sep = ".")
```


## 安全函数 {#purrr-safely-functions}

possibly() 和 safely(),当循环时候遇到错误报错导致整个程序停止,这不是我们想要的。

```{r eval=FALSE}
l <- list(1,2,3,4,'5')
map(l,function(.x) .x+1)

```

以上程序将会报错,不能正确得到结果。

```{r}
l <- list(1,2,3,4,'5')
test_fun <- safely(function(.x) .x+1)
map(l,test_fun)
```

用safely()函数将原始function包裹起来,即使执行过程中遇到错误也可以完成整个任务,不会因为中途报错停止,在大型循环过程中,如爬虫过程中比较实用。



## 其他函数介绍{#purrr:else-functions}

- flatten

flatten()系列函数可以将列表输出为稳定类型。purrr package 自带Examples。

```{r eval=FALSE}
x <- rerun(2, sample(4))
x
x %>% flatten()
x %>% flatten_int()
# You can use flatten in conjunction with map
x %>% map(1L) %>% flatten_int()
# But it's more efficient to use the typed map instead.
x %>% map_int(1L)
```

- imap

imap()系列函数官方描述：

imap_xxx(x, ...), an indexed map, is short hand for map2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...) if it does not. This is useful if you need to compute on both the value and the position of an element.


imap,当x有names(x)或者seq_along(x)属性,imap是map2的另一种表达方式。

使用公式快捷方式时,第一个参数是值(.x),第二个参数是位置/名称(.y)。

详情请查看:?imap

示例1：

```{r}
imap_chr(sample(10), ~ paste0(.y, ": ", .x))
```

sample(10),没有names(),只有长度信息。转化成map2表达如下:


```{r}
#same above

map2_chr(sample(10),1:10,~paste0(.y,": ",.x)) # 第二个list 为位置信息.

```

